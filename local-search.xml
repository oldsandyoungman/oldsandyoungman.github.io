<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【归】复习准备秋招第20天</title>
    <link href="/2022/07/25/2022-07-25-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC20%E5%A4%A9/"/>
    <url>/2022/07/25/2022-07-25-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC20%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a></p></blockquote><h4 id="P23"><a href="#P23" class="headerlink" title="P23"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=23">P23</a></h4><p>分页： <code>LIMIT a, b</code>，从第a条数据开始输出，输出b条数据</p><ul><li>8.0新特性，等效的写法：<code>LIMIT b OFFSET a</code>位置要变一下</li></ul><h4 id="P25"><a href="#P25" class="headerlink" title="P25"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=25">P25</a></h4><p>单表拆成多表的意义：</p><ul><li>减少冗余数据（有些行的字段为空）</li><li>增大数据IO（多表联查比单表查，因为上面的减少冗余，能查更多操作）</li><li>并行查询效率更高（单表查的并行效率肯定低）</li></ul><h4 id="P26"><a href="#P26" class="headerlink" title="P26"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=26">P26</a></h4><p>笛卡尔积的错误</p><ul><li>A表的每一行，都跟B表每一行乘了一次显示</li></ul><p>多表查询时，建议每个字段都加上表名（即使没有歧义）</p><ul><li>便于SQL优化</li></ul><p>多表查询时，FROM里可以给表名加别名，给SELECT，WHERE里用</p><ul><li>一旦起了别名，就不能用原名了</li></ul><h4 id="P27"><a href="#P27" class="headerlink" title="P27"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=27">P27</a></h4><p>非等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.last_name, e.salary, j.grade_level<br><span class="hljs-keyword">FROM</span> employees e, job_grades j<br><span class="hljs-keyword">WHERE</span> e.salary <span class="hljs-keyword">BETWEEN</span> j.lowest_sal <span class="hljs-keyword">AND</span> j.highest_sal;<br></code></pre></td></tr></table></figure><p>自连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.employee_id, e.last_name employee_name, e.manager_id, m.last_name manager_name<br><span class="hljs-keyword">from</span> employees e, employees m<br><span class="hljs-keyword">WHERE</span> e.manager_id <span class="hljs-operator">=</span> m.employee_id<br></code></pre></td></tr></table></figure><h4 id="P28"><a href="#P28" class="headerlink" title="P28"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=28">P28</a></h4><p>内连接：多表查询如果不满足条件，就不列出来</p><p>外连接：多表查询如果不满足条件，也要列出来</p><ul><li>左外连接：不满足的左表都列出来</li><li>右外连接：不满足的右表都列出来</li><li>满外连接：左右表不满足的都列出来</li></ul><h5 id="SQL92-使用-创建连接"><a href="#SQL92-使用-创建连接" class="headerlink" title="SQL92**:使用**(+)创建连接"></a>SQL92**:使用**(+)<strong>创建连接</strong></h5><p>在 SQL92 中采用(+)代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。</p><p>Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">#左外连接<br><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees ,departments<br><span class="hljs-keyword">WHERE</span> employees.department_id <span class="hljs-operator">=</span> departments.department_id(<span class="hljs-operator">+</span>);<br><br>#右外连接<br><span class="hljs-keyword">SELECT</span> last_name,department_name<br><span class="hljs-keyword">FROM</span> employees ,departments<br><span class="hljs-keyword">WHERE</span> employees.department_id(<span class="hljs-operator">+</span>) <span class="hljs-operator">=</span> departments.department_id;<br></code></pre></td></tr></table></figure><p>而且在 SQL92 中，只有左外连接和右外连接，没有满(或全)外连接。</p><h5 id="SQL99-使用JOIN-ON创建连接"><a href="#SQL99-使用JOIN-ON创建连接" class="headerlink" title="SQL99**:使用JOIN ON创建连接**"></a>SQL99**:使用<strong>JOIN ON</strong>创建连接**</h5><p><strong>内连接</strong>(INNER JOIN)<strong>的实现</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, city, department_name<br><span class="hljs-keyword">FROM</span>   employees e<br><span class="hljs-keyword">JOIN</span>   departments d<br><span class="hljs-keyword">ON</span>     d.department_id <span class="hljs-operator">=</span> e.department_id<br><span class="hljs-keyword">JOIN</span>   locations l<br><span class="hljs-keyword">ON</span>     d.location_id <span class="hljs-operator">=</span> l.location_id;<br></code></pre></td></tr></table></figure><p><strong>左外连接</strong>(LEFT OUTER JOIN)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.last_name, e.department_id, d.department_name<br><span class="hljs-keyword">FROM</span>   employees e<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span>   (e.department_id <span class="hljs-operator">=</span> d.department_id) ;<br></code></pre></td></tr></table></figure><p><strong>右外连接</strong>(RIGHT OUTER JOIN)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.last_name, e.department_id, d.department_name<br><span class="hljs-keyword">FROM</span>   employees e<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> departments d<br><span class="hljs-keyword">ON</span>    (e.department_id <span class="hljs-operator">=</span> d.department_id);<br></code></pre></td></tr></table></figure><h4 id="P29"><a href="#P29" class="headerlink" title="P29"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=29">P29</a></h4><blockquote><p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p></blockquote><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="304-Range-Sum-Query-2D-Immutable"><a href="#304-Range-Sum-Query-2D-Immutable" class="headerlink" title="304. Range Sum Query 2D - Immutable"></a><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/">304. Range Sum Query 2D - Immutable</a></h4><ul><li>这类前缀和，都是默认输入的小标是取到的，所以preSum[j+1]-preSum[i]，后面那个不需要额外加一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] preSum;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length+<span class="hljs-number">1</span>][matrix[<span class="hljs-number">0</span>].length+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 第一行第一列默认为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;preSum.length; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;preSum[<span class="hljs-number">0</span>].length; j++)&#123;<br>                preSum[i][j] = preSum[i-<span class="hljs-number">1</span>][j] + preSum[i][j-<span class="hljs-number">1</span>] + matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] - preSum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> preSum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>] - preSum[row2+<span class="hljs-number">1</span>][col1] - preSum[row1][col2+<span class="hljs-number">1</span>] + preSum[row1][col1];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第20天，看到<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a>的 P29 开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></li><li><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></li><li><a href="https://leetcode.cn/problems/O4NDxx/">剑指 Offer II 013. 二维子矩阵的和</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>阿尔贝·加缪</p><p>振奋昂扬，生存本身就是对荒诞最有力的反抗</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第19天</title>
    <link href="/2022/07/24/2022-07-24-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC19%E5%A4%A9/"/>
    <url>/2022/07/24/2022-07-24-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC19%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第19天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a></p></blockquote><h4 id="P15"><a href="#P15" class="headerlink" title="P15"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=15">P15</a></h4><p>字符串用单引号，别名用双引号</p><ul><li>如果乱用，mysql虽然不会报错（语法检查不严谨），但是oracle会报错</li></ul><p>distinct 只能放在所有字段最前面，加多个变量（其实没啥意义）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> department_id, salary <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p>着重号``:</p><ul><li>用于处理和关键字相同的表名</li></ul><p>查询常数：</p><ul><li>用于增加常亮字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, department_id, salary <span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><h4 id="P16"><a href="#P16" class="headerlink" title="P16"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=16">P16</a></h4><p>SQL 在windows里：</p><ul><li>对变量名，关键字啥的，不区分大小写</li><li>对字符串，是区分的<ul><li>但是mysql语法不严谨，所以你字符串大小写变了也是能查到的</li></ul></li></ul><p>where一定紧跟from，不能被分开</p><h4 id="P18"><a href="#P18" class="headerlink" title="P18"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=18">P18</a></h4><p>SQL 中，+ 没有concat作用，字符串如果是数字字符就隐式转成数字，不是的话就认为是0</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span> <span class="hljs-operator">+</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">FROM</span> DUAL # 返回的是 <span class="hljs-number">101</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span> <span class="hljs-operator">+</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">FROM</span> DUAL # 返回的是 <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>SQL 中，<code>/</code> 自动把数变成浮点型，而 <code>DIV</code> 会帮你自动截断成整型（无论你原来是不是浮点型）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span><span class="hljs-operator">/</span><span class="hljs-number">2</span> <span class="hljs-keyword">FROM</span> DUAL; # 返回 <span class="hljs-number">50.0000</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span> DIV <span class="hljs-number">2</span> <span class="hljs-keyword">FROM</span> DUAL; # 返回 <span class="hljs-number">50</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span> DIV <span class="hljs-number">3</span> <span class="hljs-keyword">FROM</span> DUAL; # 返回 <span class="hljs-number">33</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span> DIV <span class="hljs-number">3.0</span> <span class="hljs-keyword">FROM</span> DUAL; # 返回 <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p>SQL的除法和取模规则一样，除法看奇偶，取模看被模数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">12</span><span class="hljs-operator">/</span><span class="hljs-number">5</span>, <span class="hljs-number">12</span><span class="hljs-operator">/</span><span class="hljs-number">-5</span>, <span class="hljs-number">-12</span><span class="hljs-operator">/</span><span class="hljs-number">5</span>, <span class="hljs-number">-12</span><span class="hljs-operator">/</span><span class="hljs-number">-5</span> <span class="hljs-keyword">FROM</span> DUAL;  # <span class="hljs-number">2</span> <span class="hljs-number">-2</span> <span class="hljs-number">-2</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">12</span><span class="hljs-operator">%</span><span class="hljs-number">5</span>, <span class="hljs-number">12</span><span class="hljs-operator">%</span><span class="hljs-number">-5</span>, <span class="hljs-number">-12</span><span class="hljs-operator">%</span><span class="hljs-number">5</span>, <span class="hljs-number">-12</span><span class="hljs-operator">%</span><span class="hljs-number">-5</span> <span class="hljs-keyword">FROM</span> DUAL;  # <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">-2</span> <span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure><h4 id="P19"><a href="#P19" class="headerlink" title="P19"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=19">P19</a></h4><p>SQL 的 <code>=</code> 只要有一边是NULL，就是NULL，所以想单独选出NULL的数据列，不要用<code>WHERE xxx = NULL</code>，而是用安全等于<code>&lt;=&gt;</code>，<code>WHERE xxx &lt;=&gt; NULL</code>（和<code>WHERE xxx IS NULL</code>，<code>WHERE ISNULL(xxx)</code>效果一样 ）</p><ul><li>不等号<code>&lt;&gt;</code>，大于号<code>&gt;</code>等也一样，只要有一边是NULL，结果就是NULL</li><li>不为NULL，只有两种写法<code>WHERE xxx IS NOT NULL</code>，<code>WHERE NOT xxx &lt;=&gt; NULL</code></li></ul><p>字符串排序，是比较字典序，而不是长短</p><ul><li><code>&#39;ag&#39;</code>&gt; <code>&#39;abc&#39;</code></li></ul><p>BETWEEN xxx AND xxx，是闭区间，都取得到</p><p><strong>NOT 的两种位置</strong></p><ul><li><strong>如果后面直接跟了一个运算符式子（整体是一个boolean），那就加在前面</strong></li><li><strong>如果后面是关键字做成的，那么加在变量名前后都可以</strong></li></ul><p><code>%</code>代表 N 个任意字符</p><p><code>_</code>代表<code>1</code>个任意字符</p><ul><li><p>想表示字符<code>_</code>，用转义字符<code>\_</code>，或者自定义转义字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WHERE</span> xxx <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_$_a%&#x27;</span> <span class="hljs-keyword">ESCAPE</span> <span class="hljs-string">&#x27;$&#x27;</span>; # 代表找第二个字符是 <span class="hljs-string">&#x27;$&#x27;</span>，第四个字符是<span class="hljs-string">&#x27;a&#x27;</span>的字符串<br></code></pre></td></tr></table></figure></li></ul><p>常用正则表达式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br><span class="hljs-string">&#x27;shkstart&#x27;</span> REGEXP <span class="hljs-string">&#x27;^shk&#x27;</span>, # 以shk开头<br><span class="hljs-string">&#x27;shkstart&#x27;</span> REGEXP <span class="hljs-string">&#x27;t$&#x27;</span>, # 以t结尾<br><span class="hljs-string">&#x27;shkstart&#x27;</span> REGEXP <span class="hljs-string">&#x27;hk&#x27;</span> # 包含hk<br><span class="hljs-keyword">FROM</span> DUAL;<br><span class="hljs-keyword">SELECT</span> <br><span class="hljs-string">&#x27;atguigu&#x27;</span> REGEXP <span class="hljs-string">&#x27;gu.gu&#x27;</span>, # 包含一个字符串，其中第三位任意<br><span class="hljs-string">&#x27;atguigu&#x27;</span> REGEXP <span class="hljs-string">&#x27;[ab]&#x27;</span> # 包含一个a或b的字符<br><span class="hljs-keyword">FROM</span> DUAL;<br></code></pre></td></tr></table></figure><h4 id="P20"><a href="#P20" class="headerlink" title="P20"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=20">P20</a></h4><p><code>AND</code> 优先级 高于 <code>OR</code>    </p><p><code>~</code>：取反</p><p><code>^</code>：异或</p><h4 id="P22"><a href="#P22" class="headerlink" title="P22"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=22">P22</a></h4><p>没有设定排序操作，默认按添加顺序显示</p><p>升序降序排列<code>ORDER BY xx ASC/DESC</code>，默认是升序</p><p><strong>别名能在<code>ORDER BY</code>里使用，不能在<code>WHERE</code>里使用</strong></p><ul><li>因为SQL执行顺序是先 <code>FROM + WHERE</code>，再是 <code>SELECT</code>，再是<code>ORDER BY</code>，所以WHERE还不知道别名</li></ul><p>NULL 是升序排序的第一个，降序排序的最后一个</p><p>二级排序的例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, salary, department_id<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_id, salary <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">25. Reverse Nodes in k-Group</a></h4><ul><li>遍历K个节点的过程里，如果为null，就直接返回head，别忘了</li><li>这里面也是两步走<ul><li>递归调用子函数，表示前k个节点ok了</li><li>head的next指针，指向下一部分（<strong>注意下一部分要调用本函数</strong>）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span> || head.next==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode nextStart = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nextStart==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            nextStart = nextStart.next;<br>        &#125;<br>        ListNode last = reverseA2B(head, nextStart);<br>        head.next = reverseKGroup(nextStart, k);<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseA2B</span><span class="hljs-params">(ListNode head, ListNode nextStart)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.next==nextStart)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode last = reverseA2B(head.next, nextStart);<br>        head.next.next = head;<br>        head.next = nextStart;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第19天，看到<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a>的 P22 开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></li><li><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></li><li><a href="https://leetcode.cn/problems/aMhZSa/">剑指 Offer II 027. 回文链表</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>叔本华《人生的智慧》</p><p>谁要是不热爱独处，他就不热爱自由，因为只有当一个人独处的时候，他才是自由的。独处的时候，一个可怜虫就会感受到自己的全部可怜之处，一个具有伟大思想的人只会感觉到自己伟大的思想</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第18天</title>
    <link href="/2022/07/23/2022-07-23-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC18%E5%A4%A9/"/>
    <url>/2022/07/23/2022-07-23-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC18%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第18天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a></p></blockquote><h4 id="P11"><a href="#P11" class="headerlink" title="P11"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=11">P11</a></h4><p>表与表的关系：</p><ul><li>一对一</li><li>一对多</li><li>多对多</li><li>自关联</li></ul><h4 id="P12"><a href="#P12" class="headerlink" title="P12"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=12">P12</a></h4><p>SQL是一种语言规范，具体到各个厂商的数据库，就各自细节不同了</p><p>SQL的分类</p><ul><li>DDL：data defination language，数据定义语言</li><li>DML：data manipulation language，数据操作语言</li><li>DCL：data control language，数据控制语言</li></ul><h4 id="P13"><a href="#P13" class="headerlink" title="P13"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=13">P13</a></h4><p>SQL语句，一定以<code>;</code>，<code>\g</code>，<code>\G</code> 结束</p><p>sql大小写规范</p><p><img src="/2022/07/23/2022-07-23-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC18%E5%A4%A9/sql%E5%A4%A7%E5%B0%8F%E5%86%99%E8%A7%84%E8%8C%83.png" alt="sql大小写规范"></p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/">92. Reverse Linked List II</a></h4><ul><li>记得一定是 3步走：<ul><li>递归一句话，得到了 last</li><li>head.next，重新指向到head</li><li>head本身，指向null或者是suc</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;=<span class="hljs-number">2</span>)&#123;<br>            head.next = reverseBetween(head.next, left-<span class="hljs-number">1</span>, right-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> reverseK(head, right);<br>    &#125;<br>    <br>    ListNode suc = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseK</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>            suc = head.next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>        ListNode last = reverseK(head.next, k-<span class="hljs-number">1</span>);<br>        head.next.next = head;<br>        head.next = suc;<br>        <br>        <span class="hljs-keyword">return</span> last;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第18天，看到<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a>的 P13 开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></li><li><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></li><li><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></li><li><a href="https://leetcode.cn/problems/UHnkqh/">剑指 Offer II 024. 反转链表</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>阿尔贝·加缪《鼠疫》</p><p>人世间的罪恶几乎总是由愚昧无知造成，如果缺乏理解，好心能造成和恶意同样大的危害</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第17天</title>
    <link href="/2022/07/22/2022-07-22-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC17%E5%A4%A9/"/>
    <url>/2022/07/22/2022-07-22-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC17%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第17天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><p><strong>注意：整个新特性只是过了一遍，有了大致印象，之后如果用到再查：</strong></p><div class="row">    <embed src="尚硅谷_宋红康_第17章_Java9&amp;Java10&amp;Java11新特性.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="P695"><a href="#P695" class="headerlink" title="P695"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=695">P695</a></h4><p>Java9新特性</p><p><img src="/2022/07/22/2022-07-22-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC17%E5%A4%A9/Java9%E6%96%B0%E7%89%B9%E6%80%A7.png" alt="Java9新特性"></p><h4 id="P696"><a href="#P696" class="headerlink" title="P696"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=696">P696</a></h4><p>模块化</p><p><img src="/2022/07/22/2022-07-22-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC17%E5%A4%A9/%E6%A8%A1%E5%9D%97%E5%8C%961.png" alt="模块化1"></p><p><img src="/2022/07/22/2022-07-22-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC17%E5%A4%A9/%E6%A8%A1%E5%9D%97%E5%8C%962.png" alt="模块化2"></p><h4 id="P698"><a href="#P698" class="headerlink" title="P698"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=698">P698</a></h4><p>接口可以定义私有方法</p><h4 id="P708"><a href="#P708" class="headerlink" title="P708"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=708">P708</a></h4><p>Java 8 ：主打 stream</p><p>Java 9 ：主打 模块化</p><p>Java 10：主打 局部变量的类型推断</p><p>Java 11：主打 两种新的 gc</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a></p></blockquote><h4 id="P4"><a href="#P4" class="headerlink" title="P4"></a><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=4">P4</a></h4><p>4.1 <strong>关系型数据库</strong>(RDBMS)</p><p>4.1.1 **实质<br>** 这种类型的数据库是 最古老 的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系 (即二维表格形式)。</p><p>4.1.2 **优势<br>** <strong>复杂查询</strong> 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p><p><strong>事务支持</strong> 使得对于安全性能很高的数据访问要求得以实现。 4.2 <strong>非关系型数据库</strong>(<strong>非</strong>RDBMS)</p><p>4.2.1 **介绍<br>** <strong>非关系型数据库</strong>，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过SQL层</p><p>的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。 目前基本上大部分主流的非关系型数据库都是免费的。</p><p>4.2.2 **有哪些非关系型数据库<br>** 相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和</p><p>列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。 </p><p><strong>键值型数据库</strong></p><p>键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复 杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法 像关系型数据库一样使用条件过滤(比如 WHERE)，如果你不知道去哪里找数据，就要遍历所有的键， 这就会消耗大量的计算。</p><p>键值型数据库典型的使用场景是作为 内存缓存 。 Redis 是最流行的键值型数据库。</p><p><strong>文档型数据库</strong></p><p>此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位， 一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。</p><p><strong>搜索引擎数据库</strong></p><p>虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在 搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检 索的时候才能保证性能最优。核心原理是“倒排索引”。</p><p>典型产品:Solr、Elasticsearch、Splunk 等。 </p><p><strong>列式数据库</strong></p><p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储 (Row-based)，而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品:HBase等。</p><p><strong>图形数据库</strong></p><p>图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体(对象) 之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社 交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品: Neo4J、InfoGrid等</p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><a href="https://leetcode.com/problems/3sum/">15. 3Sum</a></h4><ul><li>不要用 Array.asList(1,2,3) 来初始化，这样返回的List不能修改（这个List跟你new ArrayList出来的class类型不一样，add没有被重写过，直接报错）</li><li>关于去重，用的是while，不是if</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; )&#123;<br>            <span class="hljs-keyword">int</span> target = -nums[i];<br>            List&lt;List&lt;Integer&gt;&gt; cur = twoSum(nums, target, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(List&lt;Integer&gt; t : cur)&#123;<br>                t.add(nums[i]);<br>                res.add(t);<br>            &#125;<br>            i++;<br>            <span class="hljs-keyword">while</span>(i&lt;nums.length &amp;&amp; nums[i]+target==<span class="hljs-number">0</span>)&#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> start)&#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> l = start;<br>        <span class="hljs-keyword">int</span> r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">int</span> numl = nums[l];<br>            <span class="hljs-keyword">int</span> numr = nums[r];<br>            <span class="hljs-keyword">int</span> sum = numl + numr;<br>            <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                r--;<br>                <span class="hljs-keyword">while</span>(r&gt;l &amp;&amp; nums[r]==numr)&#123;<br>                    r--;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;<br>                l++;<br>                <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l]==numl)&#123;<br>                    l++;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                tmp.add(numl);<br>                tmp.add(numr);<br>                res.add(tmp);<br>                r--;<br>                <span class="hljs-keyword">while</span>(r&gt;l &amp;&amp; nums[r]==numr)&#123;<br>                    r--;<br>                &#125;<br>                l++;<br>                <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l]==numl)&#123;<br>                    l++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a><a href="https://leetcode.com/problems/4sum/">18. 4Sum</a></h4><ul><li>for循环里，不要i++，不要手贱</li><li>最近出了新的溢出样例，记得用long类型检验一下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; res = nSum(nums, target, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>);<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; cur : res)&#123;<br>            <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : cur)&#123;<br>                sum += i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum&lt;Integer.MIN_VALUE || sum&gt;Integer.MAX_VALUE)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            result.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; nSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> start)&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(N==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">int</span> left = start;<br>            <span class="hljs-keyword">int</span> right = n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-keyword">int</span> ln = nums[left];<br>                <span class="hljs-keyword">int</span> rn = nums[right];<br>                <span class="hljs-keyword">int</span> s = ln+rn;<br>                <span class="hljs-keyword">if</span>(s&gt;target)&#123;<br>                    right--;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right]==rn)&#123;<br>                        right--;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&lt;target)&#123;<br>                    left++;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left]==ln)&#123;<br>                        left++;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                    tmp.add(ln);<br>                    tmp.add(rn);<br>                    res.add(tmp);<br>                    right--;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right]==rn)&#123;<br>                        right--;<br>                    &#125;<br>                    left++;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left]==ln)&#123;<br>                        left++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>            <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <br>            <span class="hljs-keyword">int</span> i = start;<br>            <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>                <span class="hljs-keyword">int</span> tt = target - nums[i];<br>                List&lt;List&lt;Integer&gt;&gt; tmp = nSum(nums, tt, N-<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">for</span>(List&lt;Integer&gt; cur : tmp)&#123;<br>                    cur.add(nums[i]);<br>                    <span class="hljs-comment">// res.add(cur);</span><br>                    res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(cur));<br>                &#125;<br>                i++;<br>                <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; nums[i]==target-tt)&#123;<br>                    i++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第17天，看到<a href="https://www.bilibili.com/video/BV1iq4y1u7vj">MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！</a>的 P6 开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></li><li><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></li><li><a href="https://leetcode.cn/problems/1fGaJU/">剑指 Offer II 007. 数组中和为 0 的三个数</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>伊曼努尔·康德</p><p>自由不是让你想做什么就做什么，自由是你想不做什么，就可以不做什么</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第16天</title>
    <link href="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/"/>
    <url>/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第16天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P641"><a href="#P641" class="headerlink" title="P641"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=641">P641</a></h4><p>类被加载到内存中时，称为运行时类，作为Class的一个实例</p><ul><li>万事万物皆对象有了进一步的解释：原来静态的属性怎么解释成对象的，现在可以说因为类本身也是个对象，所以顺理成章</li><li>Class的实例并不是new出来的，而是获取一个运行时类，拿来赋值的</li></ul><h4 id="P642"><a href="#P642" class="headerlink" title="P642"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=642">P642</a></h4><p>Class 获取实例的4种方法</p><ul><li><p>第三种更常用，因为真正体现了动态性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clazz</span> </span>= Class.forName(<span class="hljs-string">&quot;com.shasha.xxxx&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>注意：3种方法获取的都是内存中同一个地址，==判断为true</strong></p><h4 id="P643"><a href="#P643" class="headerlink" title="P643"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=643">P643</a></h4><p>哪些类型可以有class对象</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89class%E5%AF%B9%E8%B1%A1.png" alt="哪些类型可以有class对象"></p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%9C%89class%E5%AF%B9%E8%B1%A12.png" alt="哪些类型可以有class对象2"></p><h4 id="P644"><a href="#P644" class="headerlink" title="P644"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=644">P644</a></h4><p>类的加载过程</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类的加载过程"></p><p>复习：代码块和显示赋值，谁在上面谁先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">a</span></span>&#123;<br>  <span class="hljs-keyword">static</span>&#123;<br>    m = <span class="hljs-number">300</span>;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">100</span>; <span class="hljs-comment">// 最后结果为100</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P645"><a href="#P645" class="headerlink" title="P645"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=645">P645</a></h4><p>类加载器和类缓存</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E7%BC%93%E5%AD%98.png" alt="类加载器和类缓存"></p><p>类加载器的内部结构</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="类加载器的内部结构"></p><p><strong>注意：强行获取引导类加载器，返回值为null</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader classLoader = String.class.getClassLoader();<br>System.out.println(classLoader); <span class="hljs-comment">// 返回 null</span><br></code></pre></td></tr></table></figure><h4 id="P646"><a href="#P646" class="headerlink" title="P646"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=646">P646</a></h4><p>properties文件读取的两种方式</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/properties%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="properties文件读取的两种方式"></p><p><strong>注意：建议配置文件放到src下，因为部署到服务器下，工程文件下的东西都不复存在</strong></p><h4 id="P647"><a href="#P647" class="headerlink" title="P647"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=647">P647</a></h4><p>动态创建对象，依然用的是构造器</p><p>建议都提供public 的 空参构造器</p><ul><li>便于反射方法创建对象</li><li>便于子类调用空参构造器时，super()不报错</li></ul><h4 id="P650"><a href="#P650" class="headerlink" title="P650"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=650">P650</a></h4><p>获取运行时类的属性的各种参数</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0.png" alt="获取运行时类的属性的各种参数"></p><h4 id="P651"><a href="#P651" class="headerlink" title="P651"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=651">P651</a></h4><p>获取运行时类的方法结构</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84.png" alt="获取运行时类的方法结构"></p><h4 id="P652"><a href="#P652" class="headerlink" title="P652"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=652">P652</a></h4><p>框架 = 注解 + 反射 + 设计模式</p><h4 id="P655"><a href="#P655" class="headerlink" title="P655"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=655">P655</a></h4><p>动态代理：运行时，根据要处理的被代理类，查到其实现的接口，进而再找到代理类，进而再进行代理的操作</p><h4 id="P659"><a href="#P659" class="headerlink" title="P659"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=659">P659</a></h4><p>常用动态方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_reflect</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.shasha.s20220721.Person&quot;</span>);<br><br>        Person person = (Person) clazz.newInstance();<br><br>        Method show = clazz.getMethod(<span class="hljs-string">&quot;show&quot;</span>);<br>        show.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object res = show.invoke(person);<br>        System.out.println(res);<br><br>        Method sayHello = clazz.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>, String.class);<br>        sayHello.setAccessible(<span class="hljs-keyword">true</span>);<br>        sayHello.invoke(person, <span class="hljs-string">&quot;yes&quot;</span>);<br><br>        Method yep = clazz.getMethod(<span class="hljs-string">&quot;yep&quot;</span>);<br>        yep.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 静态方法，调用方法1</span><br>        yep.invoke(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// 静态方法，调用方法2</span><br>        yep.invoke(clazz);<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>        System.out.println(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">yep</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P660"><a href="#P660" class="headerlink" title="P660"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=660">P660</a></h4><p>三种创建对象的方式：</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="创建对象的3种方式"></p><h4 id="P662"><a href="#P662" class="headerlink" title="P662"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=662">P662</a></h4><p>动态代理</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="动态代理"></p><h4 id="P664"><a href="#P664" class="headerlink" title="P664"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=664">P664</a></h4><p>动态代理的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_dynamic_proxy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Superman s = <span class="hljs-keyword">new</span> Superman();<br>        Human proxy = (Human) ProxyFactory.getInstance(s);<br>        String belief = proxy.getBelief();<br>        System.out.println(belief);<br>        proxy.eat(<span class="hljs-string">&quot;rua&quot;</span>);<br><br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Human</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBelief</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String food)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superman</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Human</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBelief</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I can fly&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String food)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I love eat &quot;</span> + food);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Object o)</span></span>&#123;<br>        MyInvocationHandler handler = <span class="hljs-keyword">new</span> MyInvocationHandler();<br>        handler.bind(o);<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(o.getClass().getClassLoader(), o.getClass().getInterfaces(), handler);<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<br><br>    Object obj;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(Object o)</span></span>&#123;<br>        obj = o;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;额外处理点事儿&quot;</span>);<br>        Object res = method.invoke(obj, args);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="P665"><a href="#P665" class="headerlink" title="P665"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=665">P665</a></h4><p>AOP（Aspect Orient Programming）和动态代理的关系：</p><ul><li>感觉就是在动态代理部分，自己额外加的操作就是一些通用操作，而原来的method.invoke()就可以随便换，体现面向切面编程</li></ul><h4 id="P667"><a href="#P667" class="headerlink" title="P667"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=667">P667</a></h4><p>Java不一定是目前最好的语言（比较老了，上个世纪就出了），但是JVM一定是目前最强大的虚拟机（能跑Scalar，js）</p><h4 id="P668"><a href="#P668" class="headerlink" title="P668"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=668">P668</a></h4><p>lambda表达式 和 方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// 普通构造器</span><br>    Comparator&lt;Integer&gt; comparator1 = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(o1, o2);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">int</span> res1 = comparator1.compare(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(res1);<br><br>    System.out.println(<span class="hljs-string">&quot;*********************&quot;</span>);<br><br>  <span class="hljs-comment">// lambda 表达式</span><br>    Comparator&lt;Integer&gt; comparator2 = ((o1, o2) -&gt; Integer.compare(o1, o2));<br>    <span class="hljs-keyword">int</span> res2 = comparator2.compare(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(res2);<br><br>    System.out.println(<span class="hljs-string">&quot;*********************&quot;</span>);<br><br>  <span class="hljs-comment">// 方法引用</span><br>    Comparator&lt;Integer&gt; comparator3 = Integer ::compare;<br>    <span class="hljs-keyword">int</span> res3 = comparator3.compare(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(res3);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P669"><a href="#P669" class="headerlink" title="P669"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=669">P669</a></h4><p>lambda表达式的实质：接口的实例</p><h4 id="P671"><a href="#P671" class="headerlink" title="P671"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=671">P671</a></h4><p>lambda表达式的前提：函数式接口（只含有一个抽象方法的接口）</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" alt="函数式接口"></p><h4 id="P672"><a href="#P672" class="headerlink" title="P672"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=672">P672</a></h4><p>四大核心函数式接口</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png" alt="四大核心函数式接口"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><br>      List&lt;String&gt; l = Arrays.asList(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;45&quot;</span>,<span class="hljs-string">&quot;67&quot;</span>,<span class="hljs-string">&quot;890&quot;</span>);<br><br>      List&lt;String&gt; res = filterString(l, <span class="hljs-keyword">new</span> Predicate&lt;String&gt;() &#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(String s)</span> </span>&#123;<br>              <span class="hljs-keyword">return</span> s.contains(<span class="hljs-string">&quot;3&quot;</span>);<br>          &#125;<br>      &#125;);<br><br>      System.out.println(res);<br><br>      List&lt;String&gt; res2 = filterString(l, o -&gt; o.contains(<span class="hljs-string">&quot;3&quot;</span>));<br><br>      System.out.println(res2);<br><br><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">filterString</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;<br>      ArrayList&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-keyword">for</span> (String s : list) &#123;<br>          <span class="hljs-keyword">if</span>(pre.test(s))&#123;<br>              res.add(s);<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="P673"><a href="#P673" class="headerlink" title="P673"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=673">P673</a></h4><p>方法引用的要求：接口的抽象方法的形参列表和返回值类型都要和引用的方法一致</p><h4 id="P676"><a href="#P676" class="headerlink" title="P676"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=676">P676</a></h4><p>构造器引用，数组引用，之后再回顾，暂时没咋理解</p><ul><li><input disabled type="checkbox"> 之后</li></ul><h4 id="P677"><a href="#P677" class="headerlink" title="P677"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=677">P677</a></h4><p>stream_api的相关概念</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/stream_api%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.png" alt="stream_api的相关概念"></p><p>stream三步走</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/stream%E4%B8%89%E6%AD%A5%E8%B5%B0.png" alt="stream三步走"></p><h4 id="P678"><a href="#P678" class="headerlink" title="P678"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=678">P678</a></h4><p>stream实例化的4种方式</p><h4 id="P679"><a href="#P679" class="headerlink" title="P679"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=679">P679</a></h4><p>stream的常用API</p><ul><li>筛选和切片</li><li>映射</li><li>排序</li></ul><h4 id="P680"><a href="#P680" class="headerlink" title="P680"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=680">P680</a></h4><p>map 和 flatmap 的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <br>  List&lt;String&gt; l2 = Arrays.asList(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>,<span class="hljs-string">&quot;cc&quot;</span>,<span class="hljs-string">&quot;dd&quot;</span>,<span class="hljs-string">&quot;ee&quot;</span>);<br>  Stream&lt;Stream&lt;Character&gt;&gt; streamStream = l2.stream().map(Test_stream_map::string2stream);<br>  streamStream.forEach(s -&gt; &#123;<br>    s.forEach(System.out::println);<br>  &#125;);<br><br>  System.out.println();<br><br>  Stream&lt;Character&gt; characterStream = l2.stream().flatMap(Test_stream_map::string2stream);<br>  characterStream.forEach(System.out::println);<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title">string2stream</span><span class="hljs-params">(String s)</span></span>&#123;<br>  ArrayList&lt;Character&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>    l.add(c);<br>  &#125;<br>  <span class="hljs-keyword">return</span> l.stream();<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="P683"><a href="#P683" class="headerlink" title="P683"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=683">P683</a></h4><p>归约操作，没咋大懂，之后再回顾，暂时没咋理解</p><ul><li><input disabled type="checkbox"> 之后</li></ul><h4 id="P686"><a href="#P686" class="headerlink" title="P686"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=686">P686</a></h4><p>Optional的操作，其实就是借助Optional这个媒介，来回倒腾两次定义即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-keyword">null</span>;<br>Optional&lt;String&gt; s1 = Optional.ofNullable(s);<br>String s2 = s1.orElse(<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;345&quot;</span>));<br><br>System.out.println(s2);<br></code></pre></td></tr></table></figure><h4 id="P687"><a href="#P687" class="headerlink" title="P687"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=687">P687</a></h4><p>实现 Runnable 接口的 Thread类，实际上是一个被代理类，因为之后会把它的对象传给 Thread 类里，而 Thread 类再去调用start() 方法，start() 会自动调用run()方法，及代理类调用被代理类写的run()方法</p><h4 id="P691"><a href="#P691" class="headerlink" title="P691"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=691">P691</a></h4><p>Stream的注意点</p><p><img src="/2022/07/21/2022-07-21-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC16%E5%A4%A9/Stream%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9.png" alt="Stream的注意点"></p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></h4><ul><li>dp[0] 已经是dp[1] 和另外一个中的最大值，所以不需要再返回Math.max(dp[0], dp[1]) 了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            dp[i] = Math.max(dp[i+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">2</span>]+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></h4><ul><li>不包括最后一个的情况，可以重复利用上次的数组，只是dp[n-1]位置置为0即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-comment">// 不包括第一个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">1</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>            dp[i] = Math.max(dp[i+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">2</span>]+nums[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> max1 = dp[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 不包括最后一个</span><br>        dp[n-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            dp[i] = Math.max(dp[i+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">2</span>]+nums[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> max2 = dp[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-keyword">return</span> Math.max(max1, max2);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第16天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P693开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></li><li><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></li><li><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></li><li><a href="https://leetcode.cn/problems/Gu0c2T/">剑指 Offer II 089. 房屋偷盗</a></li><li><a href="https://leetcode.cn/problems/PzWKhm/">剑指 Offer II 090. 环形房屋偷盗</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>阿尔贝·加缪《鼠疫》</p><p>要了解一个城市，比较方便的途径不外乎打听：那里的人们怎么干活，怎么相爱，怎么死去</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第15天</title>
    <link href="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/"/>
    <url>/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第15天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P570"><a href="#P570" class="headerlink" title="P570"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=570">P570</a></h4><p>泛型方法可以声明为静态的，泛型参数是调用方法时确定的，并非在实例化时确定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 泛型方法可以是静态的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">E <span class="hljs-title">show</span><span class="hljs-params">(E e)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P571"><a href="#P571" class="headerlink" title="P571"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=571">P571</a></h4><p>泛型类 和 泛型方法 的 操作数据库 举例，可以再回顾体悟</p><h4 id="P572"><a href="#P572" class="headerlink" title="P572"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=572">P572</a></h4><p><code>List&lt;Object&gt;</code> 和 <code>List&lt;String&gt; b</code> 不具备子父类关系，不然下面例子的最后，a = b，那么a.add(123) 也不会报错，就引入了不匹配的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Object a = <span class="hljs-keyword">null</span>;<br>String b = <span class="hljs-keyword">null</span>;<br>a = b;<br><br>Object[] a = <span class="hljs-keyword">null</span>;<br>String[] b = <span class="hljs-keyword">null</span>;<br>a = b;<br><br>List&lt;Object&gt; a = <span class="hljs-keyword">null</span>;<br>List&lt;String&gt; b = <span class="hljs-keyword">null</span>;<br>a = b; <span class="hljs-comment">// 会报错，只有这一种不具备子父类关系</span><br><br></code></pre></td></tr></table></figure><h4 id="P573"><a href="#P573" class="headerlink" title="P573"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=573">P573</a></h4><p>解决上一p的尖括号内的子父类继承问题，就是引入通配符？，即<code>List&lt;?&gt;</code>  是  <code>List&lt;Object&gt;</code> 和 <code>List&lt;String&gt; b</code>  的公共父类，因此可以不用写一堆重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  List&lt;Object&gt; o = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  List&lt;String&gt; s = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  print(o);<br>  print(s);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;?&gt; cur)</span></span>&#123;<br>  Iterator&lt;?&gt; iterator = cur.iterator();<br>  <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>    Object o = iterator.next();<br>    System.out.println(o);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P574"><a href="#P574" class="headerlink" title="P574"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=574">P574</a></h4><p>通配符？不能写入任何元素（null除外，毕竟任何类型都可以赋值null），但是可以读取，赋值给Object类型</p><h4 id="P575"><a href="#P575" class="headerlink" title="P575"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=575">P575</a></h4><p>有限制条件的通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;? extends Person&gt; l1 = <span class="hljs-keyword">null</span>;<br>        List&lt;? <span class="hljs-keyword">super</span> Person&gt; l2 = <span class="hljs-keyword">null</span>;<br><br>        List&lt;Object&gt; l3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Person&gt; l4 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Student&gt; l5 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><br><span class="hljs-comment">//        l1 = l3; // 报错</span><br>        l1 = l4;<br>        l1 = l5;<br><br>        l2 = l3;<br>        l2 = l4;<br><span class="hljs-comment">//        l2 = l5; // 报错</span><br>        <br><span class="hljs-comment">//        l1.add(new Student()); // 报错，还是只能传null</span><br><span class="hljs-comment">//        l1.add(new Person()); // 报错，还是只能传null</span><br>        l2.add(<span class="hljs-keyword">new</span> Person());<br>        l2.add(<span class="hljs-keyword">new</span> Student());<br></code></pre></td></tr></table></figure><h4 id="P578"><a href="#P578" class="headerlink" title="P578"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=578">P578</a></h4><p>File的相关函数方法1</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/File%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%951.png" alt="File的相关函数方法1"></p><h4 id="P579"><a href="#P579" class="headerlink" title="P579"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=579">P579</a></h4><p>File的相关函数方法2</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/File%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%952.png" alt="File的相关函数方法2"></p><p>File的相关函数方法3</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/File%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%953.png" alt="File的相关函数方法3"></p><p><strong>注意：File的各种方法，都不涉及内容，内容的修改要用到IO流</strong></p><h4 id="P584"><a href="#P584" class="headerlink" title="P584"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=584">P584</a></h4><p>对于idea，如果是main方法，相对路径是整个工程，如果是单元测试，相对路径是在module下</p><h4 id="P585"><a href="#P585" class="headerlink" title="P585"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=585">P585</a></h4><p>不同分类：</p><ul><li>数据单位<ul><li>字节流： 8bit</li><li>字符流：16bit</li></ul></li><li>流的角色<ul><li>节点流：</li><li>处理流：节点流上外包的流</li></ul></li></ul><h4 id="P586"><a href="#P586" class="headerlink" title="P586"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=586">P586</a></h4><p>IO流的分类</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="IO流的分类"></p><p>第一行：抽象基类</p><p>第二行：节点流</p><p>第三行及以后：处理流</p><h4 id="P587"><a href="#P587" class="headerlink" title="P587"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=587">P587</a></h4><p>尽量用try-catch-finally，而不是throws，因为可能跳过了IO流的关闭，gc是关不掉流的</p><h4 id="P588"><a href="#P588" class="headerlink" title="P588"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=588">P588</a></h4><p>读入的基本用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">int</span> len;<br><span class="hljs-keyword">while</span>((len = fr.read(<span class="hljs-keyword">char</span>)!=-<span class="hljs-number">1</span>))&#123;<br>  String s = <span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, len);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P589"><a href="#P589" class="headerlink" title="P589"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=589">P589</a></h4><p>写入的操作，默认是覆盖，如果要追加，fw定义的时候，第二个参数变成true</p><h4 id="P592"><a href="#P592" class="headerlink" title="P592"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=592">P592</a></h4><p>用字节流来读文本，英文没啥问题（单位能用char处理），中文因为有3个字节，所以会乱码（除非中文占的3个字节，在一次性读的buffer[]内没有被截断）</p><p><strong>注意，读有问题是因为每次读buffer，如果全部操作完，整体再读（类似于复制），就没有任何问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream fi = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>            fi = <span class="hljs-keyword">new</span> FileInputStream(f);<br><br>            <span class="hljs-comment">// 读取方法1，中文一定会乱码</span><br>            <span class="hljs-keyword">int</span> res;<br>            <span class="hljs-keyword">while</span>((res = fi.read())!=-<span class="hljs-number">1</span>)&#123;<br>                System.out.print((<span class="hljs-keyword">char</span>)res);<br>            &#125;<br><br>            <span class="hljs-comment">// 读取方法2，中文会乱码(没有被截断)</span><br><span class="hljs-comment">//            byte[] buffer = new byte[5];</span><br><span class="hljs-comment">//            int len;</span><br><span class="hljs-comment">//            while((len=fi.read(buffer))!=-1)&#123;</span><br><span class="hljs-comment">//                System.out.print(new String(buffer, 0, len));</span><br><span class="hljs-comment">//            &#125;</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span>&#123;<br>          <span class="hljs-keyword">if</span> (fi!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    fi.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException ioException) &#123;<br>                    ioException.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>注意：doc文件因为会自动换行，插入图片，也不算文本文件</strong></p><h4 id="P596"><a href="#P596" class="headerlink" title="P596"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=596">P596</a></h4><p>Flush()：当前缓冲区内容输出，并清空缓冲区内容</p><h4 id="P597"><a href="#P597" class="headerlink" title="P597"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=597">P597</a></h4><p>读写操作的两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        BufferedReader bf = <span class="hljs-keyword">null</span>;<br>        BufferedWriter bw = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>            File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;hello2.txt&quot;</span>);<br>            FileReader fr = <span class="hljs-keyword">new</span> FileReader(f);<br>            FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(f2);<br>            bf = <span class="hljs-keyword">new</span> BufferedReader(fr);<br>            bw = <span class="hljs-keyword">new</span> BufferedWriter(fw);<br><br>            <span class="hljs-comment">// 读写方法1</span><br>            String res;<br>            <span class="hljs-keyword">while</span> ((res = bf.readLine())!=<span class="hljs-keyword">null</span>) &#123;<br>                bw.write(res);<br>            &#125;<br>            <span class="hljs-comment">// 读写方法2</span><br><span class="hljs-comment">//            int len = 0;</span><br><span class="hljs-comment">//            char[] buffer = new char[1024];</span><br><span class="hljs-comment">//            while((len = bf.read(buffer))!=-1)&#123;</span><br><span class="hljs-comment">//                bw.write(buffer, 0, len);</span><br><span class="hljs-comment">//            &#125;</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span>&#123;<br>          <span class="hljs-keyword">if</span> (bf!=<span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    bf.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException ioException) &#123;<br>                    ioException.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="P598"><a href="#P598" class="headerlink" title="P598"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=598">P598</a></h4><p>读取图片，并加密（对像素进行位运算）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>((len = bf.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>      buffer[i] = buffer[i]^<span class="hljs-number">5</span><br>    &#125;<br>    bw.write(buffer, <span class="hljs-number">0</span>, len);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P600"><a href="#P600" class="headerlink" title="P600"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=600">P600</a></h4><p>转换流：InputStreamReader 和 OutputStreamWriter</p><ul><li>InputStreamReader：字节 变 字符</li><li>OutputStreamWriter：字符 变 字节</li></ul><h4 id="P602"><a href="#P602" class="headerlink" title="P602"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=602">P602</a></h4><p>不同字符集</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E9%9B%86.png" alt="不同字符集"></p><p>GB2312  和 GBK 的原理</p><p>首位表示是一个字节还是两个字节：</p><ul><li>为0，表示1个字节</li><li>为1，表示2个字节</li></ul><p>UTF-8原理</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/UTF-8%E5%8E%9F%E7%90%86.png" alt="UTF-8原理"></p><p>不同字符集的关系</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="不同字符集的关系"></p><h4 id="P603"><a href="#P603" class="headerlink" title="P603"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=603">P603</a></h4><p>标准输入输出流的用法（System.in 得到的是InputStream，要用转换流转成 InputStreamReader，再用别的类似 BufferedReader 去操作）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">BufferedReader br = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>  InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(System.in);<br>  br = <span class="hljs-keyword">new</span> BufferedReader(isr);<br><br>  String res = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">while</span>((res = br.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;e&quot;</span>.equalsIgnoreCase(res))&#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    String uppercase = res.toUpperCase();<br>    System.out.println(uppercase);<br>  &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>  e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-keyword">if</span>(br!=<span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      br.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException ioException) &#123;<br>      ioException.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P605"><a href="#P605" class="headerlink" title="P605"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=605">P605</a></h4><p>数据流的读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>  DataOutputStream dos = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;hello.txt&quot;</span>));<br><br>  dos.writeUTF(<span class="hljs-string">&quot;123&quot;</span>);<br>  dos.flush();<br>  dos.writeInt(<span class="hljs-number">123</span>);<br>  dos.flush();<br>  dos.writeDouble(<span class="hljs-number">12.34</span>);<br><br>  dos.close();<br><br><br>  DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;hello.txt&quot;</span>));<br><br>  String s = dis.readUTF();<br>  System.out.println(s);<br>  <span class="hljs-keyword">int</span> i = dis.readInt();<br>  System.out.println(i);<br>  <span class="hljs-keyword">double</span> v = dis.readDouble();<br>  System.out.println(v);<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P610"><a href="#P610" class="headerlink" title="P610"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=610">P610</a></h4><p>System.in 返回的是抽象基类 InputStream</p><p>system.out 返回的是打印流 PrintStream</p><h4 id="P611"><a href="#P611" class="headerlink" title="P611"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=611">P611</a></h4><p>关于序列化</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E5%85%B3%E4%BA%8E%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="关于序列化"></p><h4 id="P613"><a href="#P613" class="headerlink" title="P613"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=613">P613</a></h4><p>对象流的要求：</p><ul><li>实现Serializable接口</li><li>有个 <code>static final long serialVersionUID</code> 的属性</li><li>所有成员变量/属性，都是可序列化的（基本数据类型默认是可以的）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_Object_Input_Output</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;hello.txt&quot;</span>));<br><br>        oos.writeObject(<span class="hljs-keyword">new</span> Sha(<span class="hljs-string">&quot;沙1&quot;</span>));<br>        oos.flush();<br>        oos.writeObject(<span class="hljs-keyword">new</span> Sha(<span class="hljs-string">&quot;沙2&quot;</span>));<br>        oos.flush();<br>        oos.writeObject(<span class="hljs-keyword">new</span> Sha(<span class="hljs-string">&quot;沙3&quot;</span>));<br>        oos.flush();<br><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;hello.txt&quot;</span>));<br><br>        Object o1 = ois.readObject();<br>        System.out.println(o1);<br>        Object o2 = ois.readObject();<br>        System.out.println(o2);<br>        Object o3 = ois.readObject();<br>        System.out.println(o3);<br><br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sha</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">4212412412414131L</span>;<br><br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sha</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sha&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P614"><a href="#P614" class="headerlink" title="P614"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=614">P614</a></h4><p>序列化UID的作用</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E5%BA%8F%E5%88%97%E5%8C%96UID%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="序列化UID的作用"></p><p><strong>注意：即使序列化后，又改了类的一些内容，只要你的UID不变，即使本地存的类信息是被修改后的，依然能反序列化还原出修改前的类的对象信息</strong></p><h4 id="P615"><a href="#P615" class="headerlink" title="P615"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=615">P615</a></h4><p>static，transient修饰的属性，不能序列化（反序列化的结果是默认值）</p><h4 id="P616"><a href="#P616" class="headerlink" title="P616"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=616">P616</a></h4><p>RandomAccessFile</p><ul><li>直接继承Object，而不是4个抽象基类</li><li>实现了 DataInput 和 DataOutput 两个接口（既可以做输入流，又可以做输出流）</li></ul><p>RandomAccessFile类的信息</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/RandomAccessFile%E7%B1%BB%E7%9A%84%E4%BF%A1%E6%81%AF.png" alt="RandomAccessFile类的信息"></p><h4 id="P617"><a href="#P617" class="headerlink" title="P617"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=617">P617</a></h4><p>RandomAccessFile 的使用</p><ul><li>seek() 的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>  RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>  RandomAccessFile raf2 = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><br>  <span class="hljs-comment">// 第一次写</span><br>  raf.write(<span class="hljs-string">&quot;abcdefghijklmn&quot;</span>.getBytes());<br><br>  <span class="hljs-comment">// 第一次读</span><br>  <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];<br>  <span class="hljs-keyword">while</span>((len = raf2.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>    System.out.print(<span class="hljs-keyword">new</span> String(buffer,<span class="hljs-number">0</span>,len));<br>  &#125;<br><br>  <span class="hljs-comment">// 第二次写</span><br>  raf.seek(<span class="hljs-number">3</span>);<br>  raf.write(<span class="hljs-string">&quot;xyz&quot;</span>.getBytes());<br><br>  <span class="hljs-comment">// 第二次读</span><br>  System.out.println();<br>  raf2.seek(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">while</span>((len = raf2.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>    System.out.print(<span class="hljs-keyword">new</span> String(buffer,<span class="hljs-number">0</span>,len));<br>  &#125;<br><br>  raf.close();<br>  raf2.close();<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意，RandomAccessFile的应用，例如下载的断点续传</strong></p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/RandomAccessFile%E7%9A%84%E5%BA%94%E7%94%A8_%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0.png" alt="RandomAccessFile的应用_断点续传"></p><h4 id="P618"><a href="#P618" class="headerlink" title="P618"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=618">P618</a></h4><p>NIO是基于缓冲区的，普通IO是基于流的</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E5%85%B3%E4%BA%8ENIO.png" alt="关于NIO"></p><p>关于Path，Paths，Files</p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E5%85%B3%E4%BA%8EPath_Paths_Files.png" alt="关于Path_Paths_Files1"></p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E5%85%B3%E4%BA%8EPath_Paths_Files2.png" alt="关于Path_Paths_Files2"></p><p><img src="/2022/07/20/2022-07-20-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC15%E5%A4%A9/%E5%85%B3%E4%BA%8EPath_Paths_Files3.png" alt="关于Path_Paths_Files3"></p><h4 id="P619"><a href="#P619" class="headerlink" title="P619"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=619">P619</a></h4><p>如何导第三方jar包</p><ul><li>建一个package，命名为“libs”，粘贴到该目录下</li><li>右键jar包，“add as Library…”，之后就能引用了</li></ul><h4 id="P623"><a href="#P623" class="headerlink" title="P623"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=623">P623</a></h4><p>UDP的数据包，最大不超过64K</p><h4 id="P624"><a href="#P624" class="headerlink" title="P624"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=624">P624</a></h4><p>socket通信的基本原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> </span>&#123;<br><br>      OutputStream outputStream = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          InetAddress inet = InetAddress.getLocalHost();<br>          Socket s = <span class="hljs-keyword">new</span> Socket(inet, <span class="hljs-number">8889</span>);<br><br>          outputStream = s.getOutputStream();<br><br>          outputStream.write(<span class="hljs-string">&quot;沙哥牛逼~~123&quot;</span>.getBytes());<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-keyword">if</span>(outputStream!=<span class="hljs-keyword">null</span>)&#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  outputStream.close();<br>              &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                  e.printStackTrace();<br>              &#125;<br>          &#125;<br><br>      &#125;<br><br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span>&#123;<br><br>      InputStreamReader isr = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8889</span>);<br>          Socket accept = ss.accept();<br><br>          InputStream inputStream = accept.getInputStream();<br><br>          isr = <span class="hljs-keyword">new</span> InputStreamReader(inputStream);<br><br>          <span class="hljs-keyword">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">5</span>];<br>          <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">while</span>((len = isr.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>              System.out.print(<span class="hljs-keyword">new</span> String(buffer,<span class="hljs-number">0</span>,len));<br>          &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-keyword">if</span>(isr!=<span class="hljs-keyword">null</span>) &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  isr.close();<br>              &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                  e.printStackTrace();<br>              &#125;<br>          &#125;<br>      &#125;<br><br><br><br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="P626"><a href="#P626" class="headerlink" title="P626"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=626">P626</a></h4><p>客户端传文件，服务端收到后，返回“收到”：</p><ul><li>如果客户端传完文件，没有明确告知传完，服务端会一直等待，及不会退出接收程序的循环<ul><li>需要额外客户端的socket，调用shutdownOutput() 一下</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>      <span class="hljs-comment">// 文件 输入流的定义</span><br>      FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;art_pig.jpg&quot;</span>);<br><br>      <span class="hljs-comment">// socket 输出流的定义</span><br>      InetAddress inet = InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>      Socket s = <span class="hljs-keyword">new</span> Socket(inet, <span class="hljs-number">8889</span>);<br>      OutputStream os = s.getOutputStream();<br><br>      <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5</span>];<br><br>      <span class="hljs-keyword">while</span>((len = fis.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>          os.write(buffer, <span class="hljs-number">0</span>, len);<br>      &#125;<br><br>      s.shutdownOutput();<br><br>      InputStream is = s.getInputStream();<br>      InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(is);<br>      <span class="hljs-keyword">char</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">5</span>];<br>      <span class="hljs-keyword">while</span>((len = isr.read(buf))!=-<span class="hljs-number">1</span>)&#123;<br>          System.out.print(<span class="hljs-keyword">new</span> String(buf, <span class="hljs-number">0</span>, len));<br>      &#125;<br><br>      isr.close();<br>      os.close();<br>      s.close();<br>      fis.close();<br><br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-comment">// 文件 输出流</span><br>      FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;art_pig2.jpg&quot;</span>);<br><br>      <span class="hljs-comment">// socket 输入流</span><br>      ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8889</span>);<br>      Socket s = ss.accept();<br>      InputStream is = s.getInputStream();<br><br>      <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5</span>];<br>      <span class="hljs-keyword">while</span>((len=is.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>          fos.write(buffer, <span class="hljs-number">0</span>, len);<br>      &#125;<br><br>      OutputStream os = s.getOutputStream();<br><br>      os.write(<span class="hljs-string">&quot;发送完成word沙&quot;</span>.getBytes());<br><br><br>      os.close();<br>      is.close();<br>      s.close();<br>      ss.close();<br>      fos.close();<br><br>  &#125;<br><br></code></pre></td></tr></table></figure><h4 id="P627"><a href="#P627" class="headerlink" title="P627"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=627">P627</a></h4><p>Tomcat服务器有空自己搭一下</p><h4 id="P628"><a href="#P628" class="headerlink" title="P628"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=628">P628</a></h4><p>UDP 的 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket();<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;UDP就是我~~&quot;</span>.getBytes();<br>        DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(bytes,<span class="hljs-number">0</span>,bytes.length, InetAddress.getLocalHost(),<span class="hljs-number">8889</span>);<br><br>        ds.send(dp);<br><br><br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">8889</span>);<br>        <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">100</span>];<br>        DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(buf,<span class="hljs-number">0</span>,buf.length);<br><br>        ds.receive(dp);<br><br>        System.out.println(<span class="hljs-keyword">new</span> String(dp.getData(),<span class="hljs-number">0</span>,dp.getLength()));<br><br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="P630"><a href="#P630" class="headerlink" title="P630"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=630">P630</a></h4><p>URL 下载图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_URL_download</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <br><span class="hljs-comment">//        https://c-ssl.duitang.com/uploads/item/201710/21/20171021211119_x2wWB.jpeg</span><br><br>        URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;https://c-ssl.duitang.com/uploads/item/201710/21/20171021211119_x2wWB.jpeg&quot;</span>);<br><br>        HttpURLConnection uc = (HttpURLConnection) url.openConnection();<br><br>        uc.connect();<br><br>        InputStream is = uc.getInputStream();<br><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;ppig.jpeg&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">while</span>((len=is.read(buffer))!=-<span class="hljs-number">1</span>)&#123;<br>            fos.write(buffer,<span class="hljs-number">0</span>,len);<br>        &#125;<br><br>        fos.close();<br>        is.close();<br>        uc.disconnect();<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P640"><a href="#P640" class="headerlink" title="P640"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=640">P640</a></h4><p>关于反射的应用讲得很好</p><ul><li>一个服务器正在运行，发来一个login 的URL，服务器代码不可能预测来的是什么，要调用哪个类，因此只能用反射的方式，通过url了解到想调login的类，因此用反射去造一个login类</li></ul><p>两个问题的解答：</p><ul><li>开发中应该用普通的直接new方法，还是反射方法<ul><li>大部分时候直接new，再需要动态确定的时候，采用反射的方法</li></ul></li><li>反射机制和面向对象的封装性是不是矛盾，如何看待<ul><li>不矛盾，一个是建议你用public的方法，这些public的方法被设计得更好（例如单例模式，你可以另外造对象，但是你操作了一堆最后实现的也无外乎我给你造的对象能实现的功能，因此我是强烈建议）；另一个是在证明能不能的问题（反射能达到任何你需要的操作目的）</li></ul></li></ul><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a></h4><ul><li>如何保存pre变量，要自己推演一下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-comment">//     public int maxProfit(int[] prices) &#123;</span><br><span class="hljs-comment">//         int n = prices.length;</span><br><span class="hljs-comment">//         //dp[i][j]:第i天，是否持有股票（j=1代表持有）</span><br><span class="hljs-comment">//         int[][] dp = new int[n+1][2];</span><br>        <br><span class="hljs-comment">//         dp[0][0] = 0;</span><br><span class="hljs-comment">//         dp[0][1] = -2500001;</span><br><span class="hljs-comment">//         dp[1][0] = 0;</span><br><span class="hljs-comment">//         dp[1][1] = -prices[0];</span><br>        <br><span class="hljs-comment">//         for(int i=2; i&lt;=n; i++)&#123;</span><br><span class="hljs-comment">//             dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i-1]);</span><br><span class="hljs-comment">//             dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0]-prices[i-1]);</span><br><span class="hljs-comment">//         &#125;</span><br>        <br><span class="hljs-comment">//         System.out.println(Arrays.deepToString(dp));</span><br>        <br><span class="hljs-comment">//         return Math.max(dp[n][0], 0);</span><br>        <br><span class="hljs-comment">//     &#125;</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = prices.length;<br>        <span class="hljs-comment">//dp[i][j]:第i天，是否持有股票（j=1代表持有）</span><br>        <span class="hljs-comment">// int[][] dp = new int[n+1][2];</span><br>        <br>        <span class="hljs-keyword">int</span> dp0_pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dp0_cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dp1 = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// dp[0][0] = 0;</span><br>        <span class="hljs-comment">// dp[0][1] = -2500001;</span><br>        <span class="hljs-comment">// dp[1][0] = 0;</span><br>        <span class="hljs-comment">// dp[1][1] = -prices[0];</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">int</span> tmp = dp0_cur;<br>            dp0_cur = Math.max(dp0_cur, dp1+prices[i-<span class="hljs-number">1</span>]);<br>            dp1 = Math.max(dp1, dp0_pre-prices[i-<span class="hljs-number">1</span>]);<br>            dp0_pre = tmp;<br>            <br>            <span class="hljs-comment">// System.out.println(dp0_cur + &quot;, &quot; + dp1);</span><br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> Math.max(dp0_cur, <span class="hljs-number">0</span>);<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第15天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P640开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></li><li><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>人生实如钟摆，在痛苦与倦怠之间摆动</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第14天</title>
    <link href="/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/"/>
    <url>/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第14天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P529"><a href="#P529" class="headerlink" title="P529"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=529">P529</a></h4><p>ArrayList底层源码</p><ul><li>JDK 7<ul><li>ArrayList list = new ArrayList(); 这句直接创建默认长度是 10 的 Object[] elementData</li><li>扩容是扩容到1.5倍 </li><li>建议开发中用带参构造器</li></ul></li><li>JDK 8<ul><li>ArrayList list = new ArrayList(); 这句没有创建默认长度是 10 的 Object[] elementData，只是把它初始化为 {}</li><li>第一次添加元素，才创建了默认长度是 10 的 Object[] elementData</li><li>后续与 JDK 7无异</li><li>类似单例创建模式的懒汉式，延迟数组创建，节省内存</li></ul></li></ul><p>快捷键：ctrl + F12，找当前类的函数</p><p>快捷键：shift + shift，搜索任意一个类或者函数啥的</p><h4 id="P531"><a href="#P531" class="headerlink" title="P531"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=531">P531</a></h4><p>Vector 底层源码： JDK 7 和 8 一样</p><ul><li>默认长度为10</li><li>扩容为原来数组 2 倍</li></ul><h4 id="P532"><a href="#P532" class="headerlink" title="P532"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=532">P532</a></h4><p>List的常用方法</p><p><img src="/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/List%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="List常用方法"></p><h4 id="P534"><a href="#P534" class="headerlink" title="P534"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=534">P534</a></h4><p>List的remove方法，优先考虑索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List l = <span class="hljs-keyword">new</span> ArrayList();<br>l.add(<span class="hljs-number">1</span>);<br>l.add(<span class="hljs-number">2</span>);<br>l.add(<span class="hljs-number">3</span>);<br>l.remove(<span class="hljs-number">2</span>); <span class="hljs-comment">// 删的是索引</span><br>l.remove(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 删的是元素</span><br></code></pre></td></tr></table></figure><h4 id="P535"><a href="#P535" class="headerlink" title="P535"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=535">P535</a></h4><p>Set：无序，不可重复</p><p>（以HashSet为例进行说明）</p><ul><li>无序：不等于随机性。底层数组存储时，不按照索引顺序添加，而是按照哈希值添加</li><li>不可重复：按hashCode() + equals()判断，是不可重复的</li></ul><p>Set接口各个实现类的异同：</p><ul><li>HashSet：线程不安全，可以存储null</li><li>LinkedHashSet：HashSet的子类，遍历时，能按照添加顺序返回<ul><li>对于频繁的遍历操作，效率高于HashSet（因为HashSet数组下一个位置可能为空）</li></ul></li><li>TreeSet：可以按照添加对象的指定属性，进行排序</li></ul><h4 id="P537"><a href="#P537" class="headerlink" title="P537"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=537">P537</a></h4><p>HashSet添加元素的整体流程：</p><ul><li>用hashCode()方法计算当前元素的hash值</li><li>用某种散列函数，计算出哈希值对应到底层数组的位置索引<ul><li>如果索引没数据，直接添加</li><li>如果索引有数据，依次对比每个元素：<ul><li>如果hashCode()算下来两者不同，直接添加</li><li>如果hashCode()算下来两者相同，再调用equals()进行比较，不同再添加</li></ul></li></ul></li></ul><h4 id="P538"><a href="#P538" class="headerlink" title="P538"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=538">P538</a></h4><p>为什么idea自动的hashcode()，总是会乘31：</p><p><img src="/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/hashCode%E7%9A%8431%E7%94%B1%E6%9D%A5.png" alt="hashCode的31由来"></p><p><strong>注意：Set中添加的对象，一定要重写过equals()和hashCode()</strong></p><p>hashCode() 和 equals() 的重写要求：</p><ul><li>equals()一样，hashCode() 也得一样</li><li>equals()用到的属性，hashCode()也要用到</li></ul><h4 id="P539"><a href="#P539" class="headerlink" title="P539"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=539">P539</a></h4><p>LinkedHashSet，依然是无序（指的是底层数组存储位置无序），但是另外维护了上下节点的引用</p><h4 id="P541"><a href="#P541" class="headerlink" title="P541"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=541">P541</a></h4><p>TreeSet 判断是否相等的方式，并不是equals，而是自然排序或者定制排序</p><ul><li><p>自然排序：自定义 compareTo()</p></li><li><p>定制排序：自己构造一个 Comparator，传入 TreeSet 的声明里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator comparator = <span class="hljs-keyword">new</span> Comparator()&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> Stu &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> Stu)&#123;<br>      Stu stu1 = (Stu) o1;<br>      Stu stu2 = (Stu) o2;<br>      <span class="hljs-keyword">return</span> Integer.compare(stu1.age, stu2.age);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();<br>  &#125;<br>&#125;;<br><br>TreeSet t = <span class="hljs-keyword">new</span> TreeSet(comparator);<br></code></pre></td></tr></table></figure></li></ul><h4 id="P542"><a href="#P542" class="headerlink" title="P542"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=542">P542</a></h4><p>Collection 接口必须实现的方法</p><ul><li>List：equals()<ul><li>contains，remove，retainsAll，都要用到</li></ul></li><li>HashSet，LinkedHashSet：equals()，hashCode()</li><li>TreeSet：comparable（compareTo()方法） 或者 comparator（compare(Object o1, Object o2)）</li></ul><h4 id="P544"><a href="#P544" class="headerlink" title="P544"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=544">P544</a></h4><p>快捷键：ctrl（mac里也依然是ctrl）+ H，查看某个类的继承关系</p><h4 id="P547"><a href="#P547" class="headerlink" title="P547"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=547">P547</a></h4><p>可以大胆将 List 和 Set相互转换，有相关的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List list = <span class="hljs-keyword">new</span> ArrayList();<br>list.add(<span class="hljs-number">1</span>);<br><br>HashSet set = <span class="hljs-keyword">new</span> HashSet();<br>set.addAll(list);<br>List newList = <span class="hljs-keyword">new</span> ArrayList(set);<br></code></pre></td></tr></table></figure><p>一个易错题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_HashSet_problem</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><br>        HashSet s = <span class="hljs-keyword">new</span> HashSet();<br>        Person p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;AA&quot;</span>);<br>        Person p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-number">1002</span>,<span class="hljs-string">&quot;BB&quot;</span>);<br><br>        s.add(p1);<br>        s.add(p2);<br>        System.out.println(s); <span class="hljs-comment">// 2个</span><br>        System.out.println(<span class="hljs-string">&quot;********************&quot;</span>);<br><br>        p1.name = <span class="hljs-string">&quot;CC&quot;</span>;<br>        s.remove(p1);<span class="hljs-comment">// 先算hashCode，发现对应数组位置上没有内容，所以觉得要删的对象不存在</span><br>        System.out.println(s); <span class="hljs-comment">// 2个</span><br>        System.out.println(<span class="hljs-string">&quot;********************&quot;</span>);<br><br>        s.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;CC&quot;</span>)); <span class="hljs-comment">// 同样计算hashCode，发现对应数组位置上没有内容，所以直接加</span><br>        System.out.println(s); <span class="hljs-comment">// 3个</span><br>        System.out.println(<span class="hljs-string">&quot;********************&quot;</span>);<br><br>        s.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;AA&quot;</span>)); <span class="hljs-comment">// 同样计算hashCode，发现对应数组位置上有内容Person(1001, &quot;CC&quot;)，再equals运算，发现不一样，添加</span><br>        System.out.println(s); <span class="hljs-comment">// 4个</span><br>        System.out.println(<span class="hljs-string">&quot;********************&quot;</span>);<br><br><br><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Person person = (Person) o;<br>        <span class="hljs-keyword">return</span> id == person.id &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(id, name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意，HashSet进行任何查值操作，永远都是先找hashCode对应的位置，如果有东西，再用equals判断</strong></p><h4 id="P548"><a href="#P548" class="headerlink" title="P548"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=548">P548</a></h4><p>Map</p><ul><li><p>HashMap：线程不安全，效率高；可以存储null 的 key 和 value</p><ul><li>LinkedHashMap：按照添加顺序实现遍历。频繁的遍历操作，效率高于HashMap</li></ul></li><li><p>TreeMap：底层使用红黑树，按照key进行排序</p></li><li><p>Hashtable：线程安全，效率低；不能存储null 的 key 或 value</p><ul><li>Properties：常用来处理配置文件，key-value都是String类型</li></ul></li></ul><p>常考面试题</p><ul><li>HashMap的底层实现原理</li><li>HashMap 和 HashTable 的异同</li><li>CurrentHashMap 和 Hashtable 的异同</li></ul><h4 id="P549"><a href="#P549" class="headerlink" title="P549"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=549">P549</a></h4><p>HashMap中，要重写 key 的 equals() 和 hashCode() 方法，重写 value 的 equals() 方法</p><h4 id="P552"><a href="#P552" class="headerlink" title="P552"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=552">P552</a></h4><p>HashMap的底层原理</p><p>JDK1.7</p><ul><li>HashMap m = new HashMap();<ul><li>底层创建了一个数组Entry[] table，默认长度（DEFAULT_INITIAL_CAPACITY）是16，并且初始化了一些其他参数（加载因子DEFAULT_LOAD_FACTOR0.75等）</li></ul></li><li>m.put(a, b);<ul><li>先计算这个键值对的哈希值（不止是hashcCode()，另外还做了些别的操作），进而&amp;15得到数组的下标位置<ul><li>如果该位置为空，则直接添加即可</li><li>如果不为空，遍历该位置的链表<ul><li>如果某一个节点计算equals()函数也一样，那么将新的value，替换旧的value</li><li>如果所有节点都不相等，那么判断是否满足扩容条件：当前元素数量是否超过threshold 16*0.75，并且插入的位置不为空<ul><li>两个条件都满足，就扩容，重新分配所有元素，再插入新的元素</li><li>两个条件不同时满足，直接插入新的键值对，键值对的next，指向原来的键值对</li></ul></li></ul></li></ul></li></ul></li></ul><p><strong>注意，resize()里有具体的扩容细节，不再展开</strong></p><p>JDK1.8 跟 1.7 的区别</p><ul><li><p>HashMap m = new HashMap();</p><ul><li>这一步底层没有创建数组</li><li>底层数组的名字变成了Node[]，但Node属性其实和原来的Entry一样</li></ul></li><li><p>m.put(a, b);</p><ul><li><p>如果第一次插入键值对，那么会创建数组Node[] table</p></li><li><p>在插入时，会考虑是否将链表变成红黑树</p><ul><li>如果当前位置的链表长度&gt;TREEIFY_THRESHOLD 8，并且数组整体的长度&gt;MIN_TREEIFY_CAPACITY 64，那么该位置的所有数据改为红黑树存储</li><li>如果当前位置的链表长度&gt;8，但数组整体的长度&lt;=64，那么只是进行扩容，不变成红黑树</li><li>如果当前位置的链表长度&lt;8，直接在链表上添加即可</li></ul></li><li><p>链表的添加方式变了，由原来的节点，指向新的节点</p></li></ul></li></ul><p>面试常问名词：</p><p><img src="/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/HashMap%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84%E5%90%8D%E8%AF%8D.png" alt="HashMap面试常问的名词"></p><p>负载因子过大过小的影响</p><p><img src="/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E8%BF%87%E5%A4%A7%E8%BF%87%E5%B0%8F%E7%9A%84%E5%BD%B1%E5%93%8D.png" alt="负载因子过大过小的影响"></p><h4 id="P554"><a href="#P554" class="headerlink" title="P554"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=554">P554</a></h4><p>LinkedHashMap 底层元素属性，多了 before 和 after，因此能按加入顺序遍历</p><p><img src="/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/LinkedHashMap%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7.png" alt="LinkedHashMap元素属性"></p><h4 id="P556"><a href="#P556" class="headerlink" title="P556"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=556">P556</a></h4><p>HashMap 的 3 种遍历方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap m = <span class="hljs-keyword">new</span> HashMap();<br>m.put(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">111</span>);<br>m.put(<span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-number">222</span>);<br>m.put(<span class="hljs-string">&quot;789&quot;</span>, <span class="hljs-number">333</span>);<br>m.put(<span class="hljs-string">&quot;000&quot;</span>, <span class="hljs-number">444</span>);<br><br><br>Set set = m.keySet();<br>Iterator iterator = set.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>  System.out.println(iterator.next());<br>&#125;<br>System.out.println();<br><br><br>Collection values = m.values();<br>Iterator iterator1 = values.iterator();<br><span class="hljs-keyword">while</span>(iterator1.hasNext())&#123;<br>  System.out.println(iterator1.next());<br>&#125;<br>System.out.println();<br><br><br>Set set1 = m.entrySet();<br>Iterator iterator2 = set1.iterator();<br><span class="hljs-keyword">while</span>(iterator2.hasNext())&#123;<br>  Object tmp = iterator2.next();<br>  Map.Entry e = (Map.Entry)tmp;<br>  System.out.println(e + <span class="hljs-string">&quot; , &quot;</span> + e.getKey() + <span class="hljs-string">&quot; , &quot;</span> + e.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P558"><a href="#P558" class="headerlink" title="P558"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=558">P558</a></h4><p>Properties 类的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream fi = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>  Properties pro = <span class="hljs-keyword">new</span> Properties();<br>  fi = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;test_properties.properties&quot;</span>);<br>  pro.load(fi);<br><br>  String name = pro.getProperty(<span class="hljs-string">&quot;name&quot;</span>);<br>  String age = pro.getProperty(<span class="hljs-string">&quot;age&quot;</span>);<br><br>  System.out.println(name);<br>  System.out.println(age);<br><br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>  e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>  e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  <span class="hljs-keyword">if</span> (fi!=<span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      fi.close();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P559"><a href="#P559" class="headerlink" title="P559"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=559">P559</a></h4><p>Collections 和 Collection 的区别</p><ul><li>Collections 是操作Collection 和 Map 的工具类</li><li>Collection 是创建各种集合的接口</li></ul><p>Collections的常用函数：</p><p><img src="/2022/07/19/2022-07-19-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC14%E5%A4%A9/Collections%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0.png" alt="Collections的常用函数"></p><p><strong>注意：copy的使用要先初始化等长集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>l.add(<span class="hljs-number">1</span>);<br>l.add(<span class="hljs-number">5</span>);<br>l.add(<span class="hljs-number">2</span>);<br>l.add(<span class="hljs-number">4</span>);<br>l.add(<span class="hljs-number">3</span>);<br><br>List l2 = Arrays.asList(<span class="hljs-keyword">new</span> Object[l.size()]);<br>Collections.copy(l2, l);<br>System.out.println(l2);<br></code></pre></td></tr></table></figure><p>关于ArrayList，Hashmap转成线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>l.add(<span class="hljs-number">1</span>);<br>l.add(<span class="hljs-number">5</span>);<br>l.add(<span class="hljs-number">2</span>);<br>l.add(<span class="hljs-number">4</span>);<br>l.add(<span class="hljs-number">3</span>);<br>List&lt;Integer&gt; integers = Collections.synchronizedList(l);<br></code></pre></td></tr></table></figure><p>附：List，数组怎么从大到小排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>l.add(<span class="hljs-number">1</span>);<br>l.add(<span class="hljs-number">5</span>);<br>l.add(<span class="hljs-number">2</span>);<br>l.add(<span class="hljs-number">4</span>);<br>l.add(<span class="hljs-number">3</span>);<br><br>Collections.sort(l, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Integer.compare(o2, o1);<br>  &#125;<br>&#125;);<br><br>System.out.println(l);<br><br>Integer[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<br>Arrays.sort(nums, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Integer.compare(o2, o1);<br>  &#125;<br>&#125;);<br><br>System.out.println(Arrays.toString(nums));<br></code></pre></td></tr></table></figure><p>（不是这章）</p><p>快捷键：ctrl + H （Mac也是ctrl）：查看当前类的上下继承关系</p><h4 id="P569"><a href="#P569" class="headerlink" title="P569"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=569">P569</a></h4><ul><li><p>泛型不同的引用不能相互赋值</p><ul><li>尽管编译时，<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code> 是两种类型，但是运行时只有一个ArrayList被加载到JVM中</li></ul></li><li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object</p></li><li><p>静态方法中，不能使用类的泛型（泛型是在对象创建时才确定，但静态方法在加载类之后就可能要用了）</p></li><li><p>异常类不能是泛型</p></li><li><p><strong>不能new T[]，但是可以 T[] x = (T[]) new Object[10];</strong></p></li></ul><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></h4><ul><li>一开始初始化为不可能达到的，最后返回前要判断下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">char</span>[] pp = t.toCharArray();<br>        <span class="hljs-keyword">int</span> n = ss.length;<br>        <br>        <span class="hljs-keyword">int</span>[] need = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];<br>        <span class="hljs-keyword">int</span>[] window = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];<br>        <br>        <span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : pp)&#123;<br>            <span class="hljs-keyword">if</span>(need[c]==<span class="hljs-number">0</span>)&#123;<br>                target++;<br>            &#125;<br>            need[c]++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res_len = n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> res_l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res_r = n;<br>        <br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        <span class="hljs-keyword">while</span>(r&lt;n)&#123;<br>            <span class="hljs-keyword">char</span> cur = ss[r];<br>            <span class="hljs-keyword">if</span>(need[cur]&gt;<span class="hljs-number">0</span>)&#123;<br>                window[cur]++;<br>                <span class="hljs-keyword">if</span>(window[cur]==need[cur])&#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            r++;<br>            <br>            <br>            <span class="hljs-keyword">while</span>(valid&gt;=target)&#123;<br>                <span class="hljs-keyword">if</span>(r-l&lt;res_len)&#123;<br>                    res_len = r - l;<br>                    res_l = l;<br>                    res_r = r;<br>                &#125;<br>                cur = ss[l];<br>                <span class="hljs-keyword">if</span>(need[cur]&gt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(window[cur]==need[cur])&#123;<br>                        valid--;<br>                    &#125;<br>                    window[cur]--;<br>                &#125;<br>                l++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> (res_len==n+<span class="hljs-number">1</span>)?<span class="hljs-string">&quot;&quot;</span>:s.substring(res_l, res_r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第14天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P570开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></li><li><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></li><li><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></li><li><a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></li><li><a href="https://leetcode.cn/problems/MPnaiL/">剑指 Offer II 014. 字符串中的变位词</a></li><li><a href="https://leetcode.cn/problems/VabMRr/">剑指 Offer II 015. 字符串中的所有变位词</a></li><li><a href="https://leetcode.cn/problems/wtcaE1/">剑指 Offer II 016. 不含重复字符的最长子字符串</a></li><li><a href="https://leetcode.cn/problems/M1oyTv/"> 剑指 Offer II 017. 含有所有字符的最短字符串</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《过于喧嚣的孤独》赫拉巴尔</p><p>虽然他喜欢孤身独处，但是似乎并不孤独，只是独自一人而已，独自生活在稠密的思想之中，因为看似有点儿狂妄，是无限和永恒中的狂妄分子，而无限和永恒也许就喜欢他这样的人</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第13天</title>
    <link href="/2022/07/18/2022-07-18-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC13%E5%A4%A9/"/>
    <url>/2022/07/18/2022-07-18-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC13%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第13天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P480"><a href="#P480" class="headerlink" title="P480"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=480">P480</a></h4><p>SimpleDateFormat的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<br><span class="hljs-comment">// 默认格式</span><br>  SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat();<br>  Date d = <span class="hljs-keyword">new</span> Date();<br>  String format = sdf.format(d);<br>  System.out.println(format);<br>  Date parse_d = sdf.parse(format);<br>  System.out.println(parse_d);<br><br>  <span class="hljs-comment">// 指定格式</span><br>  SimpleDateFormat sdf2 = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>  Date d2 = <span class="hljs-keyword">new</span> Date();<br>  String format2 = sdf2.format(d);<br>  System.out.println(format2);<br>  Date parse_d2 = sdf2.parse(format2);<br>  System.out.println(parse_d2);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P481"><a href="#P481" class="headerlink" title="P481"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=481">P481</a></h4><p>将指定格式转成java.sql.Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将java.util.Date 转成 java.sql.Date</span><br>Date d = <span class="hljs-keyword">new</span> Date();<br>java.sql.Date dd = <span class="hljs-keyword">new</span> java.sql.Date(d.getTime());<br></code></pre></td></tr></table></figure><h4 id="P483"><a href="#P483" class="headerlink" title="P483"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=483">P483</a></h4><p>Calendar类的使用</p><p><img src="/2022/07/18/2022-07-18-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC13%E5%A4%A9/Calendar%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="Calendar类的使用"></p><h4 id="P484"><a href="#P484" class="headerlink" title="P484"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=484">P484</a></h4><p>老时间API存在的问题：</p><p><img src="/2022/07/18/2022-07-18-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC13%E5%A4%A9/%E8%80%81%E6%97%B6%E9%97%B4API%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="老时间API存在的问题"></p><h4 id="P485"><a href="#P485" class="headerlink" title="P485"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=485">P485</a></h4><p>localDateTime类的API</p><p><img src="/2022/07/18/2022-07-18-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC13%E5%A4%A9/localDateTime%E7%B1%BB%E7%9A%84API.png" alt="localDateTime类的API"></p><h4 id="P486"><a href="#P486" class="headerlink" title="P486"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=486">P486</a></h4><p>Instant类的使用</p><p><img src="/2022/07/18/2022-07-18-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC13%E5%A4%A9/Instant%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="Instant类的使用"></p><h4 id="P488"><a href="#P488" class="headerlink" title="P488"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=488">P488</a></h4><p>Java.time.format.DateTimeFormatter类的常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br>String format1 = dateTimeFormatter.format(LocalDateTime.now());<br>System.out.println(format1);<br>TemporalAccessor parse1 = dateTimeFormatter.parse(format1);<br>System.out.println(parse1);<br></code></pre></td></tr></table></figure><p>不同时间类的转换</p><p><img src="/2022/07/18/2022-07-18-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC13%E5%A4%A9/%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="不同时间类的转换"></p><h4 id="P492"><a href="#P492" class="headerlink" title="P492"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=492">P492</a></h4><p>抛出的异常如果是运行时异常，可以不做处理</p><p><strong>注意</strong></p><p>如果是double类型比较大小，最好用Double.compare()，自己比较很容易2.2 - 2.1 = 0.1，但是因为返回int类型，就变成0，即相等了</p><blockquote><p>还是用if else 安全</p></blockquote><h4 id="P493"><a href="#P493" class="headerlink" title="P493"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=493">P493</a></h4><p>两种比较器：</p><ul><li>自然排序compareTo()：用于类的内部，是接口comparable的抽象方法</li><li>自定义类排序Comparator：用于外部，一次性构造使用</li></ul><h4 id="P494"><a href="#P494" class="headerlink" title="P494"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=494">P494</a></h4><p>BigInteger，BigDecimal两种函数</p><h4 id="P495"><a href="#P495" class="headerlink" title="P495"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=495">P495</a></h4><p>JDK8之前和JDK8的时间类的对应关系：</p><ul><li>java.util.Date，java.sql.Date   ===》 java.time.instant</li><li>Java.text.SimpleDateFormat   ===》 java.time.format.DateTimeFormat</li><li>java.util.Calendar  ====》 java.time.LocalDateTime/LocalDate/LocalTime</li></ul><h4 id="P499"><a href="#P499" class="headerlink" title="P499"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=499">P499</a></h4><p>自定义枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shasha.s20220718;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ShaLuwei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-07-18 13:52</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_Enum</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Season spring = Season.SPRING;<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Season</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String des;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Season SPRING = <span class="hljs-keyword">new</span> Season(<span class="hljs-string">&quot;春&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Season SUMMER = <span class="hljs-keyword">new</span> Season(<span class="hljs-string">&quot;夏&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Season AUTUMN = <span class="hljs-keyword">new</span> Season(<span class="hljs-string">&quot;秋&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Season WINTER = <span class="hljs-keyword">new</span> Season(<span class="hljs-string">&quot;冬&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Season</span><span class="hljs-params">(String name, String des)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.des = des;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, des=&#x27;&quot;</span> + des + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P500"><a href="#P500" class="headerlink" title="P500"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=500">P500</a></h4><p>enum定义枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Season1</span></span>&#123;<br><br>    SPRING(<span class="hljs-string">&quot;春&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>),<br>    SUMMER(<span class="hljs-string">&quot;夏&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>),<br>    AUTUMN(<span class="hljs-string">&quot;秋&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>),<br>    WINTER(<span class="hljs-string">&quot;冬&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String des;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Season1</span><span class="hljs-params">(String name, String des)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.des = des;<br>    &#125;<br><br>  <span class="hljs-comment">// 不重写的话，打印的是常量名</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, des=&#x27;&quot;</span> + des + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：Seanson1的父类是 java.lang.Enum，不是Object</strong></p><h4 id="P501"><a href="#P501" class="headerlink" title="P501"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=501">P501</a></h4><p>enum定义</p><p>Enum类的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Season1[] values = Season1.values();<br><span class="hljs-keyword">for</span> (Season1 value : values) &#123;<br>  System.out.println(value);<br>&#125;<br><br>Season1 winnter = Season1.valueOf(<span class="hljs-string">&quot;WINTER&quot;</span>);<br>System.out.println(winnter);<br><br>System.out.println(Season1.WINTER.toString());<br></code></pre></td></tr></table></figure><h4 id="P502"><a href="#P502" class="headerlink" title="P502"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=502">P502</a></h4><p>如果枚举类还实现了别的接口，可以给枚举类的每个类型都重写相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Test_sha</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Season1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Test_sha</span> </span>&#123;<br><br>    SPRING(<span class="hljs-string">&quot;春&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;11.....11&quot;</span>);<br>        &#125;<br>    &#125;,<br>    SUMMER(<span class="hljs-string">&quot;夏&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;22.....22&quot;</span>);<br>        &#125;<br>    &#125;,<br>    AUTUMN(<span class="hljs-string">&quot;秋&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;44.....33&quot;</span>);<br>        &#125;<br>    &#125;,<br>    WINTER(<span class="hljs-string">&quot;冬&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;44.....44&quot;</span>);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String des;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Season1</span><span class="hljs-params">(String name, String des)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.des = des;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, des=&#x27;&quot;</span> + des + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P503"><a href="#P503" class="headerlink" title="P503"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=503">P503</a></h4><p>枚举类如果用在switch里，不需要加类名前缀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Season1 s1 = Season1.AUTUMN;<br><br><span class="hljs-keyword">switch</span> (s1)&#123;<br>  <span class="hljs-keyword">case</span> AUTUMN:<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> SPRING:<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> WINTER:<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> SUMMER:<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>附：</p><p>返回枚举类的序号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Season1 s1 = Season1.AUTUMN;<br>System.out.println(s1.ordinal()); <span class="hljs-comment">// 2，因为从0开始</span><br></code></pre></td></tr></table></figure><h4 id="P506"><a href="#P506" class="headerlink" title="P506"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=506">P506</a></h4><p>注解的3种用途：</p><ul><li>文档相关</li><li>编译时进行格式检查（JDK内置3个基本注解）<ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul></li><li>跟踪代码依赖性，实现替代配置文件功能</li></ul><h4 id="P507"><a href="#P507" class="headerlink" title="P507"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=507">P507</a></h4><p>自定义注解:</p><ul><li>注解声明为 @interface</li><li>内部定义成员，通常使用value表示</li><li>可以指定成员的默认值，使用default定义（没有默认值的话，调用的时候就要强行指定值了）</li><li>如果自定义注解没有成员，表明是一个标识作用</li></ul><h4 id="P508"><a href="#P508" class="headerlink" title="P508"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=508">P508</a></h4><p>元注解：对现有的注解进行解释说明的注解</p><ul><li>Retention：指定修饰的annotation 的生命周期：RetentionPolicy.SOURCE，CLASS(默认)，RUNTIME<ul><li>只有RUNTIME修饰的注解，才能通过反射获取</li></ul></li><li>Target：指定该注解能修饰哪些程序元素</li><li>Documented：该注解被javadoc解析时，会被保留</li><li>Inherited：注解会有继承性，即子类即使不声明注解，也有父类的注解</li></ul><h4 id="P510"><a href="#P510" class="headerlink" title="P510"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=510">P510</a></h4><p>JDK8的注解新特性：</p><ul><li><p>可重复注解</p><ul><li><p>两种实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_annotation</span> </span>&#123;<br>    <span class="hljs-comment">// 可重复注解写法二</span><br>    <span class="hljs-meta">@MyAnnotation(&quot;123&quot;)</span><br>    <span class="hljs-meta">@MyAnnotation(&quot;456&quot;)</span><br>    <span class="hljs-comment">// 可重复注解写法一</span><br><span class="hljs-comment">//    @MyAnnotations(&#123;@MyAnnotation(&quot;123&quot;), @MyAnnotation(&quot;456&quot;)&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Repeatable(MyAnnotations.class)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;hello&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotations &#123;<br>    MyAnnotation[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：MyAnnotation 和 MyAnnotations 的元注解要一样，例如Retention，Inherited，Target</strong></p></li></ul></li><li><p>类型注解</p><ul><li><p>ElementType.TYPE_PARAMETER：写在类型声明的变量语句中，如泛型声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic_sha</span>&lt;@<span class="hljs-title">MyAnnotation</span>(&quot;789&quot;) <span class="hljs-title">T</span>&gt;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> @<span class="hljs-title">MyAnnotation</span><span class="hljs-params">(<span class="hljs-string">&quot;321&quot;</span>)</span> RuntimeException</span>&#123;<br>        ArrayList&lt;<span class="hljs-meta">@MyAnnotation(&quot;654&quot;)</span> String&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> nums = (<span class="hljs-meta">@MyAnnotation(&quot;987&quot;)</span> <span class="hljs-keyword">int</span>) <span class="hljs-number">313L</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>ElementType.TYPE_USE：写在使用类型的任何语句中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic_sha</span>&lt;@<span class="hljs-title">MyAnnotation</span>(&quot;789&quot;) <span class="hljs-title">T</span>&gt;</span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> @<span class="hljs-title">MyAnnotation</span><span class="hljs-params">(<span class="hljs-string">&quot;321&quot;</span>)</span> RuntimeException</span>&#123;<br>        ArrayList&lt;<span class="hljs-meta">@MyAnnotation(&quot;654&quot;)</span> String&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> nums = (<span class="hljs-meta">@MyAnnotation(&quot;987&quot;)</span> <span class="hljs-keyword">int</span>) <span class="hljs-number">313L</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="P515"><a href="#P515" class="headerlink" title="P515"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=515">P515</a></h4><p>Collections 中的常用方法：</p><ul><li>add()：</li><li>addAll(Collection T)：</li><li>clear()：</li></ul><p>（不是这章）：</p><p>快捷键：ctrl + N，generate各种方法啥的</p><h4 id="P521"><a href="#P521" class="headerlink" title="P521"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=521">P521</a></h4><p>Collection 中的常用方法：</p><ul><li><p>retainAll(Collection T)：求交集，并保留在原Collection中</p></li><li><p>equals(Object o)：两个集合是否相等，如果两个都是有序集合，那么顺序也要一致</p><ul><li><strong>注意，如果是自定义类，那么用的时候一定要重写equals()方法</strong></li></ul></li><li><p>toArray()：集合变成数组</p><ul><li><p>数组变集合：List<String> res = Arrays.asList(new String[]{“AA”,”BB”});</String></p><ul><li><p>一个细节，Arrays.asList()里面的参数是Object对象，因此非包装类，用的时候不要大括号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-keyword">int</span>[]&gt; ints = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;);<br>System.out.println(ints.size()); <span class="hljs-comment">// 1</span><br>List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>System.out.println(integers.size()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>iterator()：返回一个迭代器</p></li></ul><h4 id="P526"><a href="#P526" class="headerlink" title="P526"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=526">P526</a></h4><p>iterator接口的几个方法：</p><ul><li>next()</li><li>hasNext()</li><li>remove()：一定要先next()，再调用，并且只能调用一次，不能连续调用</li></ul><h4 id="P527"><a href="#P527" class="headerlink" title="P527"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=527">P527</a></h4><p>增强for，本质上还是调用iterator</p><ul><li>注意，增强for里面改值，不会改到原来的值，因为倪神先给一个局部变量赋值再操作，改的是局部变量，而非原来的</li></ul><h4 id="P528"><a href="#P528" class="headerlink" title="P528"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=528">P528</a></h4><p>ArrayList，LinkedList，Vector的异同：</p><ul><li>相同<ul><li>都实现了List接口，存储有序，可重复数据，动态存储</li></ul></li><li>不同：<ul><li>线程是否安全<ul><li>Vector 是线程安全，效率不高</li><li>ArrayList不安全，效率高</li><li>LinkedList</li></ul></li><li>出现先后<ul><li>Vector 古老，jdk1.0出现</li><li>ArrayList，LinkedList jdk1.2出现（List接口也才1.2出现）</li></ul></li><li>底层结构<ul><li>Vector：底层是Object[]数组</li><li>ArrayList：底层是Object[]数组</li><li>LinkedList：底层是双向链表，适合多次插入删除</li></ul></li></ul></li></ul><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></h4><ul><li><p>左右边界，相等的时候也要左移右移</p></li><li><p>左边界的额外条件是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 左边界额外考虑的事情</span><br><span class="hljs-keyword">if</span>(left&gt;=nums.length || nums[left]!=target)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-comment">// 右边界额外考虑的事情</span><br><span class="hljs-keyword">if</span>(right&lt;<span class="hljs-number">0</span> || nums[right]!=target)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid = -<span class="hljs-number">1</span>;<br>            <br>        <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>            mid = l + (r-l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(l&gt;r)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> l1 = l;<br>        <span class="hljs-keyword">int</span> r1 = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid1 = -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(l1&lt;=r1)&#123;<br>            mid1 = l1 + (r1-l1)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid1]&lt;target)&#123;<br>                l1 = mid1 + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r1 = mid1 - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">int</span> l2 = mid1 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> r2 = r;<br>        <span class="hljs-keyword">int</span> mid2 = -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(l2&lt;=r2)&#123;<br>            mid2 = l2 + (r2-l2)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid2]&gt;target)&#123;<br>                r2 = mid2 - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l2 = mid2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l1, r2&#125;;<br>        <br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第13天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P529开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></li><li><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>周国平</p><p>不是因为思考，所以痛苦，而是因为痛苦，所以思考。生性敏感而认真的人，总是在思考那些人生大问题，他不是刻意要想，实在是身不由己，且欲罢不能</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第12天</title>
    <link href="/2022/07/17/2022-07-17-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC12%E5%A4%A9/"/>
    <url>/2022/07/17/2022-07-17-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC12%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第12天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P433"><a href="#P433" class="headerlink" title="P433"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=433">P433</a></h4><p>解决同步线程安全问题：</p><ul><li>同步代码块：<ul><li>指的是操作共享数据的代码块</li><li>同步监视器，又称为锁，任何一个对象都可以充当锁，多个线程共用一把锁（最方便的对象是this 和 类.class）</li></ul></li><li>同步方法：<ul><li>如果方法都是操作共享数据，直接在方法前面加上synchronized</li><li>仍涉及同步监视器，只是未显式声明<ul><li>非静态方法的同步监视器：this</li><li>静态方法的同步监视器：当前类本身</li></ul></li></ul></li></ul><p><strong>注意：类.class也是个对象，例如：Class clazz = Dog.class;</strong></p><h4 id="P437"><a href="#P437" class="headerlink" title="P437"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=437">P437</a></h4><p>快捷键：ctrl + alt + t，讲一段代码用xxx结构包裹</p><p>懒汉式单例模式的线程安全问题解决：</p><ul><li><p>方法一：方法加synchronized（本身就是static，所以锁唯一），或者整个内部代码加synchronized，效率较差</p></li><li><p>方法二：双重校验锁，效率稍微高点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(bank==<span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">synchronized</span>(Bank.class)&#123;<br>      <span class="hljs-keyword">if</span>(bank==<span class="hljs-keyword">null</span>)&#123;<br>        bank = <span class="hljs-keyword">new</span> Bank();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bank;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="P438"><a href="#P438" class="headerlink" title="P438"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=438">P438</a></h4><p>避免死锁的方法：</p><ul><li>专门的算法，原则</li><li>尽量减少同步资源的定义</li><li>尽量避免嵌套同步</li></ul><h4 id="P439"><a href="#P439" class="headerlink" title="P439"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=439">P439</a></h4><p>快捷键：ctrl+p，显式该方法有几种重载的参数列表</p><p>ReentranLock 的参数fair，如果为true，代表先进先出，绝对公平，默认为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tickets = <span class="hljs-number">100</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tickets&gt;<span class="hljs-number">0</span>)&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖了第 &quot;</span> + tickets + <span class="hljs-string">&quot; 张票&quot;</span>);<br>                    tickets--;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Synchronized 和 lock 的异同：</p><ul><li>相同：<ul><li>都可以解决线程安全问题</li></ul></li><li>不同：<ul><li>synchronized执行完同步代码块后，自动释放同步监视器</li><li>lock 手动启动同步（lock.lock()），手动结束同步（lock.unlock()）</li></ul></li></ul><h4 id="P441"><a href="#P441" class="headerlink" title="P441"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=441">P441</a></h4><p>线程通信的方法：</p><ul><li>wait()</li><li>notify()</li><li>notifyAll()</li></ul><p>wait() 和 sleep() 的区别：虽然都是进入阻塞状态，但是：</p><ul><li>wait() 会释放锁的所有权，并进入阻塞</li><li>Sleep() 不会释放锁，只能睡醒之后，依然有锁，执行完同步代码块，才释放</li></ul><p><strong>注意</strong></p><ul><li>notify()唤醒优先级最高的线程</li><li>wait()，notify()，notifyAll() 必须在synchronized内，lock另算</li><li>wait()，notify()，notifyAll() 的调用者，必须是synchronized的同步监视器/锁，不然会报错 IllegalMonitorStateException异常</li></ul><h4 id="P442"><a href="#P442" class="headerlink" title="P442"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=442">P442</a></h4><p>sleep() 和 wait() 的异同：</p><ul><li>相同点：都可以使当前线程进入阻塞状态</li><li>不同点：<ul><li>声明的位置不同，sleep() 在 Thread 类中， wait() 在 Object 类中</li><li>调用的要求不同， sleep() 没啥限制， wait() 要在synchronized中（同步代码块和同步方法）</li><li>是否释放同步监视器不同， sleep() 不释放，wait() 会释放锁</li></ul></li></ul><h4 id="P443"><a href="#P443" class="headerlink" title="P443"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=443">P443</a></h4><p>生产者消费者问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shasha.s20220717;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产者 - 消费者问题</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ShaLuwei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-07-17 12:29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_producer_customer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Clerk c  = <span class="hljs-keyword">new</span> Clerk();<br>        Producer p1 = <span class="hljs-keyword">new</span> Producer(c);<br>        Customer c1 = <span class="hljs-keyword">new</span> Customer(c);<br><br>        Thread pp1 = <span class="hljs-keyword">new</span> Thread(p1);<br>        Thread cc1 = <span class="hljs-keyword">new</span> Thread(c1);<br><br>        pp1.start();<br>        cc1.start();<br><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clerk</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(count&lt;<span class="hljs-number">20</span>)&#123;<br>            count++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在生产第 &quot;</span> + count + <span class="hljs-string">&quot;个产品&quot;</span>);<br>            notify();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在消费第 &quot;</span> + count + <span class="hljs-string">&quot;个产品&quot;</span>);<br>            count--;<br>            notify();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    Clerk c;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(Clerk c)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.c = c;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            c.produce();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    Clerk c;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(Clerk c)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.c = c;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            c.consume();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="P444"><a href="#P444" class="headerlink" title="P444"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=444">P444</a></h4><p>（不在这一集，反正是今天的某集，突然想到了）</p><p>如果是匿名类的子类重写，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread()&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.run();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果是里面的参数要接口实现，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p> 不大一样，记得区分</p></blockquote><p>Callable方法比Runnable方法更强大：</p><ul><li>有返回值</li><li>可以抛出异常，被外面捕获，得到异常信息</li><li>支持泛型</li></ul><p>Callable用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shasha.s20220717;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * callable 方法调用线程</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ShaLuwei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-07-17 13:57</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_callable_thread</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        MyCallable m = <span class="hljs-keyword">new</span> MyCallable();<br><br>        FutureTask f = <span class="hljs-keyword">new</span> FutureTask(m);<br><br>        Thread t = <span class="hljs-keyword">new</span> Thread(f);<br><br>        t.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Object o = f.get();<br>            System.out.println(o);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            sum += i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关于Future接口</p><p><img src="/2022/07/17/2022-07-17-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC12%E5%A4%A9/Future%E6%8E%A5%E5%8F%A3.png" alt="Future接口"></p><h4 id="P445"><a href="#P445" class="headerlink" title="P445"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=445">P445</a></h4><p>线程池的好处：</p><ul><li>减小响应时间</li><li>减小资源消耗</li><li>便于线程管理</li></ul><h4 id="P446"><a href="#P446" class="headerlink" title="P446"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=446">P446</a></h4><p>线程池的创建方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shasha.s20220717;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池创建多线程的例子</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ShaLuwei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-07-17 14:19</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_executors_thread</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        System.out.println(service.getClass());<br><br>        <span class="hljs-comment">// 接口本身没有各种属性，是接口实现的类的对象才有，所以要强转一下</span><br>        ThreadPoolExecutor t = (ThreadPoolExecutor) service;<br>        t.setCorePoolSize(<span class="hljs-number">4</span>);<br>        t.setKeepAliveTime(<span class="hljs-number">123</span>, TimeUnit.DAYS);<br><br>        <span class="hljs-comment">// Runnable 的调用方法</span><br>        service.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                    System.out.println(i);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// Callable 的调用方法</span><br><span class="hljs-comment">//        service.submit(new Callable() &#123;</span><br><span class="hljs-comment">//            @Override</span><br><span class="hljs-comment">//            public Object call() throws Exception &#123;</span><br><span class="hljs-comment">//                for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="hljs-comment">//                    System.out.println(i);</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                return null;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;);</span><br><br>        service.shutdown();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>（不是这一集的）</p><p>快捷键：Ctrl + alt + l ：格式化</p><p>快捷键：ctrl + alt + 左/右 : 前往上一次或者下一次查看的文件指针位置</p><p>快捷键：ctrl + alt + v：补完返回值类型</p><h4 id="P452"><a href="#P452" class="headerlink" title="P452"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=452">P452</a></h4><p>String 不管是：</p><ul><li>重新赋值</li><li>连接新字符串</li><li>replace换字母</li></ul><p>都会变成常量池中心的字符串，即地址改变了，反映了<strong>String内部存储的char[] 是final类型，即地址不可变</strong></p><h4 id="P453"><a href="#P453" class="headerlink" title="P453"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=453">P453</a></h4><p>String a = new String(“abc”); 创建了两个对象，一个在堆中，一个在方法区常量池</p><h4 id="P454"><a href="#P454" class="headerlink" title="P454"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=454">P454</a></h4><p>String常量（<strong>字面量 + final修饰的变量</strong>）与常量的拼接，结果依然在常量池中（常量池中相同值的String只有一份）</p><p>只要有变量参与，就等于是在堆中new了一个新的变量</p><p>如果拼接的结果用intern() 返回，那么返回的是常量池中的结果</p><h4 id="P455"><a href="#P455" class="headerlink" title="P455"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=455">P455</a></h4><p>一个易错题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  String a = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>    method(a);<br>  System.out.println(a); <span class="hljs-comment">// 结果是”abc“,因为a一直指向内存中的一块区域，b一开始初始为指向同一个地方，但method()仅让b指向另一个地方，其他没变</span><br>&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(String b)</span></span>&#123;<br>    b = <span class="hljs-string">&quot;123&quot;</span>;<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P456"><a href="#P456" class="headerlink" title="P456"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=456">P456</a></h4><p>字符串常量池的版本更迭：</p><ul><li>1.6及之前：字符串常量池在方法区（永久代）</li><li>1.7：在堆中</li><li>1.8：在方法区（元空间）</li></ul><h4 id="P457"><a href="#P457" class="headerlink" title="P457"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=457">P457</a></h4><p>因为String的不可变性，所有String的方法，原字符串都没有变化，而是返回新的字符串</p><p>String常用方法：</p><ul><li>String toLowerCase()：</li><li>String toUpperCase()：</li><li>String trim()：</li><li>String equalsIgnoreCase(String s)：</li><li>int compareTo(String s)：</li></ul><h4 id="P458"><a href="#P458" class="headerlink" title="P458"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=458">P458</a></h4><p>String的常用方法：</p><ul><li>boolean endsWith(String suffix)：以xxx为后缀</li><li>boolean startsWith(String preffix)：以xxx为前缀</li><li>boolean startsWith(String preffix, int toffset)：从第xx个位置开始，以xxx为前缀</li><li>boolean contains(CharSequence s)：是否包含xxx，这里可以用String（因为是CharSequence接口的实现类）</li><li>int indexOf(String str)：str 第一次出现的下标位置</li><li>int indexOf(String str, int fromIndex)：str 从fromIndex开始，第一次出现的下标位置</li><li>int lastIndexOf(String str)：str 第一次出现的下标位置</li><li>int lastindexOf(String str, int fromIndex)：str 从fromIndex开始 <strong>往左找</strong> ，第一次出现的下标位置</li></ul><h4 id="P459"><a href="#P459" class="headerlink" title="P459"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=459">P459</a></h4><p>String的常用方法：</p><ul><li>String replace(char old, char new)：所有的old字符换成new字符</li><li>String replace(CharSequence old, CharSequence new)：所有的old字符串换成new字符串</li><li>String replaceAll(String regex, String replacement)：所有满足正则表达式的都换成xxxx</li><li>String replaceFirst(String regex, String replacement)：第一个满足正则表达式的换成xxxx</li><li>boolean matches(String regex)：字符串是否满足正则表达式</li><li>String[] split(String regex, int limit)：最多不超过limit个，把最后剩下的都并到最后一个里</li></ul><h4 id="P461"><a href="#P461" class="headerlink" title="P461"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=461">P461</a></h4><p>String 和 char[] 相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">char</span>[] c1 = s1.toCharArray();<br>String s2 = <span class="hljs-keyword">new</span> String(c1);<br></code></pre></td></tr></table></figure><h4 id="P462"><a href="#P462" class="headerlink" title="P462"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=462">P462</a></h4><p>String 和 byte[] 相互转换（编解码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">byte</span>[] b1 = s.getBytes(); <span class="hljs-comment">// 默认的字符集，看编译器</span><br><span class="hljs-keyword">byte</span>[] b2 = s.getBytes(”gbk“); <span class="hljs-comment">// gbk，一个汉字2bytes</span><br>String s1 = <span class="hljs-keyword">new</span> String(b1);<br>String s2 = <span class="hljs-keyword">new</span> String(b1, <span class="hljs-string">&quot;gbk&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="P465"><a href="#P465" class="headerlink" title="P465"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=465">P465</a></h4><p>String，StringBuffer，StringBuilder的异同：</p><p>相同：底层都是char[] 数组</p><p>不同：</p><ul><li>可变/不可变<ul><li>String 不可变</li><li>StringBuffer，StringBuilder 可变</li></ul></li><li>线程安全<ul><li>StringBuffer 线程安全</li><li>StringBuilder 线程不安全</li></ul></li></ul><h4 id="P466"><a href="#P466" class="headerlink" title="P466"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=466">P466</a></h4><p>StringBuffer的一些底层源码细节：</p><ul><li>扩容：一般变为原来的 2*n + 2，除非有其他例外（扩容后还不够就直接赋值你要求的值，或者扩容后超界变为负数）<ul><li>建议构造StringBuffer的时候，直接指定长度，因为扩容很耗时</li></ul></li></ul><h4 id="P467"><a href="#P467" class="headerlink" title="P467"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=467">P467</a></h4><p>StringBuffer的常用函数：</p><p><img src="/2022/07/17/2022-07-17-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC12%E5%A4%A9/StringBuffer%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0.png" alt="StringBuffer常用函数"></p><p><strong>注意，只有substring是有返回值的，更准确地说是返回不可变对象，其他都是返回自身，因此自身地址一样不如不返回</strong></p><h4 id="P470"><a href="#P470" class="headerlink" title="P470"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=470">P470</a></h4><p>几个时间类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> l = System.currentTimeMillis();<br>System.out.println(l);<br><br>Date d1 = <span class="hljs-keyword">new</span> Date();<br>System.out.println(d1.toString());<br>System.out.println(d1.getTime());<br><br>Date d2 = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">132213131L</span>);<br>System.out.println(d1.toString());<br><br>java.sql.Date d3 = <span class="hljs-keyword">new</span> java.sql.Date(d1.getTime());<br>System.out.println(d3.toString());<br></code></pre></td></tr></table></figure><h4 id="P478"><a href="#P478" class="headerlink" title="P478"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=478">P478</a></h4><p>两个字符串判断最大相同子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">maxSameSubstring</span><span class="hljs-params">(String a, String b)</span></span>&#123;<br>  String max = (a.length()&gt;b.length())?a:b;<br>  String min = (a.length()&lt;b.length())?a:b;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;min.length(); i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, y=min.length()-i; y&lt;=min.length(); x++, y++)&#123;<br>      <span class="hljs-keyword">if</span>(max.contains(min.substring(x, y)))&#123;<br>        <span class="hljs-keyword">return</span> min.substring(x, y);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P480"><a href="#P480" class="headerlink" title="P480"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=480">P480</a></h4><p>StringBuilder / StringBuffer 的一些细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String str = <span class="hljs-keyword">null</span>;<br>    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>    sb.append(str); <span class="hljs-comment">// 有单独判断处理null的语句</span><br><br>    System.out.println(sb.length()); <span class="hljs-comment">// 4</span><br><br>    System.out.println(sb); <span class="hljs-comment">// &quot;null&quot;</span><br><br>    StringBuffer sb1 = <span class="hljs-keyword">new</span> StringBuffer(str); <span class="hljs-comment">// NullPointerException，因为有一行涉及到 str.length()</span><br><br>    System.out.println(sb1);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></h4><p>版本一：全程String，速度较慢</p><ul><li>maxPalin函数最后，并非返回”“，而是同样返回s.substring(i+1, j)，这个会自动帮你处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        String res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s.length(); i++)&#123;<br>            String res1 = maxPalin(s, i, i);<br>            String res2 = maxPalin(s, i, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(res1.length()&gt;res.length())&#123;<br>                res = res1;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res2.length()&gt;res.length())&#123;<br>                res = res2;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">maxPalin</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = x;<br>        <span class="hljs-keyword">int</span> j = y;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;s.length())&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)!=s.charAt(j))&#123;<br>                <span class="hljs-keyword">return</span> s.substring(i+<span class="hljs-number">1</span>, j);<br>            &#125;<br>            i--;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(i+<span class="hljs-number">1</span>, j);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>版本二：char[] + int[]返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">int</span> max_l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max_r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;ss.length; i++)&#123;<br>            <span class="hljs-keyword">int</span>[] res1 = maxPalin(ss, i, i);<br>            <span class="hljs-keyword">int</span>[] res2 = maxPalin(ss, i, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(res1[<span class="hljs-number">2</span>]&gt;max)&#123;<br>                max = res1[<span class="hljs-number">2</span>];<br>                max_l = res1[<span class="hljs-number">0</span>];<br>                max_r = res1[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res2[<span class="hljs-number">2</span>]&gt;max)&#123;<br>                max = res2[<span class="hljs-number">2</span>];<br>                max_l = res2[<span class="hljs-number">0</span>];<br>                max_r = res2[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(max_l, max_r);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxPalin(<span class="hljs-keyword">char</span>[] ss, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)&#123;<br>        <span class="hljs-keyword">int</span> i = x;<br>        <span class="hljs-keyword">int</span> j = y;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;ss.length)&#123;<br>            <span class="hljs-keyword">if</span>(ss[i]!=ss[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i+<span class="hljs-number">1</span>, j, j-i-<span class="hljs-number">1</span>&#125;;<br>            &#125;<br>            i--;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i+<span class="hljs-number">1</span>, j, j-i-<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第12天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P478开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></li><li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></li><li><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></li><li><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></li><li><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></li><li><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></li><li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></li><li><a href="https://leetcode.cn/problems/kLl5u1/">剑指 Offer II 006. 排序数组中两个数字之和</a></li></ul><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《陆犯焉识》</p><p>她表面的嘻嘻哈哈，大大咧咧恰是因为自己的心太软，心太软的人快乐是不容易的，别人伤害她或者她伤害别人都让她在心里病一场</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第11天</title>
    <link href="/2022/07/16/2022-07-16-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC11%E5%A4%A9/"/>
    <url>/2022/07/16/2022-07-16-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC11%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第11天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P417"><a href="#P417" class="headerlink" title="P417"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=417">P417</a></h4><p>多线程的优点：（即使单核CPU多线程更慢，也要多线程）</p><ul><li>提高用户体验（如果只能执行一个，用户只能呆等）</li><li>多核CPU，多线程会让CPU利用率更高，不会有CPU空闲</li><li>代码结构会更清晰</li></ul><p>多线程的应用场景：</p><ul><li>同时执行多个任务</li><li>任务需要等待时（用户输入，文件读写，网络，搜索）</li><li>需要一些后台运行的程序（gc回收）</li></ul><h4 id="P419"><a href="#P419" class="headerlink" title="P419"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=419">P419</a></h4><p>Thread 的 start() 方法有两个作用：</p><ul><li><p>启动当前线程</p></li><li><p>调用 run() 方法</p><ul><li>如果只调用run() 方法，那么还是只有主线程执行而已</li></ul></li><li><p>一个线程对象被start以后，内部threadStatus 值会非0，进而抛出异常</p></li><li><p>匿名子类的简单写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  <span class="hljs-keyword">new</span> Thread()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//........</span><br>    &#125;<br>  &#125;.start();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="P421"><a href="#P421" class="headerlink" title="P421"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=421">P421</a></h4><p>Thread 的 方法：</p><ul><li>yield()：释放CPU的执行权（但下一次还是有可能又被分配到执行权），注意，如果涉及到同步的锁，这里并没有释放锁</li><li>join()：线程a中调用线程b的join()，a进入阻塞状态，直到b的run()执行结束，a结束阻塞状态，才能等待CPU分配资源</li><li>Stop()：强制结束线程（<strong>已过时</strong>）</li><li>Sleep()：（静态方法）阻塞一段时间，结束后才能等待CPU分配资源</li><li>isAlive()：是否存活</li></ul><h4 id="P422"><a href="#P422" class="headerlink" title="P422"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=422">P422</a></h4><p>Thread设置了优先级只是概率，实测很有可能还是反的</p><h4 id="P424"><a href="#P424" class="headerlink" title="P424"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=424">P424</a></h4><p>第二种创建多线程方式:</p><ul><li>创建Runnable接口的自定义类</li><li>创建自定义类的对象，传入Thread构造器中</li><li>Thread构造出的对象，照样 start() 一下即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;666&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_multi_thread</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 方式一：</span><br>        MyThread t11 = <span class="hljs-keyword">new</span> MyThread();<br>        t11.start();<br>      MyThread t12 = <span class="hljs-keyword">new</span> MyThread();<br>        t12.start();<br><br>        <span class="hljs-comment">// 方式二：</span><br>        MyRunnable r = <span class="hljs-keyword">new</span> MyRunnable();<br>        Thread t21 = <span class="hljs-keyword">new</span> Thread(r);<br>        t21.start();<br>      Thread t22 = <span class="hljs-keyword">new</span> Thread(r);<br>        t22.start();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：Runnbale接口的对象可以反复使用</p><h4 id="P426"><a href="#P426" class="headerlink" title="P426"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=426">P426</a></h4><p>两种多线程方式的区别：</p><ul><li>不同点：优先选择第二种<ul><li>第一种有单继承的局限性（如果你本身就是一个子类，那么久无法再继承Thread）</li><li>第二种天然实现多个线程共享数据，不需要额外加static</li></ul></li><li>相同点 / 联系<ul><li>都实现了 Runnable 接口，Thread 本身就实现了 Runnable 接口</li><li>都重写了Runnable接口中的 run()方法，将核心逻辑写入其中</li></ul></li></ul><h4 id="P429"><a href="#P429" class="headerlink" title="P429"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=429">P429</a></h4><p>Java线程分两种：</p><ul><li>用户线程：用户线程一旦死亡，守护线程也立即死亡</li><li>守护线程：可以在 start() 方法前调用 thread.setDaemon(true) 把用户线程编程守护线程<ul><li>举例：垃圾回收</li></ul></li></ul><p><img src="/2022/07/16/2022-07-16-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC11%E5%A4%A9/%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB.png" alt="线程分类"></p><h4 id="P430"><a href="#P430" class="headerlink" title="P430"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=430">P430</a></h4><p>线程的不同状态：</p><ul><li>新建：new了对象以后的状态</li><li>就绪：start() 以后，获得时间片之前</li><li>运行：获得时间片之后，进入run()函数</li><li>阻塞：被人为挂起或执行输入输出，让出CPU（区别于没被动分配到时间片的“就绪”状态，这个是人为挂起，比如使用join() 方法）</li><li>死亡：完成全部任务，或被提前终止，或发生异常</li></ul><p>线程的生命周期</p><p><img src="/2022/07/16/2022-07-16-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC11%E5%A4%A9/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程生命周期"></p><h4 id="P432"><a href="#P432" class="headerlink" title="P432"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=432">P432</a></h4><p>线程安全问题：例如卖车票的重票错票问题（可以通过加sleep来提高线程插队的概率，进而提高重票错票的概率）</p><ul><li>原因：某个线程操作共享数据到一半，另一个线程进来了，操作了共享数据</li><li>解决方法：线程a操作共享数据的时候，禁止别的线程操作，即使a阻塞了，也得等着</li></ul><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></h4><ul><li>并不是下一个节点是null才换链表，而是本身等于null，不然会一直死循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        ListNode l1 = headA;<br>        ListNode l2 = headB;<br>        <span class="hljs-keyword">while</span>(l1!=l2)&#123;<br>            <span class="hljs-keyword">if</span>(l1==<span class="hljs-keyword">null</span>)&#123;<br>                l1 = headB;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2==<span class="hljs-keyword">null</span>)&#123;<br>                l2 = headA;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a></h4><ul><li>PriorityQueue的定义，new后面的也要加 <code>&lt;&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        ListNode dum = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br><br>        PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(o1.val, o2.val);<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span>(ListNode tmp : lists)&#123;<br>            <span class="hljs-keyword">if</span>(tmp!=<span class="hljs-keyword">null</span>)&#123;<br>                pq.add(tmp);<br>            &#125;<br>        &#125;<br><br>        ListNode cur = dum;<br><br>        <span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>            ListNode tmp = pq.poll();<br>            cur.next = tmp;<br>            <span class="hljs-keyword">if</span>(tmp.next!=<span class="hljs-keyword">null</span>)&#123;<br>                pq.add(tmp.next);<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dum.next;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a><a href="https://leetcode.com/problems/partition-list/">86. Partition List</a></h4><p>前面都没啥问题，最后别忘了big.next要置为null，不然成环了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        ListNode dum1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode dum2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br><br>        ListNode small = dum1;<br>        ListNode big = dum2;<br><br>        ListNode cur = head;<br><br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cur.val&lt;x)&#123;<br>                small.next = cur;<br>                small = small.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                big.next = cur;<br>                big = big.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br><br>        big.next = <span class="hljs-keyword">null</span>;<br><br>        small.next = dum2.next;<br><br>        <span class="hljs-keyword">return</span> dum1.next;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第11天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P432开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></li><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></li><li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></li><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></li><li><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></li><li><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></li><li><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></li><li><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></li><li><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></li><li><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></li><li><a href="https://leetcode.cn/problems/SLwz0R/">剑指 Offer II 021. 删除链表的倒数第 n 个结点</a></li><li><a href="https://leetcode.cn/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点</a></li><li><a href="https://leetcode.cn/problems/3u1WK4/">剑指 Offer II 023. 两个链表的第一个重合节点</a></li><li><a href="https://leetcode.cn/problems/vvXgSW/">剑指 Offer II 078. 合并排序链表</a></li></ul><p>感觉今天也没怎么浪，但却看得很少，可能确实越往后面我越不熟悉，速度明显放缓了，经常重放或者慢速，坚持住，然后每天多花点时间</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《偷书贼》 </p><p>一个非常珍视的故事，就会用漫不经心来掩饰它的重要性，以免听故事的人冷淡无情</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第10天</title>
    <link href="/2022/07/15/2022-07-15-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC10%E5%A4%A9/"/>
    <url>/2022/07/15/2022-07-15-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC10%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第10天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P367"><a href="#P367" class="headerlink" title="P367"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=367">P367</a></h4><p>abstract：只能修饰类和方法，不能修饰属性，构造器</p><ul><li>不能修饰final，因为final的类不允许继承，final的方法不允许重写</li><li>不能修饰static（static修饰的方法不能被重写；static能被类名直接调用，但abstract还只是声明没内容调不了）</li><li>不能修饰private，因为private对子类不可见，因此子类调不了abstract方法</li></ul><h4 id="P368"><a href="#P368" class="headerlink" title="P368"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=368">P368</a></h4><p>抽象类和接口的异同：</p><p>相同点：都不能实例化，都可以包含抽象方法</p><p>不同点：</p><ul><li><p>定义，结构：</p><ul><li><p>抽象类</p><ul><li>有构造器</li></ul></li><li><p>接口</p><ul><li>没有构造器</li><li>JDK7及之前，只能有全局常亮和抽象方法，JDK8可以出现静态方法和默认方法，JDK9可以出现私有方法</li></ul></li></ul></li><li><p>继承性：</p><ul><li>抽象类：只能单继承</li><li>接口：多继承</li><li>抽象类和接口：多实现</li></ul></li></ul><h4 id="P369"><a href="#P369" class="headerlink" title="P369"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=369">P369</a></h4><p>不管是成员内部类，还是局部内部类，都会生成对应的字节码文件</p><blockquote><p>成员内部类：Person$Dog.class</p><p>局部内部类：Person$1AA.class。（中间的数字是因为，局部内部类可以出现好多次，可能重名）</p></blockquote><h4 id="P370"><a href="#P370" class="headerlink" title="P370"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=370">P370</a></h4><p>局部内部类如果要用外面的属性，外面的属性只能是final类型（毕竟是两个字节码文件，理论上是不该有联系，但是硬要用也行，那就只能用它的副本，不能改）</p><ul><li>JDK7及之前，要显示声明 final</li><li>JDK8及之后，可以省略不写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AA</span></span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        num = <span class="hljs-number">20</span>; <span class="hljs-comment">// 会报错</span><br>        System.out.println(num); <br>      &#125;  <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意，Android开发里，onCreate函数里，设定按钮监听，就是这种东西</strong></p><h4 id="P371"><a href="#P371" class="headerlink" title="P371"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=371">P371</a></h4><p>Error：Java虚拟机无法解决的问题</p><ul><li>JVM系统内部错误</li><li>系统资源耗尽：栈溢出 java.lang.StackOverFlowError，堆溢出 java.lang.OutOfMemoryError</li></ul><p>Throwable</p><ul><li>Error</li><li>Exception<ul><li>编译时异常(checked)<ul><li>IOException<ul><li>FileNotFoundException</li></ul></li><li>ClassNotFoundException</li></ul></li><li>运行时异常(unchecked)：RuntimeException<ul><li>NullPointerException：null.属性</li><li>ArrayIndexOutOfBoundsException：下标超界</li><li>ClassCastException：Object o = new Date(); String s = (String)o</li><li>NumberFormatException：Integer.parseInt(“abc”)</li><li>InputMismatchException：scanner.nextInt()，结果输入一个字符</li><li>ArithmeticException：10/0</li></ul></li></ul></li></ul><h4 id="P374"><a href="#P374" class="headerlink" title="P374"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=374">P374</a></h4><p>异常处理：抓抛模型</p><ul><li><p>抛</p><ul><li>一旦出现异常，会在异常代码处生成一个对应异常类的对象，并将对象抛出</li><li>抛出后，其它代码就不再执行</li></ul></li><li><p>抓：有两种处理方式</p><ul><li>Try - catch - finally<ul><li>catch可以有多个</li><li>finally不一定要有</li><li>第一个catch命中，直接跳出</li><li>父类exception放在上面，会报子类exception无法到达</li><li>两个常用函数：e.getMessage() 和 e.printStackTrace()，前面只是报错信息，后面会具体到哪行报错</li><li>try - catch 只是把编译报错延迟到运行时（即还是可能会报错），<strong>编译异常变成运行异常，运行异常就不处理，因为反正都是要报一堆信息的</strong></li><li>finally必执行，即使try或catch中有return，即使catch还有异常</li><li>finally中如果有return，优先级高于try或catch里的return</li><li>finally的实际应用在于，对于数据库连接，IO流，socket等，JVM无法自动回收，就得放到finally里</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readFile</span><span class="hljs-params">()</span></span>&#123;<br>  <br>  FileInputStream fi = <span class="hljs-keyword">null</span>;<br>        <br>        <span class="hljs-keyword">try</span>&#123;<br>            File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>            fi = <span class="hljs-keyword">new</span> FileInputStream(file);<br><br>            <span class="hljs-keyword">int</span> data = fi.read();<br><br>            <span class="hljs-keyword">while</span>(data!=-<span class="hljs-number">1</span>)&#123;<br><br>                System.out.print((<span class="hljs-keyword">char</span>)data);<br>                data = fi.read();<br><br>            &#125;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(fi!=<span class="hljs-keyword">null</span>)&#123;<br>                    fi.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>  <br>  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>throws<ul><li>只是把异常抛给调用者，没有处理异常</li><li>异常一旦抓住，后面就不再执行，没有finally类似的东西</li></ul></li></ul></li></ul><h4 id="P379"><a href="#P379" class="headerlink" title="P379"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=379">P379</a></h4><p>异常的继承关系：子类的异常，也得是父类异常的儿子</p><ul><li>理解：比如父类引用，写的代码处理的都是父亲异常，即使你多态导致父类引用指向的是子类，那么子类也是更小的异常，原来的代码框架也能hold住</li></ul><h4 id="P380"><a href="#P380" class="headerlink" title="P380"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=380">P380</a></h4><p>Try-catch 和 throws 的选择问题</p><ul><li>如果父类没有throws，则子类更不能throws，因此只能try-catch</li><li>如果a方法中调用了别的b，c方法，建议b，c 往上throws，a统一try-catch处理（因为一旦出错，其实即使b，c中try-catch处理了，得出的数据也没啥用，不如统一到a中处理）</li></ul><h4 id="P381"><a href="#P381" class="headerlink" title="P381"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=381">P381</a></h4><p>手动抛出异常的时候</p><ul><li>如果是个运行时异常，那么不需要throws来处理</li><li>如果不是运行时异常（大类Exception也算），那么当前函数要throws处理，并且上层函数要么再throws，要么自己try-catch解决</li></ul><h4 id="P382"><a href="#P382" class="headerlink" title="P382"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=382">P382</a></h4><p>自定义异常的三要素</p><ul><li>static final long serialVersionUID</li><li>空参构造器</li><li>String参数构造器</li></ul><h4 id="P383"><a href="#P383" class="headerlink" title="P383"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=383">P383</a></h4><p>try-catch也可以不用catch</p><ul><li>意义：针对运行时异常，虽然不做处理，但是依然能在finally里做一些必要操作</li></ul><h4 id="P384"><a href="#P384" class="headerlink" title="P384"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=384">P384</a></h4><p>运行时异常，可以处理也可以不处理，看需求</p><h4 id="P385"><a href="#P385" class="headerlink" title="P385"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=385">P385</a></h4><p>throw和throws的区别</p><ul><li>throw：生成一个异常，在方法体内，属于“抛”</li><li>throws：抛出一个异常，是异常的处理方式，在方法的声明处，属于“抓”</li></ul><h4 id="P391"><a href="#P391" class="headerlink" title="P391"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=391">P391</a></h4><p>枚举类的替代方法：多利模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Status</span></span>&#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String NAME;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Status</span><span class="hljs-params">(String name)</span></span>&#123;<br>    NAME = name;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Status BUSY = <span class="hljs-keyword">new</span> Status(<span class="hljs-string">&quot;BUSY&quot;</span>);<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Status FREE = <span class="hljs-keyword">new</span> Status(<span class="hljs-string">&quot;FREE&quot;</span>);<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P392"><a href="#P392" class="headerlink" title="P392"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=392">P392</a></h4><p>导入某包下类的所有静态结构，就可以省略包名的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.xxx.xxx.xxx.Data.*;<br><br><span class="hljs-keyword">int</span> n = Data.EMPOLYEE.length; <span class="hljs-comment">// 原来写法</span><br><span class="hljs-keyword">int</span> n = EMPOLYEE.length; <span class="hljs-comment">// 现在写法</span><br></code></pre></td></tr></table></figure><p>Switch 里，多用常量的名字，而非数字表示，这样之后要改直接改常量的定义即可</p><h4 id="P414"><a href="#P414" class="headerlink" title="P414"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=414">P414</a></h4><p>定义快捷键模板：类似psvm</p><ul><li>两个位置，位置2才能自定义</li></ul><p><img src="/2022/07/15/2022-07-15-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC10%E5%A4%A9/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%A8%A1%E6%9D%BF%E4%BD%8D%E7%BD%AE1.png" alt="快捷键模板位置1"></p><p><img src="/2022/07/15/2022-07-15-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC10%E5%A4%A9/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%A8%A1%E6%9D%BF%E4%BD%8D%E7%BD%AE2.png" alt="快捷键模板位置2"></p><h4 id="P415"><a href="#P415" class="headerlink" title="P415"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=415">P415</a></h4><p>程序：一段静态代码</p><p>进程：正在运行的一个程序，是动态的</p><ul><li>进程是系统资源分配的单位（eg. 内存区域）</li></ul><p>线程：一个程序内部的执行路径</p><ul><li>调度和执行的单位</li><li>每个线程有独立的栈和程序计数器</li><li>不同线程共享堆和方法区，因此线程间通信效率更高</li></ul><p>单核CPU和多核CPU的理解：</p><ul><li>单核CPU是一种假的多线程</li><li>一个java程序，至少有3个进程：main()主线程，gc()垃圾回收线程，异常处理线程</li></ul><p>并行和并发：</p><ul><li>并行：多个人同时做多个事情</li><li>并发：一个CPU（采用时间片）同时执行多个事情</li></ul><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h4><ul><li>集合题目，遍历二叉树的每一步其实都要输出，看情况加别的条件</li><li>如果原来的数组有重复元素，先排序，再用 <code>if(i&gt;start &amp;&amp; nums[i]==nums[i-1])&#123; continue;&#125;</code> 来剪枝</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <br>        Arrays.sort(nums);<br><br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        backtrack(path, nums, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;Integer&gt; path, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span></span>&#123;<br><br>        <span class="hljs-comment">// if(start&gt;=nums.length)&#123;</span><br>        <span class="hljs-comment">//     res.add(new ArrayList&lt;&gt;(path));</span><br>        <span class="hljs-comment">//     return;</span><br>        <span class="hljs-comment">// &#125;</span><br><br>        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;nums.length; i++)&#123;<br>          <span class="hljs-comment">// 如何剪枝的重要步骤</span><br>            <span class="hljs-keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            path.add(nums[i]);<br><br>            backtrack(path, nums, i+<span class="hljs-number">1</span>);<br><br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>此类题目总结：重复？反复选？</strong></p><ul><li>集合<ul><li>不重复 + 单选：start来防止重复，下次递归传 i+1，无条件加入res</li><li>不重复 + 多选：start来防止重复，下次递归传 i，无条件加入res</li><li>重复 + 单选：排序， <code>if(i&gt;start &amp;&amp; nums[i]==nums[i-1])&#123; continue;&#125;</code> 防止重复</li></ul></li><li>组合<ul><li>不重复 + 单选：start来防止重复，下次递归传 i+1，path有k个加入res</li><li>不重复 + 多选：start来防止重复，下次递归传 i，path有k个加入res</li><li>重复 + 单选：排序， <code>if(i&gt;start &amp;&amp; nums[i]==nums[i-1])&#123; continue;&#125;</code> 防止重复</li></ul></li><li>排序<ul><li>不重复 + 单选：boolean[] used 来防止重</li><li>不重复 + 多选：貌似啥也不需要</li><li>重复 + 单选：排序， <code>if(i&gt;start &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1])&#123; continue;&#125;</code> 防止重复</li></ul></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第10天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P415开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></li><li><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></li><li><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></li><li><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></li><li><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></li><li><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></li><li><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></li><li><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></li><li><a href="https://leetcode.cn/problems/TVdhkn/">剑指 Offer II 079. 所有子集</a></li><li><a href="https://leetcode.cn/problems/uUsW3B/">剑指 Offer II 080. 含有 k 个元素的组合</a></li><li><a href="https://leetcode.cn/problems/Ygoe9J/">剑指 Offer II 081. 允许重复选择元素的组合</a></li><li><a href="https://leetcode.cn/problems/4sjJUc/">剑指 Offer II 082. 含有重复元素集合的组合</a></li><li><a href="https://leetcode.cn/problems/VvJkup/">剑指 Offer II 083. 没有重复元素集合的全排列</a></li><li><a href="https://leetcode.cn/problems/7p8L0Z/">剑指 Offer II 084. 含有重复元素集合的全排列</a></li></ul><p>感觉今天也没怎么浪，但却看得很少，可能确实越往后面我越不熟悉，速度明显放缓了，经常重放或者慢速，坚持住，然后每天多花点时间</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《被讨厌的勇气》阿德勒</p><p>太在意别人的视线和评价，才会不断寻求别人的认可。对认可的追求，才扼杀了自由。由于不想被任何人讨厌，才选择了不自由的生活方式</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第9天</title>
    <link href="/2022/07/14/2022-07-14-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC9%E5%A4%A9/"/>
    <url>/2022/07/14/2022-07-14-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC9%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第九天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P330"><a href="#P330" class="headerlink" title="P330"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=330">P330</a></h4><p>代码块</p><ul><li>作用：初始化类、对象</li><li>修饰：只能用static</li><li>分类：<ul><li>静态代码块：<ul><li>可以有输出语句</li><li>随着类的加载执行（因此只能执行一次）</li><li>作用：初始化类的信息（静态属性）</li></ul></li><li>非静态代码块<ul><li>可以有输出语句</li><li>随着对象创建执行（因此可以多次执行）</li><li>作用：创建对象时，给属性初始化</li></ul></li></ul></li></ul><h4 id="P331"><a href="#P331" class="headerlink" title="P331"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=331">P331</a></h4><p>代码块的应用，可以再看看，总结下就是：</p><blockquote><p>如果在给静态变量赋值前，还有别的执行语句操作，你不能在类内方法外进行，那静态代码块正好可以弥补这个空缺</p></blockquote><h4 id="P332"><a href="#P332" class="headerlink" title="P332"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=332">P332</a></h4><p>父子类的代码块先后顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_static_block</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B..static&quot;</span>);<br>    &#125;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;B..no-static&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;B..main&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;************&quot;</span>);<br>        <span class="hljs-keyword">new</span> Test_static_block();<br>        System.out.println(<span class="hljs-string">&quot;************&quot;</span>);<br>        <span class="hljs-keyword">new</span> A();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A..static&quot;</span>);<br>    &#125;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;A..no-static&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 输出为</span><br><span class="hljs-comment">A..static</span><br><span class="hljs-comment">B..static</span><br><span class="hljs-comment">B..main</span><br><span class="hljs-comment">************</span><br><span class="hljs-comment">A..no-static</span><br><span class="hljs-comment">B..no-static</span><br><span class="hljs-comment">************</span><br><span class="hljs-comment">A..no-static</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="P333"><a href="#P333" class="headerlink" title="P333"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=333">P333</a></h4><p>属性赋值的先后顺序：</p><ol><li>默认初始化值</li><li>显式初始化值</li><li>代码块赋值</li><li>构造器赋值</li></ol><p>顺序为：1-2/3-4（其中2和3谁类中声明在前，谁先）</p><h4 id="P334"><a href="#P334" class="headerlink" title="P334"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=334">P334</a></h4><p>final关键字，可以修饰</p><ul><li>类：表示不能被继承，例如：String、System、StringBuffer</li><li>方法：表示方法不能被重写，例如：Object中的getClass方法</li><li>变量：表示变量是个常亮，不能被修改<ul><li>属性：赋值的选择：<ul><li>显式赋值：用于赋简单的值，并且每个对象的值都一样</li><li>代码块赋值：用于赋复杂的值，比如值是通过函数计算，有可能还会抛异常</li><li>构造器赋值：用于赋简单的值，只是每个对象的值不一样，通过形参赋值</li></ul></li><li>局部变量：<ul><li>非形参：声明的时候赋值一次，之后不可再赋值</li><li>形参：调用方法的时候已经赋值过了，所以方法内部不能再赋值</li></ul></li></ul></li></ul><p><strong>补充</strong></p><p>native：代表底层是C++写的，这里只是声明，不再展开</p><h4 id="P336"><a href="#P336" class="headerlink" title="P336"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=336">P336</a></h4><p>static final一起的话：修饰属性，代表是 全局，常量</p><h4 id="P337"><a href="#P337" class="headerlink" title="P337"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=337">P337</a></h4><p>final如果修饰一个引用，引用的对象虽然不能变，但是属性可以变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o)</span></span>&#123;<br>  o = <span class="hljs-keyword">new</span> Object(); <span class="hljs-comment">// 报错</span><br>  o.i++; <span class="hljs-comment">//正确</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P339"><a href="#P339" class="headerlink" title="P339"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=339">P339</a></h4><p>static 修饰 类的内部结构：属性，方法，代码块，内部类</p><ul><li>构造器不是，因为static是全局的，构造器是对象的，两者的生命周期不同<ul><li>静态属性用构造器初始化是另外一回事，在这里面不能划等号</li></ul></li></ul><h4 id="P340"><a href="#P340" class="headerlink" title="P340"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=340">P340</a></h4><p>下面这个也算单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> a = <span class="hljs-keyword">new</span> A();<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>但是别忘了final，因为如果没有final，外部是可以 <code>A.a = null</code> 来修改的</p><h4 id="P343"><a href="#P343" class="headerlink" title="P343"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=343">P343</a></h4><p>abstract关键字修饰：</p><ul><li><p>类：即抽象类</p><ul><li>不能被实例化（但是构造器还是有的，毕竟子类实例化要调用）</li></ul></li><li><p>方法：即抽象方法</p><ul><li><p>只有方法的声明，没有方法体（没有<code>&#123;&#125;</code>，只有<code>;</code>）</p></li><li><p>抽象方法的所在类一定是抽象类，但是抽象类的方法不一定是抽象方法（甚至可以都不是抽象方法，因为这些方法可以是静态类调用，可以子类调用）</p></li><li><p>子类只有重写父类里全部抽象方法，才能变成一个可实例化的类，不然只能继续声明成一个抽象类</p></li></ul></li></ul><h4 id="P345"><a href="#P345" class="headerlink" title="P345"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=345">P345</a></h4><p>abstract注意点：</p><ul><li>不能修饰属性，构造器</li><li>不能修饰 private、static、final的方法，final的类</li></ul><h4 id="P347"><a href="#P347" class="headerlink" title="P347"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=347">P347</a></h4><p>匿名（子）类，匿名对象的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <br>    B b = <span class="hljs-keyword">new</span> B();<br>    method(b); <span class="hljs-comment">// 非匿名对象，非匿名子类</span><br>    <br>    method(<span class="hljs-keyword">new</span> B()); <span class="hljs-comment">// 匿名对象，非匿名子类</span><br>    <br>    A a = <span class="hljs-keyword">new</span> A()&#123;     <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>    <br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br><br>      &#125;      <br>    &#125;<br>    method(a); <span class="hljs-comment">// 非匿名对象，匿名子类</span><br>    <br>    method(<span class="hljs-keyword">new</span> A()&#123;     <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>    <br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br><br>      &#125;      <br>    &#125;); <span class="hljs-comment">// 匿名对象，匿名子类</span><br>    <br>    <br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(A a)</span></span>&#123;<br>    a.eat();<br>    a.walk();<br>  &#125;<br>  <br>&#125;<br><br><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>;<br>  <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P348"><a href="#P348" class="headerlink" title="P348"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=348">P348</a></h4><p>模板方法的设计模式：</p><ul><li>确定的地方父类写好，不确定的地方抽象出来，子类重写即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Template t = <span class="hljs-keyword">new</span> SubTemplate();<br>    t.method();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//......确定的代码</span><br>    code();<br>    <span class="hljs-comment">//......确定的代码 </span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span></span>; <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTemplate</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//.....子类特定的方法</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P349"><a href="#P349" class="headerlink" title="P349"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=349">P349</a></h4><p>Calendar类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar c = Calendar.getInstance();<br><span class="hljs-keyword">int</span> month = c.get(Calendar.MONTH); <span class="hljs-comment">// 注意，从0开始算，一月份是0</span><br></code></pre></td></tr></table></figure><h4 id="P351"><a href="#P351" class="headerlink" title="P351"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=351">P351</a></h4><blockquote><p>继承：是不是的关系</p><ul><li>子类 is a 父类</li></ul><p>接口：能不能的关系</p><ul><li>类 can 接口</li></ul></blockquote><p>接口的注意点：</p><ol><li>JDK7及之前，接口中的变量只能是全局常亮（static + final，如果没写也只是省略了而已）</li><li>JDK7及之前，接口中的方法只能是抽象方法（abstract，如果没写也只是省略了而已）</li><li>JDK8及之后，接口中还可以定义静态方法和默认方法</li><li>接口中不能定义构造器，即接口不能实例化</li><li>一个类如果实现了接口中的所有抽象方法，才能实例化，否则只能变成一个抽象类</li><li>写法上，先extends，再implements</li><li>接口之间可以多继承</li></ol><h4 id="P353"><a href="#P353" class="headerlink" title="P353"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=353">P353</a></h4><p>开头的USB例子和数据库例子很好，深得我心</p><ul><li>接口的使用满足多态习惯</li><li>接口，实际上定义了一种规范</li><li>开发项目要面向接口编程</li></ul><h4 id="P354"><a href="#P354" class="headerlink" title="P354"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=354">P354</a></h4><p>匿名实现类 + 匿名对象 的四种排列组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <br>    B b = <span class="hljs-keyword">new</span> B();<br>    method(b); <span class="hljs-comment">// 非匿名对象，非匿名实现类</span><br>    <br>    method(<span class="hljs-keyword">new</span> B()); <span class="hljs-comment">// 匿名对象，非匿名实现类</span><br>    <br>    A a = <span class="hljs-keyword">new</span> A()&#123;     <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>    <br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br><br>      &#125;      <br>    &#125;<br>    method(a); <span class="hljs-comment">// 非匿名对象，匿名实现类</span><br>    <br>    method(<span class="hljs-keyword">new</span> A()&#123;     <br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>    <br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br><br>      &#125;      <br>    &#125;); <span class="hljs-comment">// 匿名对象，匿名实现类</span><br>    <br>    <br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(A a)</span></span>&#123;<br>    a.eat();<br>    a.walk();<br>  &#125;<br>  <br>&#125;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>;<br>  <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="P355"><a href="#P355" class="headerlink" title="P355"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=355">P355</a></h4><p>接口的应用：代理模式，好处：</p><ul><li>原来的人不必亲自下场操作</li><li>除了原来要做的事情，可以做很多其他事情</li><li>如果代理做不了，还可以转接让原来的人做</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_proxy_template</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Server s = <span class="hljs-keyword">new</span> Server();<br>        ProxyServer p = <span class="hljs-keyword">new</span> ProxyServer(s); <span class="hljs-comment">// 或者 NetWork p = new ProxyServer(s);</span><br>        p.browse();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NetWork</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">browse</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NetWork</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">browse</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;真实上网了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NetWork</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> NetWork n;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxyServer</span><span class="hljs-params">(NetWork n)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前期的检查工作&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">browse</span><span class="hljs-params">()</span> </span>&#123;<br><br>        check();<br><br>        n.browse();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意：代理模式，被代理人和代理人都要实现接口中的方法，只是代理人会调用被代理人的方法</strong></p><p>代理模式的应用和分类：</p><p><img src="/2022/07/14/2022-07-14-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC9%E5%A4%A9/Snipaste_2022-07-14_18-53-50.png" alt="代理模式的应用和分类"></p><h4 id="P356"><a href="#P356" class="headerlink" title="P356"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=356">P356</a></h4><p>设计模式的几大原则：</p><ul><li>开闭原则：对扩张开放，对修改封闭（你可以在原来的基础上加，但不要改原来的代码，改坏了就回不去了）</li></ul><p><strong>重点：工厂设计模式</strong></p><ul><li>无工厂模式：生产类和调用类是同一个，没分开</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">```<br><br>- 简单工厂模式：生产者的生产函数只有一个，在里面<span class="hljs-keyword">if</span>-<span class="hljs-keyword">else</span><br>  - 坏处：增加新的品种，就要修改原来的代码<br><br>```java<br></code></pre></td></tr></table></figure><ul><li>工厂方法模式：用接口定义模子，之后多个新品种，只是多了一个实现接口的类而已<ul><li>坏处：本质上还是将代码写死，之后反射的spring会彻底改变这个模式</li></ul></li><li>抽象工厂模式：多了一个族的概念，比如车是接口，那么实现的子类是不同品牌，而族就是跑车，商务车之类的划分</li></ul><h4 id="P357"><a href="#P357" class="headerlink" title="P357"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=357">P357</a></h4><p>如果父类和接口有同名的变量，怎么区分：</p><ul><li>父类中的变量，用 super.x 来调用</li><li>接口中的变量，用 类.x调用（全局常亮嘛）</li></ul><p>实现的两个接口有同名的函数，要不要紧：</p><ul><li>不冲突，重写后等于把两者都覆盖了</li></ul><h4 id="P359"><a href="#P359" class="headerlink" title="P359"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=359">P359</a></h4><p>Jdk8及以后，接口中可以有静态方法和默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AA</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>对于静态方法：</p><ul><li>不能通过继承的类的对象来调用，也不能通过继承的类名来调用，只能用接口名调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_interface_static_default_method</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <br>        BB bb = <span class="hljs-keyword">new</span> BB();<br>        bb.method1(); <span class="hljs-comment">// 报错</span><br>        BB.method1(); <span class="hljs-comment">// 报错</span><br>        AA.method1(); <span class="hljs-comment">// 正确</span><br>        <br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AA</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AA</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于默认方法：</p><ul><li><strong>可以通过继承的类的对象来调用</strong>，但不能通过继承的类名来调用</li><li>如果继承的类重写了接口中的默认方法，调用的就是重写后的</li><li>如果父类和接口函数名重名，则父类优先原则（区别之前的同名属性，那个会报错）</li><li>多个接口如果有同名的默认方法（抽象方法无所谓，之后肯定要重写），那么会报错”接口冲突“，必须强行重写这个方法<ul><li>如果还想调被重写之前的方法，用 接口.super.method()</li></ul></li></ul><p><strong>当然，default方法的意义本来就是为了不被重写，初衷就是希望你直接调用，更趋近于类的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shasha.s20220714;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_interface_default_method</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SubClass s = <span class="hljs-keyword">new</span> SubClass();<br><br><span class="hljs-comment">//s.method1();</span><br><span class="hljs-comment">//SubClass.method1();</span><br>        <span class="hljs-comment">//知识点1：接口中定义的静态方法，只能通过接口来调用。</span><br>        CompareA.method1();<br>        <span class="hljs-comment">//知识点2：通过实现类的对象，可以调用接口中的默认方法。</span><br>        <span class="hljs-comment">//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span><br>        s.method2();<br>        <span class="hljs-comment">//知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</span><br>        <span class="hljs-comment">//那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span><br>        <span class="hljs-comment">//知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span><br>        <span class="hljs-comment">//那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突。</span><br>        <span class="hljs-comment">//这就需要我们必须在实现类中重写此方法</span><br>        s.method3();<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CompareA</span>,<span class="hljs-title">CompareB</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;SubClass：上海&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">//    public void method3()&#123;</span><br><span class="hljs-comment">//        System.out.println(&quot;SubClass：深圳&quot;);</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-comment">//知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;<br>        method3();<span class="hljs-comment">//调用自己定义的重写的方法</span><br>        <span class="hljs-keyword">super</span>.method3();<span class="hljs-comment">//调用的是父类中声明的</span><br>        <span class="hljs-comment">//调用接口中的默认方法</span><br>        CompareA.<span class="hljs-keyword">super</span>.method3();<br>        CompareB.<span class="hljs-keyword">super</span>.method3();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;SuperClass:北京&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompareA</span> </span>&#123;<br><br>    <span class="hljs-comment">//静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CompareA:北京&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//默认方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CompareA：上海&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CompareA：上海&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompareB</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CompareB：上海&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P362"><a href="#P362" class="headerlink" title="P362"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=362">P362</a></h4><p>内部类分为：</p><ul><li>成员内部类<ul><li>一方面，作为外部类的成员<ul><li>可以调用外部类的结构</li><li>可以被static修饰（普通类不能被static修饰）</li><li>可以被4种权限修饰符修饰（普通类只能被public / 缺省修饰）</li></ul></li><li>另一方面，作为一个类<ul><li>可以定义属性、方法、构造器</li><li>可以被final修饰（不能被继承）；不被修饰就是能继承</li><li>可以被abstract修饰</li></ul></li></ul></li><li>局部内部类<ul><li>待续。。。。。。</li></ul></li></ul><p><strong>注意：成员内部类的如果是非静态的，内部的方法调用外部的方法，应该<code>Person.this.eat();</code>，属性类似：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_inner_class</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Person.Dog d = <span class="hljs-keyword">new</span> Person.Dog();<br>        d.show();<br><br>        Person p = <span class="hljs-keyword">new</span> Person();<br>        Person.Bird b = p.<span class="hljs-function">new <span class="hljs-title">Bird</span><span class="hljs-params">()</span></span>;<br>        b.sing();<br><br>        b.display(<span class="hljs-string">&quot;33&quot;</span>);<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    String name = <span class="hljs-string">&quot;11&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃吃吃&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;是修狗&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>&#123;<br><br>        <span class="hljs-keyword">public</span> String name = <span class="hljs-string">&quot;22&quot;</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bird</span><span class="hljs-params">()</span></span>&#123;<br><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;叽叽喳喳&quot;</span>);<br>            Person.<span class="hljs-keyword">this</span>.eat(); <span class="hljs-comment">// 调用外部的方法</span><br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(String name)</span></span>&#123;<br>            System.out.println(name);<br>            System.out.println(<span class="hljs-keyword">this</span>.name);<br>            System.out.println(Person.<span class="hljs-keyword">this</span>.name); <span class="hljs-comment">// 调用外部的属性</span><br>        &#125;<br><br>    &#125;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P363"><a href="#P363" class="headerlink" title="P363"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=363">P363</a></h4><p>调用成员内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_inner_class</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Person.Dog d = <span class="hljs-keyword">new</span> Person.Dog();<br>        d.show();<br><br>        Person p = <span class="hljs-keyword">new</span> Person();<br>        Person.Bird b = p.<span class="hljs-function">new <span class="hljs-title">Bird</span><span class="hljs-params">()</span></span>;<br>        b.sing();<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;是修狗&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;叽叽喳喳&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P365"><a href="#P365" class="headerlink" title="P365"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=365">P365</a></h4><p>局部内部类的使用：一般用于返回一个指定了接口造出来的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Comparable <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComparable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span></span>&#123;<br>    <br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyComparable();<br>  <br>  <span class="hljs-comment">// 更简洁写法</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Comparable()&#123;<br>    <br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P366"><a href="#P366" class="headerlink" title="P366"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=365">P366</a></h4><p>易错点：</p><ul><li>接口可以继承接口</li><li>抽象类能实现接口</li><li>抽象类能继承非抽象类（任意抽象类都继承Object）</li></ul><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></h4><ul><li>这种回溯题目，设定一个start，能有效解决这种集合的顺序问题（{1,2,3}和{1,3,2}是同个东西）</li><li>递归的参数写的是 i，不是start</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        backtrack(path, target, <span class="hljs-number">0</span>, candidates);<br>        <span class="hljs-keyword">return</span> res;        <br>    &#125;<br>    <br>    List&lt;List&lt;Integer&gt;&gt; res;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;Integer&gt; path, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span>[] candidates)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;candidates.length; i++)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(candidates[i]&lt;=target)&#123;<br>                <br>                path.add(candidates[i]);<br>                <br>                backtrack(path, target-candidates[i], i, candidates);<br>                <br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br>                <br>            &#125;          <br>        &#125;        <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h4><ul><li>跟前面的题目比，不同在出现了重复元素，如何避免重复元素，中间的 if 判断好好体会</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        Arrays.sort(candidates);<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        backtrack(path, target, <span class="hljs-number">0</span>, candidates);<br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>    <br>    List&lt;List&lt;Integer&gt;&gt; res;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;Integer&gt; path, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span>[] candidates)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;candidates.length; i++)&#123;<br>            <br>          <span class="hljs-comment">// 好好体会，确实没想得出来</span><br>            <span class="hljs-keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(candidates[i]&lt;=target)&#123;<br>                <br>                path.add(candidates[i]);<br>                <br>                backtrack(path, target-candidates[i], i+<span class="hljs-number">1</span>, candidates);<br>                <br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br>                <br>            &#125;<br>        &#125;<br>        <br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第九天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P366开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></li><li><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></li><li><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></li></ul><p>感觉今天也没怎么浪，但却看得很少，可能确实越往后面我越不熟悉，速度明显放缓了，经常重放或者慢速，坚持住，然后每天多花点时间</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《动物农庄》乔治·奥威尔</p><p>他最害怕的是：以为自己是那只特别的，清醒的又无可奈何的猪，到头来其实也只是埋头吃食的一员</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第8天</title>
    <link href="/2022/07/13/2022-07-13-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC8%E5%A4%A9/"/>
    <url>/2022/07/13/2022-07-13-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC8%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第八天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P284"><a href="#P284" class="headerlink" title="P284"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=284">P284</a></h4><p>父类中的private属性和方法怎么调用：</p><ul><li>方法：父类的非private方法中，调用即可（这样子类也能调用那个方法）</li><li>属性：父类的非private方法中，调用即可</li></ul><p>因此，子类在堆中会有所有父类的东西（你代码调不调用是你的事，但是一定要available）</p><h4 id="P285"><a href="#P285" class="headerlink" title="P285"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=285">P285</a></h4><p>重载和重写的区别</p><ul><li><p>概念：</p><ul><li>重载：同一个类（也包括子父类），同名不同形参列表的方法。</li><li>重写：子类和父类间，同名同参数列表的方法</li></ul></li><li><p>具体规则：</p><ul><li>重载：除了定义里提到的，返回值、权限修饰符、形参变量名都没关系</li><li>重写：权限修饰符要相等或更大（父类不能是private），返回值要相等或子类（void、基本数据类型要相等），异常要相等或子类</li></ul></li><li><p>多态性：</p><ul><li>重载：不是多态性，编译期绑定了调用地址，所以称为“早绑定”或“静态绑定”</li><li>重写：是多态性，只有在解释运行的时候才知道调用哪个方法，称为“晚绑定”或“”动态绑定“</li></ul></li></ul><h4 id="P286"><a href="#P286" class="headerlink" title="P286"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=286">P286</a></h4><p>为什么super和this不能同时出现在一个构造器中？</p><ul><li>因为它们都限制只能出现在首行</li></ul><p>为什么只能出现在首行？</p><ul><li>因为构造子类对象，你得先保证初始化父类（毕竟继承了父类中的各种属性，你得知道它们是怎么被初始化的）</li></ul><p><strong>注意</strong></p><p>其实多态的作用，就是为了减少大量的重载，提高通用性</p><h4 id="P287"><a href="#P287" class="headerlink" title="P287"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=287">P287</a></h4><p>父类引用怎么调用子类的属性或方法：</p><ul><li>向下转型：强制转换符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Man();<br>Man m = (Man)p;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p>对于类型转换，还是要看堆中的本质结构（即运行看右边的东西），即使左边是父类引用，但是转换成功与否的标准，依然是看本质是个什么东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Man(); <span class="hljs-comment">// 本质是个man</span><br>Man m = (Man)p;<br>Women w = (Women)p; <span class="hljs-comment">// 这个会报类型转换错误</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="P288"><a href="#P288" class="headerlink" title="P288"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=288">P288</a></h4><p>a instanceof B：a是B的对象或者B的子类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> X(); <span class="hljs-comment">//a可能是X或者X的子类</span><br><br><span class="hljs-keyword">if</span>(a instance of B)&#123;<span class="hljs-comment">// a是否是B或者B的子类，是的话，代表肯定至少有甚至多于B的属性，这样之后强转不会报错，因为向上强转是ok的</span><br>  B b = (B)a; <span class="hljs-comment">//进来肯定是向上转型，向上转型肯定是成功的：a向上转成B类，这样就能调用B中的属性和方法了</span><br>&#125;<br><span class="hljs-comment">//例子</span><br><span class="hljs-keyword">if</span>(a instance of Object)&#123;<span class="hljs-comment">// true</span><br>  Object o = (Object)a;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>所谓保证转型是否成功，核心就是它的转换是否是本质上的向上转换（包括自身）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Man();<br>Man m = (Man)p; <span class="hljs-comment">// 成功，本质是man转man</span><br><br>Man m  = <span class="hljs-keyword">new</span> Man();<br>Person p = (Person)m; <span class="hljs-comment">// 成功，本质是man转person，向上转肯定是成功的</span><br><br>Person p = <span class="hljs-keyword">new</span> Person();<br>Man m = (Man)p; <span class="hljs-comment">// 失败，本质是person转man，向下转型肯定是失败的（这里的向下转型跟上面提到的不一样，这里的向下失败是指本质的向下，而非引用类型的向下）</span><br></code></pre></td></tr></table></figure><blockquote><p>向上转子类属性用不到，类似强转里的精读损失，但并没有真正损失，两次转换回来没有丢东西（堆的内存没有删减）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Man m = <span class="hljs-keyword">new</span> Man();<br>Person p = (Person)m;<br>Man mm = (Man)p;<br>System.out.println(mm.mm); <span class="hljs-comment">// 能输出东西</span><br></code></pre></td></tr></table></figure><h4 id="P290"><a href="#P290" class="headerlink" title="P290"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=290">P290</a></h4><p>属性都看左边，方法编译左运行右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(a);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>&#123;<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(a);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Sub s = <span class="hljs-keyword">new</span> Sub();<br>    System.out.println(s.a); <span class="hljs-comment">// 2</span><br>    s.show(); <span class="hljs-comment">// 2</span><br>    <br>    Base b = s;<br>    <br>    System.out.println(b==s); <span class="hljs-comment">// true</span><br>    System.out.println(b.a); <span class="hljs-comment">// 1</span><br>    b.show(); <span class="hljs-comment">// 2</span><br>    <br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P293"><a href="#P293" class="headerlink" title="P293"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=293">P293</a></h4><p>易错点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_field_method2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Base1 b = <span class="hljs-keyword">new</span> Sub1();<br>        b.show(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// sub1，就是普通的多态</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>... arr)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;base1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sub1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_field_method2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Base1 b = <span class="hljs-keyword">new</span> Sub1();<br>        b.show(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// sub1，不要被混淆，Base1里没有3int的方法，所以多态只能指向sub1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>... arr)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;base1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sub1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sub2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_field_method2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Base1 b = <span class="hljs-keyword">new</span> Sub1();<br>        b.show(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// sub1</span><br>      Sub1 s = (Sub1)b;<br>        s.show(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// sub2，因为是Sub1类型，所以不是多态题目，那就看优先匹配哪个</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>... arr)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;base1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sub1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sub2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P298"><a href="#P298" class="headerlink" title="P298"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=298">P298</a></h4><p>equals方法，x.equals(null) 一定是false</p><p><strong>注意</strong></p><p>== 和 equals，比较的对象至少要能通过自动类型提升来保证数据类型一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> fl = <span class="hljs-number">65.0f</span>;<br><span class="hljs-keyword">int</span> it = <span class="hljs-number">65</span>;<br>System.out.println(fl==it); <span class="hljs-comment">//true</span><br><br><span class="hljs-keyword">char</span> ch1 = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-keyword">int</span> it = <span class="hljs-number">65</span>;<br>System.out.println(ch1==it); <span class="hljs-comment">//true</span><br><br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>==<span class="hljs-keyword">new</span> java.util.Date()); <span class="hljs-comment">//编译报错</span><br></code></pre></td></tr></table></figure><h4 id="P300"><a href="#P300" class="headerlink" title="P300"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=300">P300</a></h4><p>equals方法的大概思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123;<br>  <br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==o)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> A)&#123; <span class="hljs-comment">// 这种写法不大严密，如果Person.equals(Man)，逻辑上肯定不一样（不是一个类，但是返回了true），推荐用getClass()!=o.getClass()</span><br>    A a = (A)o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.xxx==a.xxx;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P301"><a href="#P301" class="headerlink" title="P301"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=301">P301</a></h4><p>默认的toString()方法，输出的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> getClass().getName()+<span class="hljs-string">&quot;@&quot;</span>+Integer.toHexString(hashcode());<br></code></pre></td></tr></table></figure><p>为什么打印任何一个类，是输出toString()的内容</p><ul><li>因为println()里，输出的是String.valueOf(x)，而这个再进去，就是obj.toString();</li></ul><h4 id="P303"><a href="#P303" class="headerlink" title="P303"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=303">P303</a></h4><p>单元测试：</p><ul><li><p>导包：jUnit 4</p><p>import org.junit.Test;</p></li><li><p>类的要求：public，且有公共无参构造器（默认不写即可）</p></li><li><p>方法的要求：public，void，无形参</p></li><li><p>加注解@Test</p></li></ul><h4 id="P304"><a href="#P304" class="headerlink" title="P304"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=304">P304</a></h4><p>基本数据类型的包装类：</p><p>数值类型的包装类都有一个父类：Number</p><h4 id="P305"><a href="#P305" class="headerlink" title="P305"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=305">P305</a></h4><p>Boolean的包装类额外注意，转换为小写后，只要不是”true“，都是false：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Boolean b = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-string">&quot;tRuE&quot;</span>);<span class="hljs-comment">// true</span><br>Boolean b2 = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-string">&quot;true123&quot;</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>另外，属性如果是Boolean，默认值是null，不是false（区别于boolean）</p><h4 id="P307"><a href="#P307" class="headerlink" title="P307"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=307">P307</a></h4><p>JDK5.0以后有自动装箱和拆箱</p><p>不能自动的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> b = a.intValue();<br></code></pre></td></tr></table></figure><h4 id="P308"><a href="#P308" class="headerlink" title="P308"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=308">P308</a></h4><p>包装类 -&gt; String：String.valueOf();</p><p>String -&gt; 包装类：Integer.parseInt();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = String.valueOf(<span class="hljs-number">1</span>);<br>String s2 = String.valueOf(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">int</span> i = Integer.parseInt(<span class="hljs-string">&quot;123&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="P309"><a href="#P309" class="headerlink" title="P309"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=309">P309</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Object o = True?<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>)?<span class="hljs-keyword">new</span> Double(<span class="hljs-number">2.0</span>);<br>System.out.println(o); <span class="hljs-comment">// 1.0，因为编译的时候三元运算符会自动提升类型，所以前者已经变成1.0了</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer m = <span class="hljs-number">1</span>;<br>Integer n = <span class="hljs-number">1</span>;<br>System.out.println(m==n); <span class="hljs-comment">// true</span><br><br>Integer x = <span class="hljs-number">128</span>;<br>Integer y = <span class="hljs-number">128</span>;<br>System.out.println(m==n); <span class="hljs-comment">// false; Integer 内部有个IntegerCache的内部类，内部有个Integer数组cache，缓存了-128~127的Integer，类似于常量池，超出这个范围就是重新new，在这个里面取的是同一个，提高效率</span><br></code></pre></td></tr></table></figure><h4 id="P310"><a href="#P310" class="headerlink" title="P310"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=310">P310</a></h4><p>obj转成int，可以一步到位，不必两步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Object o;<br><span class="hljs-keyword">int</span> a = (<span class="hljs-keyword">int</span>)o; <span class="hljs-comment">//一步到位</span><br><br>Integer aa = (Integer)o;<br><span class="hljs-keyword">int</span> a = aa.intValue();<span class="hljs-comment">// 两步版本</span><br></code></pre></td></tr></table></figure><p>包装类的意义在于，太多数据结构，类的方法都是参数是类，这样才能享受到继承多态的好处</p><h4 id="P311"><a href="#P311" class="headerlink" title="P311"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=311">P311</a></h4><p>向上转型其实就是多态，一般不提这个词（之前强转成功的关键看是不是向上转型，只是理解上这么总结，不是这里的向上）</p><p>向下转型：目的是为了调用子类的属性和方法</p><p><strong>注意</strong></p><p>大类到小类不需要强转（多态保证），小类到大类要强转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Man();<br>Man man = (Man)p;<br></code></pre></td></tr></table></figure><h4 id="P312"><a href="#P312" class="headerlink" title="P312"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=312">P312</a></h4><p>如果是两个不相关的类instanceof，编译就会报错</p><p><strong>面试题：对多态性的理解</strong></p><ul><li>实现代码的通用性</li><li>例子：Object中的equals(Object obj)</li><li>抽象类、接口的使用（不能实例化）</li></ul><h4 id="P313"><a href="#P313" class="headerlink" title="P313"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=313">P313</a></h4><p>Object类中没有属性，只有一个空参构造器</p><p>数组可以看成一个特殊的类，继承自Object，可以调用各种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>method(arr);<br>System.out.println(arr.getClass()); <span class="hljs-comment">// class [I，代表是一位数组，int型</span><br>System.out.println(arr.getClass().getSuperClass()); <span class="hljs-comment">// class java.lang.Object</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Object o)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="P317"><a href="#P317" class="headerlink" title="P317"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=317">P317</a></h4><p>静态变量既可以用 类.静态变量，也可以用对象.静态变量</p><p>静态变量存在于方法区的静态域中</p><p>举例：System.out，Math.PI</p><h4 id="P319"><a href="#P319" class="headerlink" title="P319"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=319">P319</a></h4><p>静态方法内不能使用this，super关键字</p><p>静态属性和方法的使用，可以用生命周期的角度解释</p><h4 id="P320"><a href="#P320" class="headerlink" title="P320"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=320">P320</a></h4><p>工具类的方法，一般都声明为static</p><h4 id="P325"><a href="#P325" class="headerlink" title="P325"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=325">P325</a></h4><p>单例设计模式：饿汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Bank b1 = Bank.getInstance();<br>    Bank b2 = Bank.getInstance();<br>    <br>    System.out.println(b1==b2); <span class="hljs-comment">//true</span><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bank bank = <span class="hljs-keyword">new</span> Bank();<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bank <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> bank;<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>单例设计模式：懒汉式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Order b1 = Order.getInstance();<br>    Order b2 = Order.getInstance();<br>    <br>    System.out.println(b1==b2); <span class="hljs-comment">//true</span><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Order</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Order order = <span class="hljs-keyword">null</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Order <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(order==<span class="hljs-keyword">null</span>)&#123;<br>      order = <span class="hljs-keyword">new</span> Order();<br>    &#125;<br>    <span class="hljs-keyword">return</span> order;<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P327"><a href="#P327" class="headerlink" title="P327"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=327">P327</a></h4><p><strong>区别</strong></p><p>懒汉式</p><ul><li>好处：延迟对象的创建</li><li>坏处：目前线程不安全</li></ul><p>饿汉式</p><ul><li>坏处：对象加载时间过长</li><li>好处：线程安全</li></ul><h4 id="P328"><a href="#P328" class="headerlink" title="P328"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=328">P328</a></h4><p>单例的好处：减少系统性能开销，当一个对象的产生需要比较多的资源时（如读取配置，产生其他依赖对象），则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存</p><p>例子：</p><ul><li>java.lang.Runtime</li><li>网站的计数器</li><li>应用程序的日志</li><li>数据库连接池</li><li>读取配置文件的类</li><li>Application，手机app</li><li>windows 的回收站，任务管理器</li></ul><h4 id="P329"><a href="#P329" class="headerlink" title="P329"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=329">P329</a></h4><p>main方法之所以是static，是因为这个方法是入口，因此是在当前类构造出之前调用，要能达到这个效果，只能申明为static</p><p>String[] args，里面的内容不包括main.exe之类的</p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="752-Open-the-Lock"><a href="#752-Open-the-Lock" class="headerlink" title="752. Open the Lock"></a><a href="https://leetcode.com/problems/open-the-lock/">752. Open the Lock</a></h4><ul><li>如果在dead里，不能continue，因为会把往下转一次的给跳过</li><li>下面这个写法不优美，其实完全可以不要额外把第一个节点做一次验证，而是都放到循环里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> </span>&#123;<br>        <br>        HashSet&lt;String&gt; dead = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String tmp : deadends)&#123;<br>            dead.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dead.contains(<span class="hljs-string">&quot;0000&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target.equals(<span class="hljs-string">&quot;0000&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        ArrayDeque&lt;String&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        q.addLast(<span class="hljs-string">&quot;0000&quot;</span>);<br>        dead.add(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <br>        <span class="hljs-keyword">int</span> step = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> n = q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>                String cur = q.removeFirst();<br>                <br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">4</span>; j++)&#123;<br>                    String upString = up(cur, j);<br>                    <span class="hljs-keyword">if</span>(!dead.contains(upString))&#123;<br>                        <span class="hljs-keyword">if</span>(upString.equals(target))&#123;<br>                            <span class="hljs-keyword">return</span> step;<br>                        &#125;<br>                        q.addLast(upString);<br>                        dead.add(upString);<br>                    &#125;<br>                    <br>                    <br>                    String downString = down(cur, j);<br>                    <span class="hljs-keyword">if</span>(!dead.contains(downString))&#123;<br>                        <span class="hljs-keyword">if</span>(downString.equals(target))&#123;<br>                            <span class="hljs-keyword">return</span> step;<br>                        &#125;<br>                        q.addLast(downString);<br>                        dead.add(downString);<br>                    &#125;<br>                    <br>                    <br>                &#125;               <br>                <br>            &#125;<br>            step++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">up</span><span class="hljs-params">(String cur, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = cur.toCharArray();<br>        <span class="hljs-keyword">if</span>(ss[j]==<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            ss[j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ss[j]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(ss);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">down</span><span class="hljs-params">(String cur, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = cur.toCharArray();<br>        <span class="hljs-keyword">if</span>(ss[j]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            ss[j] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ss[j]--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(ss);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>正确写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> </span>&#123;<br>        HashSet&lt;String&gt; visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String cur : deadends)&#123;<br>            visited.add(cur);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(visited.contains(<span class="hljs-string">&quot;0000&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;0000&quot;</span>.equals(target))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        ArrayDeque&lt;String&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        q.addLast(<span class="hljs-string">&quot;0000&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br><br>            <span class="hljs-keyword">int</span> n = q.size();<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>                String cur = q.removeFirst();<br><br>                <span class="hljs-keyword">if</span>(cur.equals(target))&#123;<br>                    <span class="hljs-keyword">return</span> res;<br>                &#125;<br>                <br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br><br>                    String upup = up(cur, i);<br>                    <span class="hljs-keyword">if</span>(!visited.contains(upup))&#123;<br>                        q.addLast(upup);<br>                        visited.add(upup);<br>                    &#125;<br><br>                    String downdown = down(cur, i);<br>                    <span class="hljs-keyword">if</span>(!visited.contains(downdown))&#123;<br>                        q.addLast(downdown);<br>                        visited.add(downdown);<br>                    &#125;<br><br>                &#125;<br>            &#125;<br><br>            res++;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">up</span><span class="hljs-params">(String cur, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = cur.toCharArray();<br>        <span class="hljs-keyword">if</span>(ss[k]==<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            ss[k] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ss[k]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(ss);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">down</span><span class="hljs-params">(String cur, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = cur.toCharArray();<br>        <span class="hljs-keyword">if</span>(ss[k]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            ss[k] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ss[k]--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(ss);<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第八天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P330开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li><li><a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></li><li><a href="https://leetcode.cn/problems/zlDJc7/">剑指 Offer II 109. 开密码锁</a></li></ul><p>中途浪了一段时间，不然进度可以再往前推一推，感觉必须在7.20之前解决掉那个视频系列，好有太多东西要弄</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《人间失格》</p><p>太敏感的人会体谅到他人的痛苦，自然就无法轻易做到坦率。所谓的坦率，其实就是暴力</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第7天</title>
    <link href="/2022/07/12/2022-07-12-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC7%E5%A4%A9/"/>
    <url>/2022/07/12/2022-07-12-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC7%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第七天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P234"><a href="#P234" class="headerlink" title="P234"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=234">P234</a></h4><p>this还可以用于构造器，降低冗余：调用本类中其它构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>  <br>  <span class="hljs-keyword">int</span> a;<br>  <span class="hljs-keyword">int</span> b;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>&#123;<br>    <br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>();<br>    <span class="hljs-keyword">this</span>.a = a;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>(a);<br>    <span class="hljs-keyword">this</span>.b = b;<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>构造器相互调用，不能成环<ul><li>因此，n个构造器只能最后有n-1次相互调用</li></ul></li><li>this()，只能放在首行<ul><li>因此，一个构造器不能有两次this调用别的构造器</li></ul></li></ul><h4 id="P235"><a href="#P235" class="headerlink" title="P235"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=235">P235</a></h4><p>类的compare函数，返回值：</p><ul><li>正数：当前对象大</li><li>复数：形参对象大</li><li>0：一样大</li></ul><h4 id="P239"><a href="#P239" class="headerlink" title="P239"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=239">P239</a></h4><p><img src="/2022/07/12/2022-07-12-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC7%E5%A4%A9/image-20220712095317201.png" alt="MVC设计模式"></p><h4 id="P240"><a href="#P240" class="headerlink" title="P240"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=240">P240</a></h4><p>import：导入类/接口</p><p>如果使用了：</p><ul><li>java.lang包</li><li>本包</li></ul><p>下的同级的东西，不需要显示import</p><p><strong>注意区别</strong></p><ul><li>如果是上述两种情况下的子包，还是要另外import，或者加上包名前缀</li></ul><p>import还可以导入类的静态成员，这样就可以省略类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.System.*;<br><span class="hljs-keyword">import</span> java.lang.Math.*;<br><br>out.println(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-keyword">int</span> a = max(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><br></code></pre></td></tr></table></figure><h4 id="P244"><a href="#P244" class="headerlink" title="P244"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=244">P244</a></h4><p>eclipse的快捷键，可以看看</p><h4 id="P260"><a href="#P260" class="headerlink" title="P260"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=260">P260</a></h4><p>继承的好处：</p><ul><li>提高复用，减少冗余</li><li>便于功能扩展（直接加在父类里）</li><li>为多态的使用提供前提</li></ul><h4 id="P261"><a href="#P261" class="headerlink" title="P261"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=261">P261</a></h4><p>父类的私有属性/方法，子类也能继承到，只是不能直接调用而已</p><h4 id="P262"><a href="#P262" class="headerlink" title="P262"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=262">P262</a></h4><ul><li>Java中类只能单继承</li><li>直接继承的叫直接父类，间接继承的叫间接父类</li></ul><h4 id="P273"><a href="#P273" class="headerlink" title="P273"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=273">P273</a></h4><p>重写：</p><ul><li>方法的方法名和形参列表相同</li><li>权限修饰符：子类比父类更宽松</li><li>特别的，private修饰的方法不能被重写（你写了也不报错，编译器不会识别，并且运行的也是父类的方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person eat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Person walk&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">person_test</span><span class="hljs-params">()</span></span>&#123;<br>        walk();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Student eat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Student walk&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_person_student</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br><br>        <span class="hljs-comment">// 正常的覆盖：显示&quot;Student eat&quot;</span><br>        s.eat();<br>        <span class="hljs-comment">// 没有覆盖：显示&quot;Person walk&quot;</span><br>        s.person_test();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>返回值类型：</p><ul><li>如果父类是void，子类重写也只能是void</li><li>如果父类是A类型，子类可以是A或者A的子类</li><li>如果父类是基本数据类型，子类也得是相同的基本数据类型</li></ul></li><li><p>异常：子类的异常也要是父类异常的平级或子类</p></li><li><p>关于static：同名同参数的方法，要么都加static，要么都不加（加了static，已经不叫重写了，重写特指非static）</p></li></ul><h4 id="P276"><a href="#P276" class="headerlink" title="P276"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=276">P276</a></h4><p>子父类，有同名属性，是共存而非覆盖，用super+this（可省略）来区分</p><ul><li>this过程：现在本类中找，优先子类，找不到再去父类找，再找不到再上移找</li><li>super过程：跳过本类，直接去父类找，找不到再去更上层的父类找</li></ul><p><strong>存疑：</strong></p><p>多级父类的爷变量咋调用，测试了不能super.super</p><h4 id="P277"><a href="#P277" class="headerlink" title="P277"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=277">P277</a></h4><p>super调用构造器，只能放在首行</p><ul><li>因此和this()调用构造器冲突，只能2选1</li></ul><p>如果构造器既没有super又没有this，其实默认是调用了父类的空参构造器super()</p><ul><li>因此有时候报错是因为父类子类没有同时都有空参构造器</li></ul><p>子类构造器（非object都算），多个构造器中至少有一个是用super的</p><h4 id="P278"><a href="#P278" class="headerlink" title="P278"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=278">P278</a></h4><p>之所以子类能继承父类的各种结构，是因为子类的任意一个构造器，都会直接间接用到super构造器（如果this()构造，那么this指向的构造器也会直接间接指向super），因此这样一直循环到调用到object的构造器，因为就会加载所有的父类结构，因此所有父类的所有属性，都会被继承在堆中分配了空间</p><h4 id="P280"><a href="#P280" class="headerlink" title="P280"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=280">P280</a></h4><p>对象的多态性：父类的引用，指向子类的对象</p><p>多态的使用：虚拟方法的调用（虚拟方法只父类方法，因为运行时都是执行子类方法，所以谓之虚）</p><ul><li>编译期，只能调用父类中声明的方法（因此如果只有子类有的方法，是无法通过父类引用调用的）</li><li>运行期，实际执行的是子类重写父类的方法</li></ul><p>（编译看左，执行看右）</p><p>多态性的使用前提：</p><ul><li>类的继承关系</li><li>方法的重写</li></ul><h4 id="P281"><a href="#P281" class="headerlink" title="P281"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=281">P281</a></h4><p>多态后面两个例子可以再领悟，确实重写+多态能节省很多代码量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数据库例子</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectSql</span><span class="hljs-params">(Connection con)</span></span>&#123;<br>  con.method1();<br>  con.method2();<br>  con.method3();<br>&#125;<br><br><span class="hljs-comment">//真正在使用的时候，con传的都是子类，比如mysqlConnection, oracleConnection，然后因为重写+多态，同样的上述代码，能在不同的数据上获得数据，所以很方便</span><br></code></pre></td></tr></table></figure><h4 id="P282"><a href="#P282" class="headerlink" title="P282"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=282">P282</a></h4><p>多态不适用于属性：</p><ul><li>如果是父类子类都有同名的属性，不管编译还是运行，都是父类的属性</li></ul><p>（编译运行，都看左边）</p><h4 id="P283"><a href="#P283" class="headerlink" title="P283"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=283">P283</a></h4><p>重载和重写的区别：</p><ul><li>重载本质上是不同的方法，编译期已经确定了它们各自不同的地址，方法调用前已经知道代码要调用哪个方法，称为”早绑定“或“静态绑定”<ul><li>子类也可以重载父类的方法</li></ul></li><li>重写，或者进一步讲是多态这个层面，只有等到调用那一刻，解释运行器才知道调用哪个方法，称为“晚绑定”或”动态绑定“</li></ul><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a><a href="https://leetcode.com/problems/permutations/">46. Permutations</a></h4><p>不重复元素的全排列，记录哪个元素被用过，建一个boolean数组，而不是用list的contains函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>        backtrack(path, nums, used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    List&lt;List&lt;Integer&gt;&gt; res;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;Integer&gt; path, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size()==nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!used[i])&#123;<br>                path.add(nums[i]);<br>                used[i] = <span class="hljs-keyword">true</span>;<br>                backtrack(path, nums, used);<br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br>                used[i] = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a><a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a></h4><ul><li>for循环里，两个int定义只要写一个int就行</li><li>for循环里，条件判断用&amp;&amp;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        backtrack(path, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    List&lt;List&lt;String&gt;&gt; res;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;String&gt; path, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(isValid(path, row, i, n))&#123;<br>                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;i; j++)&#123;<br>                    sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                &#125;<br>                sb.append(<span class="hljs-string">&#x27;Q&#x27;</span>);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;n; j++)&#123;<br>                    sb.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                &#125;<br>                <br>                path.add(sb.toString());<br>                <br>                backtrack(path, row+<span class="hljs-number">1</span>, n);<br>                <br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br>                <br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(List&lt;String&gt; path, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-keyword">if</span>(path.get(i).charAt(col)==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = row - <span class="hljs-number">1</span>, c = col - <span class="hljs-number">1</span>; r&gt;=<span class="hljs-number">0</span> &amp;&amp; c&gt;=<span class="hljs-number">0</span>; r--, c--)&#123;<br>            <span class="hljs-keyword">if</span>(path.get(r).charAt(c)==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = row - <span class="hljs-number">1</span>, c = col + <span class="hljs-number">1</span>; r&gt;=<span class="hljs-number">0</span> &amp;&amp; c&lt;n; r--, c++)&#123;<br>            <span class="hljs-keyword">if</span>(path.get(r).charAt(c)==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第七天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P284开头，刷题如下：</p><ul><li><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></li><li><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></li><li><a href="https://leetcode.cn/problems/VvJkup/">剑指 Offer II 083. 没有重复元素集合的全排列</a></li></ul><p>中途浪了一段时间，不然进度可以再往前推一推，感觉必须在7.20之前解决掉那个视频系列，好有太多东西要弄</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>我是烈火，也是枯枝，一部分的我消耗着另一部分</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第6天</title>
    <link href="/2022/07/11/2022-07-11-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC6%E5%A4%A9/"/>
    <url>/2022/07/11/2022-07-11-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC6%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第六天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P221-222"><a href="#P221-222" class="headerlink" title="P221-222"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=221">P221-222</a></h4><p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p><p>低耦合：仅对外暴露少量的方法用于使用</p><p>封装性的体现：</p><ol><li><p>类的成员私有化，同时提供公共的方法来获取和设置成员的值</p><ul><li><p>对成员赋值操作加想要的限制（setXxx方法）</p></li><li><p>避免直接调用成员，瞎赋值（跟第一点类似）</p></li></ul></li><li><p>不对外暴露私有的方法</p></li><li><p>单例模式</p></li></ol><h4 id="P223"><a href="#P223" class="headerlink" title="P223"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=223">P223</a></h4><p>封装所用的4种权限修饰符的范围：</p><ul><li><p>private：同一个类</p></li><li><p>缺省：同一个包：</p></li><li><p>protected：不同包的子类</p></li><li><p>public：同一工程下</p></li></ul><p>修饰类的内部结构（成员，方法，构造器，内部类）：4种都可以</p><p>修饰类：缺省、public</p><h4 id="P227"><a href="#P227" class="headerlink" title="P227"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=227">P227</a></h4><p>构造器的作用：</p><ul><li>创建对象</li><li>初始化对象的信息（成员）</li></ul><p>一旦显示定义构造器，系统不再提供空参构造器（即使参数列表不空）</p><h4 id="P230"><a href="#P230" class="headerlink" title="P230"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=230">P230</a></h4><p>属性赋值的先后顺序</p><ol><li>默认初始化</li><li>显示初始化</li><li>构造器中赋值</li><li>通过对象.方法，对象.属性，赋值</li></ol><h4 id="P231"><a href="#P231" class="headerlink" title="P231"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=231">P231</a></h4><p>默认的空参构造器，权限修饰符跟随类的权限修饰符</p><p>JavaBean的三要素：</p><ul><li>类是公共的</li><li>构造器有一个是无参+公共</li><li>有属性，且对应有get+set方法</li></ul><h4 id="P232"><a href="#P232" class="headerlink" title="P232"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=232">P232</a></h4><p>UML类图</p><p><img src="/2022/07/11/2022-07-11-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC6%E5%A4%A9/image-20220711214953439.png" alt="UML类图"></p><h4 id="P233"><a href="#P233" class="headerlink" title="P233"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=233">P233</a></h4><p>this修饰哪些东西：属性、方法、构造器</p><h3 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h3><blockquote><p>来源：<a href="https://labuladong.github.io/algo">labuladong的算法小抄</a></p></blockquote><h4 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h4><p>最大深度来计算最长路径，不需要-2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        maxDia = <span class="hljs-number">0</span>;<br>        maxDep(root);<br>        <span class="hljs-keyword">return</span> maxDia;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> maxDia;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDep</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> maxLeft = maxDep(root.left);<br>        <span class="hljs-keyword">int</span> maxRight = maxDep(root.right);<br>        <br>        maxDia = Math.max(maxDia, maxLeft+maxRight);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(maxLeft, maxRight);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></h4><ul><li><p>不需要排序</p></li><li><p>最开始记得赋初值，最大值</p></li><li><p>最后的结果要判断是不是初值，是的话变成-1</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">// Arrays.sort(coins);</span><br>        <br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount+<span class="hljs-number">1</span>];<br>        <br>        Arrays.fill(dp, amount+<span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=amount; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> coin : coins)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;=coin)&#123;<br>                    dp[i] = Math.min(dp[i], dp[i-coin] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[amount]==amount+<span class="hljs-number">1</span>?-<span class="hljs-number">1</span>:dp[amount];<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第六天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P233开头，刷题如下：</p><ul><li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p></li><li><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p></li><li><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></p></li><li><p><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></p></li><li><p><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></p></li><li><p><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></p></li><li><p><a href="https://leetcode.cn/problems/gaM7Ch/">剑指 Offer II 103. 最少的硬币数目</a></p></li><li></li></ul><p>早点睡了，明天早点起弄弄</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>霍金《时间简史》</p><p>懂与不懂都是收获</p></blockquote><p>合理</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第5天</title>
    <link href="/2022/07/10/2022-07-10-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC5%E5%A4%A9/"/>
    <url>/2022/07/10/2022-07-10-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC5%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第五天，给爷学</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P191"><a href="#P191" class="headerlink" title="P191"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=191">P191</a></h4><p>快捷键：ctrl + alt + 左右，可以返回跳进来之前的文件指针位置</p><p>文档注释：/**</p><p>可以指针悬停的时候显示信息</p><p>​    </p><h4 id="P196"><a href="#P196" class="headerlink" title="P196"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=196">P196</a></h4><p>关于面试官的心思模拟，很有道理</p><p>面向对象编程的三条主线：</p><ol><li>类及类的成员：成员，方法，构造器，代码块，内部类</li><li>面向对象的三大特征：封装，继承，多态</li><li>其它关键字：this, super, abstract, interface, static, final, package, import</li></ol><p>面试的时候，举例不要猫狗，而是具体的开发例子，比如scanner</p><h4 id="P198"><a href="#P198" class="headerlink" title="P198"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=198">P198</a></h4><p>关于行业的选择，不能只看当下的钱，还得看行业的发展，虽然不一定能够有足够的预见性</p><h4 id="P201"><a href="#P201" class="headerlink" title="P201"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=201">P201</a></h4><p>万事万物皆对象：例如html的前端、数据库，它们到后台处理是，都是封装成一个对象再调用的</p><h4 id="P203"><a href="#P203" class="headerlink" title="P203"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=203">P203</a></h4><p>匿名对象的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Phone().call(); <span class="hljs-comment">//一般没啥意义</span><br><span class="hljs-keyword">new</span> Phone().play(); <span class="hljs-comment">//一般没啥意义</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Phone p)</span></span>&#123;<br>        p.call();<br>        p.play();<br>    &#125;<br>&#125;<br><br>A.show(<span class="hljs-keyword">new</span> Phone()); <span class="hljs-comment">// 这样就减少变量的使用，并且匿名对象能被调用多次</span><br><br></code></pre></td></tr></table></figure><h4 id="P206"><a href="#P206" class="headerlink" title="P206"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=206">P206</a></h4><p>重载：两同一不同</p><ul><li>同一个类</li><li>同名</li><li>参数列表不同</li></ul><p>跟<strong>权限修饰符</strong>，<strong>返回值类型</strong>，<strong>形参变量名</strong>无关</p><h4 id="P209"><a href="#P209" class="headerlink" title="P209"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=209">P209</a></h4><p>可变个数形参：0个也可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br>a.show();<br>a.show(<span class="hljs-number">1</span>);<br>a.show(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ... a)</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，不能跟数组形参同时出现，会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-comment">// 不能共存</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ... a)</span></span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a)</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法和数组一致，并且调用也可以用数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br>a.show(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>a.show(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ... a)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++)&#123;<br>            a[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>可变形参只能有一个，且在末尾</p><p><em>应用场景</em>：sql查询时，占位符？</p><h4 id="P212"><a href="#P212" class="headerlink" title="P212"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=212">P212</a></h4><p>main里面想要调该类的一个非static方法，就要重新实例化一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <br>        show(); <span class="hljs-comment">// 会报错</span><br>        <br>        A a = <span class="hljs-keyword">new</span> A();<br>        a.show(); <span class="hljs-comment">// 正确</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P213"><a href="#P213" class="headerlink" title="P213"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=213">P213</a></h4><p>例题3可以自己画图做一遍</p><h4 id="P214"><a href="#P214" class="headerlink" title="P214"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=214">P214</a></h4><p>第一个拍照的脑筋急转弯，两种方法都可以学一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.exit(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>第二个小坑，打印char数组，println唯独只对char数组进行了重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>System.out.println(a); <span class="hljs-comment">// 结果是：abc，不是地址</span><br></code></pre></td></tr></table></figure><h4 id="P219"><a href="#P219" class="headerlink" title="P219"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=219">P219</a></h4><p>面试题里面，如果让区分两个概念有相同的词，那么大概率没有相同点</p><p>如果是两个名字没啥关系的词，那么肯定是有共性的</p><h4 id="P220"><a href="#P220" class="headerlink" title="P220"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=220">P220</a></h4><p>关于String的更改，比较复杂，因为存储在方法区的字符串常量池中，之后即使要改，也是重新指向一个新的字符串常量池中的空间</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第五天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P221开头，早点睡了，明天早点起弄弄</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>这个世界上有一些错觉是危险的。一种是认为对方是特别的，一种是认为自己是特别的</p></blockquote><p>同样不记得原出处了</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第4天</title>
    <link href="/2022/07/09/2022-07-09-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC4%E5%A4%A9/"/>
    <url>/2022/07/09/2022-07-09-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC4%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第四天，深刻反省，不再浪</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P148"><a href="#P148" class="headerlink" title="P148"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=148">P148</a></h4><p>快捷键小技巧：shirt+回车，换行（不需要光标指到末尾）</p><h4 id="P149"><a href="#P149" class="headerlink" title="P149"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=149">P149</a></h4><p>二维数组的动态初始化，列数可以先不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>][]; <span class="hljs-comment">//也是对的</span><br></code></pre></td></tr></table></figure><p>额外注意</p><ul><li><p>这种方式，之后真正要用的时候，需要再new一下来初始化</p></li><li><p>适用于每行的列数不等时使用</p></li></ul><p>一些写法也是正确的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>][]; <span class="hljs-comment">//也是对的</span><br><span class="hljs-keyword">int</span>[] a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>][]; <span class="hljs-comment">//也是对的</span><br><span class="hljs-keyword">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>][]; <span class="hljs-comment">//也是对的</span><br></code></pre></td></tr></table></figure><p>一些写法还是正确的，但稍微一换就错了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;; <br><span class="hljs-keyword">int</span>[][] a = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;; <span class="hljs-comment">//省略也是对的，叫做类型推断，但是不能分开写</span><br><br><span class="hljs-comment">//错误的</span><br><span class="hljs-keyword">int</span>[][] a;<br>a = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h4 id="P150"><a href="#P150" class="headerlink" title="P150"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=150">P150</a></h4><p>二维数组只指定行数，如果直接调用某个元素<code>arr[0][0]</code>，会报空指针错误（因为内存没有分配具体的地址，找不到对应的地方）</p><p>打印 <code>arr[0]</code> 输出是null</p><h4 id="P152"><a href="#P152" class="headerlink" title="P152"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=152">P152</a></h4><p>打印数组的地址值，格式有规律</p><blockquote><p>例1：[[ I @15DB9742</p><p>[[：二维数组</p><p>I：int型</p><p>@：后面跟具体的地址</p><p>例2：[[ Ljava.lang.String  @15DB9742</p><p>[[：二维数组</p><p>Ljava.lang.String：String类型</p><p>@：后面跟具体的地址</p></blockquote><ul><li>不同类型的引用变量不能相互赋值，比如上面两个例子的地址类型不同，不能乱赋值</li></ul><p>注意，只给了行数没给列数，那么arr[1]打印出来是null，<code>arr[1][1]</code>打印会报空指针错</p><h4 id="P153"><a href="#P153" class="headerlink" title="P153"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=153">P153</a></h4><p>这一节讲的二维数组的内存解析，非常细致，可以再看看，自己默写一遍，点赞</p><h4 id="P154"><a href="#P154" class="headerlink" title="P154"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=154">P154</a></h4><p>java里打印的地址并不是真实地址，而是虚拟机算出来的哈希值，这样的好处是不需要我们来进行移位等操作来算地址，相对简单</p><h4 id="P156"><a href="#P156" class="headerlink" title="P156"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=156">P156</a></h4><p>一些数据结构的基本知识：</p><p>1.数据与数据之间的逻辑关系：集合，一对一，一对多，多对多</p><p>2.数据的存储结构</p><p>线性表：顺序表（数组），链表，栈，队列</p><p>树形结构：二叉树</p><p>图形结构</p><p>一些算法的基本知识：</p><p>排序算法</p><p>搜索算法</p><h4 id="P158"><a href="#P158" class="headerlink" title="P158"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=158">P158</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] x,y[];<span class="hljs-comment">// x是一位数组，y是二维数组</span><br></code></pre></td></tr></table></figure><h4 id="P164"><a href="#P164" class="headerlink" title="P164"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=164">P164</a></h4><p>翻转数组，用双指针更清晰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=arr.length-<span class="hljs-number">1</span>;i&lt;j;i++,j--)&#123;<br>    <span class="hljs-keyword">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P166"><a href="#P166" class="headerlink" title="P166"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=166">P166</a></h4><p>比例查找法：二分法的升级，如果分布相对均匀，那么就不用1/2，而是dest-arr[0]/arr[length-1]-arr[0]的位置</p><h4 id="P167"><a href="#P167" class="headerlink" title="P167"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=167">P167</a></h4><p>排序算法的优劣：</p><ul><li>时间复杂度：关键字的比较次数和记录的移动次数</li><li>空间复杂度：用了多少辅助内存</li><li>稳定性：关键字值相等，是否保留原来的先后次序（应用：销量高到低排序后，再价格低到高排序，如果价格相等，希望原来的销量排序不要变化，后面会再讲）</li></ul><p>排序的分类：</p><ul><li>内部排序（内存里排序即可）</li><li>外部排序（需要额外借助磁盘）</li></ul><p>十大排序算法：</p><ul><li>选择排序<ul><li>直接选择排序</li><li><em>堆排序</em></li></ul></li><li>交换排序<ul><li><strong>冒泡排序</strong></li><li><strong>快速排序</strong></li></ul></li><li>插入排序<ul><li>直接插入排序</li><li>折半插入排序</li><li>shell排序 / 希尔排序</li></ul></li><li><em>归并排序</em></li><li>桶式排序</li><li>基数排序</li></ul><h4 id="P168"><a href="#P168" class="headerlink" title="P168"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=168">P168</a></h4><p>冒泡排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort_sha</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br><br>    <span class="hljs-keyword">int</span> n = nums.length;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j]&gt;nums[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">int</span> tmp = nums[j];<br>                nums[j] = nums[j+<span class="hljs-number">1</span>];<br>                nums[j+<span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P170"><a href="#P170" class="headerlink" title="P170"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=170">P170</a></h4><p>排序算法对比</p><p><img src="/2022/07/09/2022-07-09-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC4%E5%A4%A9/%E4%B8%8D%E5%90%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt="不同排序算法对比"></p><p><img src="/2022/07/09/2022-07-09-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC4%E5%A4%A9/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9.png" alt="排序算法的选择"></p><h4 id="P171"><a href="#P171" class="headerlink" title="P171"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=171">P171</a></h4><p>数组的常用工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">boolean</span> r1 = Arrays.equals(a1, a2);<br>String r2 = Arrays.toString(a1);<br>Arrays.fill(a1, <span class="hljs-number">10</span>);<br>Arrays.sort(a1);<br><span class="hljs-keyword">int</span> index = Arrays.binarySearch(a1, target); <span class="hljs-comment">//(找不到返回一个负数)</span><br></code></pre></td></tr></table></figure><h4 id="P177"><a href="#P177" class="headerlink" title="P177"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=177">P177</a></h4><p>关于面向对象，大象塞冰箱的伪代码非常形象，可以再看看</p><h4 id="P183"><a href="#P183" class="headerlink" title="P183"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=183">P183</a></h4><p>JVM的全貌</p><p><img src="/2022/07/09/2022-07-09-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC4%E5%A4%A9/JVM%E7%BB%93%E6%9E%84.png" alt="JVM结构"></p><h4 id="P184"><a href="#P184" class="headerlink" title="P184"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=184">P184</a></h4><p>属性/成员变量 和 局部变量 的区别：</p><ul><li>位置：<ul><li>属性：类的大括号内定义</li><li>局部变量：方法内，方法的形参，代码块，构造器，构造器的形参</li></ul></li><li>权限修饰符<ul><li>属性：可以用 public、protected、private 等权限修饰符</li><li>局部变量：不可以用权限修饰符</li></ul></li><li>默认初始值<ul><li>属性：有默认初始值</li><li>局部变量：没有默认初始化值，因此用前一定要赋值</li></ul></li><li>内存中加载位置：<ul><li>属性：堆空间（static除外，在方法区）</li><li>局部变量：栈空间</li></ul></li></ul><p>​    </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第四天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P187开头，早点睡了，明天早点起弄弄</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>抬头望窗外，满目清凉</p></blockquote><p>无意间瞟到的，随手一记</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第3天</title>
    <link href="/2022/07/08/2022-07-08-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC3%E5%A4%A9/"/>
    <url>/2022/07/08/2022-07-08-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC3%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第三天，苟住</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P112"><a href="#P112" class="headerlink" title="P112"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=112">P112</a></h4><p>在确定变量肯定被赋值的情况下，才不会编译报错，否则即使目测的代码没有问题，还是会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>    sum = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//这个一定会报错</span><br></code></pre></td></tr></table></figure><h4 id="P116"><a href="#P116" class="headerlink" title="P116"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=116">P116</a></h4><p>do-while 和 while 一旦都执行了至少一次，那么条件相同，执行的次数也相同，不会看起来多1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num1 = <span class="hljs-number">15</span>;<br><span class="hljs-keyword">do</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    num1--;<br>&#125;<span class="hljs-keyword">while</span>(num1&gt;<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">int</span> num2 = <span class="hljs-number">15</span>;<br><span class="hljs-keyword">while</span>(num2&gt;<span class="hljs-number">10</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    num2--;<br>&#125;<br><br><span class="hljs-comment">// 两者执行次数一样多</span><br></code></pre></td></tr></table></figure><h4 id="P125"><a href="#P125" class="headerlink" title="P125"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=125">P125</a></h4><p>跳出外层循环，记得加标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">label:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">5</span>; j++)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">break</span> label;<br>            <span class="hljs-comment">// 或者</span><br>            <span class="hljs-keyword">continue</span> label;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="P128"><a href="#P128" class="headerlink" title="P128"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=128">P128</a></h4><p>同一个文件夹下，好像不需要额外导包，并且直接编译一次就能把另一个也编译好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//A.java</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>B.printHa();<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//B.java</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHa</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;ssss&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>直接编译</p><blockquote><p>javac A.java</p></blockquote><p>就能生成 A.class + B.class</p><h4 id="P133"><a href="#P133" class="headerlink" title="P133"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=133">P133</a></h4><p>switch里，每个case因为可能会穿透，所以要注意重复定义变量问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 下面的写法会报错</span><br><span class="hljs-keyword">switch</span>(x)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="P135"><a href="#P135" class="headerlink" title="P135"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=135">P135</a></h4><p>衡量一个功能代码的优劣：</p><ul><li>正确性</li><li>可读性</li><li>健壮性（错误的输入要能报错提示）</li><li>高效率和低存储（时间和空间复杂度）</li></ul><h4 id="P138"><a href="#P138" class="headerlink" title="P138"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=138">P138</a></h4><p>关于乱码，windows自带的cmd底层是GBK字符集编码，但是eclipse之类的可以自己设置（比如UTF-8），因此如果txt保存成ANSI，移到里面的工程就会显示乱码</p><p>解决方法就是，例如notepad++打开那个文件，有个选项是转成UTF-8</p><h4 id="P139"><a href="#P139" class="headerlink" title="P139"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=139">P139</a></h4><p>文档注释的设置，可以自定义格式，比如这个函数是谁写的，邮箱是多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@Description</span></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@author</span> shkstart Email:shkstart@126.com</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@version</span></span><br><span class="hljs-comment">    * <span class="hljs-doctag">@date</span> $&#123;date&#125;$&#123;time&#125;</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="P140"><a href="#P140" class="headerlink" title="P140"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=140">P140</a></h4><p>数组是引用数据类型，但是数组的元素可以是两种类型中的任意一者</p><h4 id="P141"><a href="#P141" class="headerlink" title="P141"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=141">P141</a></h4><p>数组是引用数据类型，因此初始化要用new</p><p>静态初始化：数组初始化和数组元素的赋值操作在同一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>动态初始化：数组初始化和数组元素的赋值操作分开进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h4 id="P142"><a href="#P142" class="headerlink" title="P142"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=142">P142</a></h4><p>数组索引越界，编译不会报错，但是运行会报错（ide里面的 <code>run</code> 是编译+运行）</p><h4 id="P144"><a href="#P144" class="headerlink" title="P144"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=144">P144</a></h4><p>数组有默认初始化值</p><ul><li>整型：0</li><li>浮点型：0.0</li><li>字符型：0或者说’\u0000’，是空字符而非空格也不是’0’</li><li>布尔型：false</li><li>引用型：null</li></ul><h4 id="P146"><a href="#P146" class="headerlink" title="P146"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=146">P146</a></h4><p>一位数组的内存解析，感觉之后可以默一遍</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第三天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P145开头，晚上9点半就发困了，一天比一天看得少，不得劲</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Ca411W7v9">《我和女朋友，被房贷改变的这三年》</a></p><p>冲动，在一般情况下不是一个好词，但在我的人生里却是一种常态，我是一个冲动的人，我做的所有决定都是下意识的，在我的词典里，成熟，就是给冲动一个冷静期，冷静一段时间再决定，这次要不要冲动</p></blockquote><p>最近关注的up，文笔很好，也对我这种小镇做题家有一定启发</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第2天</title>
    <link href="/2022/07/07/2022-07-07-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC2%E5%A4%A9/"/>
    <url>/2022/07/07/2022-07-07-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC2%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第二天，保持状态，时间不多，冲冲冲</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P69"><a href="#P69" class="headerlink" title="P69"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=69">P69</a></h4><p>goto， const 其实在java里有其他关键字能实现这俩功能，所以估计会被永久雪藏保留</p><h4 id="P72"><a href="#P72" class="headerlink" title="P72"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=72">P72</a></h4><p>负数取模运算，结果的符号和被模数一样</p><blockquote><p>12 % 5 = 2</p><p>-12 % 5 = -2</p><p>12 % -5 = 2</p><p>-12 % -5 = -2</p></blockquote><h4 id="P73"><a href="#P73" class="headerlink" title="P73"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=73">P73</a></h4><p>++ 和 – 能保持数据类型不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">short</span> a = <span class="hljs-number">1</span>;<br>a = a + <span class="hljs-number">1</span>; <span class="hljs-comment">//报错</span><br>a++; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h4 id="P76"><a href="#P76" class="headerlink" title="P76"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=76">P76</a></h4><p>+= 之类的，也能保持数据类型不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">short</span> a = <span class="hljs-number">1</span>;<br>a = a + <span class="hljs-number">1</span>; <span class="hljs-comment">//报错</span><br>a += <span class="hljs-number">1</span>; <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h4 id="P77"><a href="#P77" class="headerlink" title="P77"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=77">P77</a></h4><p>+= 一定不改变数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>a *= <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 不报错，结果为0</span><br></code></pre></td></tr></table></figure><h4 id="P78"><a href="#P78" class="headerlink" title="P78"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=78">P78</a></h4><p>print()赋值操作，打印的是第一个的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>System.out.println(b=a); <span class="hljs-comment">// 先把a的值赋给b，再打印b的值</span><br></code></pre></td></tr></table></figure><h4 id="P80"><a href="#P80" class="headerlink" title="P80"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=80">P80</a></h4><p>&amp;：逻辑与</p><p>&amp;&amp;：短路与</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">false</span> &amp; (b++&gt;<span class="hljs-number">0</span>))&#123;<br>    <br>&#125;<br>System.out.println(b); <span class="hljs-comment">// 输出是1 </span><br><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span> &amp;&amp; (b++&gt;<span class="hljs-number">0</span>))&#123;<br>    <br>&#125;<br>System.out.println(b); <span class="hljs-comment">// 输出是0</span><br></code></pre></td></tr></table></figure><h4 id="P82"><a href="#P82" class="headerlink" title="P82"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=82">P82</a></h4><p>&lt;&lt;：本身不改变值，并且符号位可能会变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>i&lt;&lt;<span class="hljs-number">2</span>; <span class="hljs-comment">//i并不会变</span><br>i&lt;&lt;<span class="hljs-number">30</span>; <span class="hljs-comment">// - 2^31</span><br></code></pre></td></tr></table></figure><p><code>&gt;&gt;&gt;</code>：无符号右移，即最左边无论原来是正还是负，都是补0（平常除法用不到，比如取倒数第5-8位数才用得到 a&gt;&gt;&gt;4, a&amp;15）</p><h4 id="P83"><a href="#P83" class="headerlink" title="P83"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=83">P83</a></h4><p><del>：取反，</del>6 = -7</p><h4 id="P84"><a href="#P84" class="headerlink" title="P84"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=84">P84</a></h4><p>两数交换的骚操作</p><p>a = a^b</p><p>b = a^b</p><p>a = a^b</p><h4 id="P103"><a href="#P103" class="headerlink" title="P103"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=103">P103</a></h4><p>switch只能用以下6种数据类型：</p><blockquote><p>byte，short，int，char，枚举（jdk5.0以后），String（jdk7.0）</p></blockquote><p>并且，default也可以放在最前面，如果default没有break，依然会继续执行</p><ul><li>注意，不写break，一般用于多个类别结果一样或者多个类的结果可以叠加，因此可以省略</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第二天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P111开头，海星，之后再慢慢恢复状态</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>春夏：</p><p>万物都爱我，也恨我不争气</p></blockquote><p>看<a href="https://b23.tv/P52LvVJ">春夏回信陈粒：万物都爱我，也恨我不争气</a>看到的，觉得春夏的文笔贼好</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【归】复习准备秋招第1天</title>
    <link href="/2022/07/06/2022-07-06-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC1%E5%A4%A9/"/>
    <url>/2022/07/06/2022-07-06-%E5%A4%8D%E4%B9%A0%E5%87%86%E5%A4%87%E7%A7%8B%E6%8B%9B%E7%AC%AC1%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>博客荒废了很久，研二下学期一开始，做公司任务+上课+补研发岗知识，就想不到再更博客了，现在准备再重启一下，输入些内容，有机会的话就再整理下博客的东西，毕竟原来的目录设计多少有点冗余</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="Java研发"><a href="#Java研发" class="headerlink" title="Java研发"></a>Java研发</h3><blockquote><p>来源：<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a></p></blockquote><h4 id="P49"><a href="#P49" class="headerlink" title="P49"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=49">P49</a></h4><p>Java中变量声明后未赋值，编译直接报错（C会随机赋值）</p><h4 id="P51"><a href="#P51" class="headerlink" title="P51"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=51">P51</a></h4><p>Java中 long 型变量赋值一定要 L / l 结尾（不写的话可能会报错也可能不会，因为默认为int，如果数在int内，就认为是自动类型转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> a = <span class="hljs-number">1234</span>;<br><span class="hljs-keyword">long</span> b = <span class="hljs-number">9876543210</span>; <span class="hljs-comment">// 会报错，因为比2*31-1(2*10^9大概)大，超出默认的int范围</span><br><span class="hljs-keyword">long</span> c = <span class="hljs-number">9876543210L</span>;<br></code></pre></td></tr></table></figure><h4 id="P52"><a href="#P52" class="headerlink" title="P52"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=52">P52</a></h4><p>Java中 float 型变量赋值一定要 F / f 结尾（不写的话会报错，因为12.3被默认为是double，但是double到float需要强转，但你并没写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> a = <span class="hljs-number">12.3</span>; <span class="hljs-comment">// 会报错，因为默认是double类型，没写强转符括号</span><br></code></pre></td></tr></table></figure><p>float类型已经比long类型的范围更大</p><p>double 比 float 范围更广，精度更高</p><h4 id="P53"><a href="#P53" class="headerlink" title="P53"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=53">P53</a></h4><p>Java 的 char 占两个字节，因此可以赋值中文日文</p><p>三种表示方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-keyword">char</span> b = <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 转义符</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;\u0043&#x27;</span> <span class="hljs-comment">// unicode字符集</span><br></code></pre></td></tr></table></figure><h4 id="P54"><a href="#P54" class="headerlink" title="P54"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=54">P54</a></h4><p>cmd 中出现乱码，其实是因为cmd默认用GBK来解析，而保存txt如果用UTF-8，那就出现了不匹配，解决方法就是把txt用ansi格式保存即可</p><h4 id="P56-57"><a href="#P56-57" class="headerlink" title="P56~57"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=56">P56~57</a></h4><p>自动类型转换，是说表示范围小的类型可以自动转化为标识范围大的类型（非存储空间大）</p><blockquote><p>int -&gt; long -&gt; float -&gt; double</p></blockquote><p>而 byte，short，char 相互运算（包括自己），结果只能用 int 及以上接收。 <code>特别地，char a = &#39;a&#39;; a+1除了int及以上的变量接收，也可以用char接收，很特殊</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">short</span> b = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//错误: char c = a + b;</span><br><span class="hljs-keyword">int</span> c = a + b;<br><span class="hljs-comment">//错误：char c = a + a;</span><br><span class="hljs-keyword">int</span> d = a + a;<br><br><span class="hljs-comment">//....................................................................</span><br><br><span class="hljs-comment">//注意</span><br><span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">char</span> c = a + b; <span class="hljs-comment">//报错</span><br><br><span class="hljs-keyword">char</span> c = a + <span class="hljs-number">1</span>; <span class="hljs-comment">//不报错</span><br><br><span class="hljs-keyword">short</span> d = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">short</span> dd = d - <span class="hljs-number">2</span>; <span class="hljs-comment">// 报错</span><br><br><span class="hljs-comment">//另外注意</span><br><span class="hljs-keyword">char</span> c = a + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> cc = a + <span class="hljs-number">1</span>;<br>System.out.println(c); <span class="hljs-comment">// b</span><br>System.out.println(cc); <span class="hljs-comment">// 98</span><br>System.out.println(<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>+<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 注意，不用类似c的变量来接收a+1，默认是int而不是char，所以是98而非&#x27;b&#x27;</span><br><br><br><span class="hljs-comment">//再注意</span><br><span class="hljs-keyword">char</span> s = <span class="hljs-number">97</span>;<br>System.out.println(s); <span class="hljs-comment">// &#x27;a&#x27;</span><br>System.out.println(s+<span class="hljs-number">1</span>); <span class="hljs-comment">// 98</span><br></code></pre></td></tr></table></figure><p>所以整型也不一定是默认为int</p><h4 id="P58"><a href="#P58" class="headerlink" title="P58"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=58">P58</a></h4><p>强制类型转换，直接截断而非四舍五入</p><h4 id="P61"><a href="#P61" class="headerlink" title="P61"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=61">P61</a></h4><p>String的运算，只有连接符“+”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 97</span><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br>String c = <span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(a+b+c); <span class="hljs-comment">// 答案是：107hello</span><br><br><span class="hljs-comment">//注意：</span><br></code></pre></td></tr></table></figure><p>区别 char 的运算，两个char运算是相加，并且结果存成了int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;*&#x27;</span>; <span class="hljs-comment">// 42</span><br><span class="hljs-keyword">char</span> b = <span class="hljs-string">&#x27;\t&#x27;</span>; <span class="hljs-comment">// 9</span><br>System.out.println(a+b); <span class="hljs-comment">// 答案是：51</span><br></code></pre></td></tr></table></figure><h4 id="P63"><a href="#P63" class="headerlink" title="P63"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=63">P63</a></h4><p>不同进制的赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0b111</span>;<span class="hljs-comment">// 2进制</span><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">111</span>;<span class="hljs-comment">// 10进制</span><br><span class="hljs-keyword">int</span> c = <span class="hljs-number">0111</span>;<span class="hljs-comment">// 8进制</span><br><span class="hljs-keyword">int</span> d = <span class="hljs-number">0x111</span>;<span class="hljs-comment">// 16进制</span><br></code></pre></td></tr></table></figure><h4 id="P67"><a href="#P67" class="headerlink" title="P67"></a><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=67">P67</a></h4><p>代码里的进制转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.toBinaryString(<span class="hljs-number">16</span>); <span class="hljs-comment">// 1000</span><br>Integer.toOctalString(<span class="hljs-number">16</span>); <span class="hljs-comment">// 20</span><br>Integer.toHexString(<span class="hljs-number">16</span>); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恢复状态第一天，看到<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程(在线答疑+Java面试真题)</a> 的 P68开头，海星，之后再慢慢恢复状态</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>悲观是一种远见，乐观是一种智慧</p></blockquote><p>没搜到出自哪里，不过着实很有道理</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day21_魔塔游戏</title>
    <link href="/2022/01/25/2022-01-25-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day21_%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/"/>
    <url>/2022/01/25/2022-01-25-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day21_%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第21天，完结啦~~</p><h1 id="Day21：魔塔游戏"><a href="#Day21：魔塔游戏" class="headerlink" title="Day21：魔塔游戏"></a>Day21：魔塔游戏</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/46">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=174">魔塔游戏</a></p><h3 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/">174. 地下城游戏</a></h3><blockquote><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p><strong>说明:</strong></p><ul><li>骑士的健康点数没有上限。</li><li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>这道题的关键跟上次的最长递增子序列一样，dp的定义不能直接套用题目所问：</p><blockquote><p>这样的定义是不对的：</p><p><code>dp[i][j]</code> ：<code>grid[0][0]</code>到<code>grid[i][j]</code>所需要的最小生命值</p></blockquote><p>如果这样定义，<code>dp[i][j]</code> 是不能从<code>dp[i-1][j]</code> 和<code>dp[i][j-1]</code>来推导出的，信息量不足（仅由最小生命值不够，还应该记录到达此处的当前生命值，但同时这两者不一定同时匹配进而被取用，所以该方法最终放弃）</p><p>但是换个思路，如果将dp反过来定义：</p><blockquote><p>很巧妙的定义方法：</p><p><code>dp[i][j]</code> ：<code>grid[i][j]</code>到<code>grid[m-1][n-1]</code>所需要的最小生命值</p></blockquote><p>当我们起点设为 i, j 后，从后往前推导就不用记录当前的生命值，因为所需要的最小生命值就是当前生命值。思路很巧妙，感觉只有做多了这种套路，才会碰到类似的题目有相关直觉</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>每次计算得到的<code>dp[i][j]</code> ，都要判断是否大于0，小于等于0的时候改为1</p><blockquote><p>因为题目中提到生命值至少是个正数，最小生命值最小为1</p></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] dungeon)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = dungeon.length;<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> n = dungeon[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] = Math.max(<span class="hljs-number">1</span>-dungeon[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m-<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            dp[i][n-<span class="hljs-number">1</span>] = Math.max(dp[i+<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] - dungeon[i][n-<span class="hljs-number">1</span>], <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            dp[m-<span class="hljs-number">1</span>][i] = Math.max(dp[m-<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>] - dungeon[m-<span class="hljs-number">1</span>][i], <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m-<span class="hljs-number">2</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n-<span class="hljs-number">2</span>; j&gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                dp[i][j] = Math.max(Math.min(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>]) - dungeon[i][j], <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// System.out.println(Arrays.deepToString(dp));</span><br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第21天，结束啦，回头看来，2天内打卡的宽容度设计挺好的，总会在某一天临时有事，比如微软笔试那天就没心情做题写题解（前一天总有心情，毕竟没到最后一天都可以浪233）</p><p>整体看出一个习惯的坚持真的很难，因为总有各种各样的情况，比如中间有段时间肠胃炎，整天都没心情做任何事，后来还是强逼着自己做下去，真的完全凭意志力，我的境界还很低，亟待修炼~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>顾城《分别的海》</p><p>我想，到空旷的海上</p><p>只要说，爱你。鱼群就会跟着我，游向陆地</p></blockquote><p>极致的浪漫主义，确实只有天赋异禀的人才能有这样的诗情画意，画面感电影感太足了</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day20_编辑距离</title>
    <link href="/2022/01/24/2022-01-24-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day20_%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/24/2022-01-24-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day20_%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第20天，乌拉~~</p><h1 id="Day20：编辑距离"><a href="#Day20：编辑距离" class="headerlink" title="Day20：编辑距离"></a>Day20：编辑距离</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/45">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=72">编辑距离</a></p><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>dp的定义很容易想到，即word1[0,i]变成word2[0,j]所需的最少步数</p><p>比较难想通的是递推关系：</p><ul><li><p>如果<code>word1[i]</code>==<code>word2[j]</code>，那么<code>dp[i][j]</code>=<code>dp[i-1][j-1]</code></p></li><li><p>如果<code>word1[i]</code>!=<code>word2[j]</code>，那么<code>dp[i][j]</code>取<code>dp[i-1][j-1]</code>，<code>dp[i][j-1]</code>，<code>dp[i-1][j]</code>中的最小值再加1</p></li></ul><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>如果进行空间压缩，可以将复杂度降低到O(min(m, n))。注意如果word2的长度为0时，空间压缩会报错</p><blockquote><p>例如，word1=”b”，word2=””</p></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol><li>不压缩空间复杂度</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n1 = word1.length();<br>        <span class="hljs-keyword">int</span> n2 = word2.length();<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n1+<span class="hljs-number">1</span>][n2+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n1; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n2; i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n1; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n2; j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>)==word2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = Math.min(Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, dp[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>), dp[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n1][n2];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>压缩空间复杂度</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n1 = word1.length();<br>        <span class="hljs-keyword">int</span> n2 = word2.length();<br>        <span class="hljs-keyword">if</span>(n1&gt;n2)&#123;<br>            <span class="hljs-keyword">int</span> tmp = n1;<br>            n1 = n2;<br>            n2 = tmp;<br>            String ss = word1;<br>            word1 = word2;<br>            word2 = ss;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n2+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n2; i++)&#123;<br>            dp[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n1; i++)&#123;<br>            <span class="hljs-keyword">int</span> top_left = i-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> left = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n2; j++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = dp[j];<br>                <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>)==word2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[j] = top_left;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[j] = Math.min(Math.min(top_left+<span class="hljs-number">1</span>, dp[j]+<span class="hljs-number">1</span>), left+<span class="hljs-number">1</span>);<br>                &#125;<br>                top_left = tmp;<br>                left = dp[j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[n2];<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第20天，快接近尾声了，希望能圆满结束</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>S.L.Gray</p><p>我与月亮，进行了一次深夜谈话，它与我谈论太阳，而我与它谈论你</p></blockquote><p>很生动，很含蓄，很静美</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day19_动态规划设计方法</title>
    <link href="/2022/01/23/2022-01-23-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day19_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/23/2022-01-23-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day19_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第19天，芜湖~~</p><h1 id="Day19：动态规划设计方法"><a href="#Day19：动态规划设计方法" class="headerlink" title="Day19：动态规划设计方法"></a>Day19：动态规划设计方法</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/44">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=300">最长递增子序列</a></p><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 2500<br>-104 &lt;= nums[i] &lt;= 104</p><p>进阶：</p><p>你可以设计时间复杂度为 O(n2) 的解决方案吗？<br>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>本题关键是要找到dp数组的定义：dp[i]表示以nums[i]为结尾的最长递增子序列的长度</p><p>在明确dp的定义之后，就自然而然地找到递推关系了：遍历0&lt;j&lt;i，dp[i] = Math.max(dp[i], dp[j]+1)</p><blockquote><p>另外一个patience sorting方法，复杂度O(NlogN)，但不容易想到，具体流程如下：</p><ul><li>遍历数组里的每个数，如果各堆顶的数有比当前数大的，就放在最左边的那个；如果没有，就新建一个堆放上去</li><li>遍历完成后，堆的数量就是答案</li></ul></blockquote><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li><p>对于方法一，dp[i]初始化为1，因为至少本身可以作为一个递增子序列</p></li><li><p>对于方法二，二分查找的框架借用找左边界，while结束后判断left是否超过右边界，超过则表明要新建堆</p></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol><li>方法一，动态规划</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;nums[i])&#123;<br>                    dp[i] = Math.max(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            res = Math.max(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>方法二，patience sorting</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> piles = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] top = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            <br>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> right = piles-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>                <span class="hljs-keyword">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(top[mid]&lt;num)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left&gt;=piles)&#123;<br>                piles++;<br>            &#125;<br>            top[left] = num;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> piles;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第19天，做完微软的笔试了，难度感觉海星，虽然有一题复杂度肯定爆表，但好歹算是都做出来了，毕竟一部分case跑通也是有分的。先告一段落，休整下继续刷题</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p><a href="https://b23.tv/5bjd3R3">【b站网友也太有才华了，我被整破防了！-哔哩哔哩】</a></p><p>南方二月雨夜，天亮了会是春天，我很年轻，所以要穿薄薄的衣服，我要早起，我要充满活力地去呼吸</p></blockquote><p>很有张力，感觉自己现在死气沉沉的，活得很累很麻木，紧赶慢赶地学着工作需要的东西，浑浑噩噩。可能自己要做点自己喜欢的事情，改变一下色调</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day18_动态规划核心原理</title>
    <link href="/2022/01/22/2022-01-22-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day18_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/22/2022-01-22-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day18_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第18天，锅锅哒~~</p><h1 id="Day18：动态规划核心原理"><a href="#Day18：动态规划核心原理" class="headerlink" title="Day18：动态规划核心原理"></a>Day18：动态规划核心原理</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/43">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=322">动态规划核心原理</a></p><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h3><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>基本的动归方法，自底向上，找到递归的关系即可</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>注意n是可以取到0的，所以要在给dp[1]赋值的时候，要先进行判断</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h3><blockquote><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>动归方法，不过这次的递归关系涉及到循环，稍微复杂一些</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ul><li><p>dp数组别忘了初始化，不然0为初值，所有结果都为0（初始化成一个取不到的结果就行）</p></li><li><p>最后返回也要先判断一下，如果是初始化的值，就返回-1即可</p></li></ul><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount+<span class="hljs-number">1</span>];<br>        Arrays.fill(dp, amount+<span class="hljs-number">2</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=amount; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp : coins)&#123;<br>                <span class="hljs-keyword">if</span>(i&lt;tmp)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i] = Math.min(dp[i-tmp] + <span class="hljs-number">1</span>, dp[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[amount]==amount+<span class="hljs-number">2</span>?-<span class="hljs-number">1</span>:dp[amount];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第18天，微软的笔试链接发了，一直犹豫要不要做，后来看群里好像是面试的机会先到先得，所以还是得做。也没啥心思复习，有点焦虑</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《大话数据结构》4.15结尾语</p><p>人生，就像是一个很大的我演变。出生时你赤条条地来到人世，慢慢地长大，渐渐地变老，最终还得赤条条地离开世间。</p><p>人生，又仿佛是一天一天小小的找重现。童年父母每天抱你不断地迸出家门，壮年你每天奔波于家与事业之间，老年你每天独自豌跚于养老院的门里屋前。</p><p>人生，更需妥有进拽出裁精神的体现。在哪里跌倒，就应该在哪里爬起来。无论陷入何等困境，只要抬头古巴仰望蓝天，就有希望，不断进取，你就可以让出头之日重现。困难不会永远存在，强者才能勇往直前。</p><p>人生，其实就是一个大大的队列演变。无知童年、快乐少年，稚傲青年. 成熟中年，安逸晚年。</p><p>人生，又是一个又一个小小的队列重现。春夏秋冬轮回年年， 平中晚夜循环天天。变化的是时间，不变的是你对未来执著的信念。</p><p>人生，更需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90 皮的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。</p></blockquote><p>非常形象，感觉作者的文字功底很强，加上敏锐的观察和认知，绝了</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day17_子集划分问题</title>
    <link href="/2022/01/21/2022-01-21-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day17_%E5%AD%90%E9%9B%86%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/2022-01-21-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day17_%E5%AD%90%E9%9B%86%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第17天，咕噜~~</p><h1 id="Day17：子集划分问题"><a href="#Day17：子集划分问题" class="headerlink" title="Day17：子集划分问题"></a>Day17：子集划分问题</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/42">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=698&target=gitee&_=1642696536440">子集划分问题</a></p><h3 id="698-划分为k个相等的子集"><a href="#698-划分为k个相等的子集" class="headerlink" title="698. 划分为k个相等的子集"></a><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></h3><blockquote><p>给定一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code></li><li><code>0 &lt; nums[i] &lt; 10000</code></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>两种思路：</p><ul><li>数字的视角，即每个数字选桶，每次选择有k个选项，复杂度是O(k^n)</li><li>桶的视角，即每个桶来选数字，每次选择为“是/否”，复杂度是O(k*2^n)</li></ul><p>因此随着n和k的增大，方法二会慢慢优于方法一</p><blockquote><p>方法一没有通过测试，超过时间限制</p></blockquote><p>对于方法二，思路进一步展开：</p><blockquote><p>注意，一个回溯函数里其实有两层循环，最外层是桶的循环，最里层是数组中每个数的循环</p></blockquote><ul><li>回溯函数中，如果k（剩余未安排桶数）为0时，表明成功，返回true</li><li>如果当前bucket值等于target，表明当前桶装好了，装下一个桶</li><li>遍历start开始的每个数，如果当前数没被使用过，并且加上当前数也没有超标，那么加入当前数，进入下一轮回溯</li></ul><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>有几个优化方法：</p><ul><li>计算数组总和，如果总和不能整除k，那么直接返回false</li><li>计算数组最大值，如果最大值大于sum/k，那么直接返回false</li><li>可以先给数组从大到小排序，这样能在递归中最大程度调用剪枝</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol><li>数字选桶</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 主函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 排除一些基本情况</span><br>        <span class="hljs-keyword">if</span> (k &gt; nums.length) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : nums) sum += v;<br>        <span class="hljs-keyword">if</span> (sum % k != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-comment">// k 个桶（集合），记录每个桶装的数字之和</span><br>        <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>        <span class="hljs-comment">// 理论上每个桶（集合）中数字的和</span><br>        <span class="hljs-keyword">int</span> target = sum / k;<br><br>        <span class="hljs-comment">/* 降序排序 nums 数组 */</span><br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-comment">// 交换 nums[i] 和 nums[j]</span><br>            <span class="hljs-keyword">int</span> temp = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = temp;<br>        &#125;<br><br>        <span class="hljs-comment">// 穷举，看看 nums 是否能划分成 k 个和为 target 的子集</span><br>        <span class="hljs-keyword">return</span> backtrack(nums, <span class="hljs-number">0</span>, bucket, target);<br>    &#125;<br><br>    <span class="hljs-comment">// 递归穷举 nums 中的每个数字</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span>[] bucket, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;<br>            <span class="hljs-comment">// 检查所有桶的数字之和是否都是 target</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (bucket[i] != target) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// nums 成功平分成 k 个子集</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 穷举 nums[index] 可能装入的桶</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) &#123;<br>            <span class="hljs-comment">// 剪枝，桶装装满了</span><br>            <span class="hljs-keyword">if</span> (bucket[i] + nums[index] &gt; target) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 将 nums[index] 装入 bucket[i]</span><br>            bucket[i] += nums[index];<br>            <span class="hljs-comment">// 递归穷举下一个数字的选择</span><br>            <span class="hljs-keyword">if</span> (backtrack(nums, index + <span class="hljs-number">1</span>, bucket, target)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 撤销选择</span><br>            bucket[i] -= nums[index];<br>        &#125;<br><br>        <span class="hljs-comment">// nums[index] 装入哪个桶都不行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>桶选数字</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            sum += num;<br>            max = Math.max(max, num);<br>        &#125;<br>        <span class="hljs-keyword">int</span> target = sum/k;<br>        <span class="hljs-keyword">if</span>(sum%k!=<span class="hljs-number">0</span> || max&gt;target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">int</span> tmp = nums[left];<br>            nums[left] = nums[right];<br>            nums[right] = tmp;<br>            left++;<br>            right--;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>        <span class="hljs-keyword">return</span> backtrack(k, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, used, target);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> bucket, <span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">boolean</span>[] used, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bucket==target)&#123;<br>            <span class="hljs-keyword">return</span> backtrack(k-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, used, target);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(bucket+nums[i]&gt;target)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            bucket += nums[i];<br>            used[i] = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span>(backtrack(k, bucket, nums, i+<span class="hljs-number">1</span>, used, target))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            bucket -= nums[i];<br>            used[i] = <span class="hljs-keyword">false</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第17天，今天虽然就一道题，但是做了很久，一个是第一种方法一直超时，优化了很久还是不行；一个是第二个方法一直想自己做出来再看答案，但是两层循环的设计自己始终无法统一在一个回溯函数里，搞了很久</p><p>不过无所谓了，尝试都是有意义的，不能叫浪费时间，毕竟你真正浪费时间的地方，在你玩的时候看视频的时候~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《大话数据结构》3.16结尾语</p><p>五六十年代出生的人，应该也就是我们父母那一辈，当年计划经济制度下，他们的生活被社会安排好了，先科员再科长、后处长再局长，混到哪算哪；学徒、技工、高级技工；教师、中级教师、高级教师，总之无论哪个行业都论资排辈。这样的生活，如何让人奋发努力，所以经济发展缓慢。就像我们的线性表的顺序存储结构一样，位置是排好的，一切都得慢慢来。</p><p>可见，舒适环境是很难培养出坚强品格，被安排好的人生，也很难做出伟大事业。</p><p>市场经济社会下，机会就大多了，你可以从社会的任何一个位置开始起步，只要你真有决心，没有人可以拦着你。事实也证明，无论出身是什么，之前是凄苦还是富足，都有出人头地的一天。当然，这也就意味着，面临的竞争也是空前激烈的，一不小心，你的位置就可能被人插足，甚至你就得 out 出局。这也多像我们线性表的链式存储结构，任何位置都可以插入和删除。</p><p>不怕苦，吃苦半辈子，怕吃苦，吃苦一辈子。如果你觉得上学读书是受罪，假设你可以活到 80 岁，其实你最多也就吃了 20 年苦。用人生四分之一的时间来换取其余时间的幸福生活，这点苦不算啥。再说了，跟着我学习，这也能算是吃苦？</p></blockquote><p>觉得作者对生活的观察也很敏锐，对不同时代的认知判断也很准确。想到我爸妈的很多观点，其实都继承自他们那个时代，早已不能适用于今天，但我并不能很精确地找到问题的关键并进行反驳，不知道是书读的少还是经历不够多</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day16_回溯算法解决排列组合子集问题</title>
    <link href="/2022/01/20/2022-01-20-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day16_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/20/2022-01-20-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day16_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第16天，哗啦~~</p><h1 id="Day16：回溯算法解决排列组合子集问题"><a href="#Day16：回溯算法解决排列组合子集问题" class="headerlink" title="Day16：回溯算法解决排列组合子集问题"></a>Day16：回溯算法解决排列组合子集问题</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/41">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=77">回溯算法解决排列/组合/子集问题</a></p><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><blockquote><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>这个题可以有两种思路：</p><ul><li>一种回溯是按当前的元素是否加入，即每次的选择是“是/否”</li><li>一种回溯是按所有元素遍历，即每次的选择是“第i个元素加入”</li></ul><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>只要思路清晰，应该海星</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol><li>当前的元素是否加入，即每次的选择是“是/否”</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        backtrack(nums, path, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; path, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(index==nums.length)&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 加入当前元素</span><br>        path.addLast(nums[index]);<br>        backtrack(nums, path, index+<span class="hljs-number">1</span>);<br>        path.removeLast();<br><br>        <span class="hljs-comment">// 不加入当前元素</span><br>        backtrack(nums, path, index+<span class="hljs-number">1</span>);<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>所有元素遍历，即每次的选择是“第i个元素加入”</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        backtrack(nums, <span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, LinkedList&lt;Integer&gt; path)</span></span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;n; i++)&#123;<br>            path.addLast(nums[i]);<br>            backtrack(nums, i+<span class="hljs-number">1</span>, path);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>回溯法的基本使用流程：</p><ol><li>主函数里，初始化存出结果变量，路径变量，调用一次回溯函数</li><li>回溯函数里，先判断是否满足终止条件。如果需要先在路径里加入值的话，返回前记得remove（即add和remove无论从哪条路退出，都要次数一致）</li><li>然后循环遍历选择列表，满足条件的话，加入当前值，进入下一层回溯函数，删除当前值</li></ol><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>很久不写，一开始在纠结主函数里要不要先遍历选择加值，其实不用，全部都在回溯函数里完成即可</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <br>        traverse(nums, path);<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, List&lt;Integer&gt; path)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n==path.size())&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!path.contains(num))&#123;<br>                path.add(num);<br>                traverse(nums, path);<br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h3><blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>因为组合也算是集合，所以同78的思路2，可以按所有元素遍历，即每次的选择是“第i个元素加入”</p><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><p>编号是从1开始的，经常会犯的错</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>        res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        backtrack(path, <span class="hljs-number">1</span>, n, k);<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(LinkedList&lt;Integer&gt; path, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size()==k)&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;=n; i++)&#123;<br><br>            path.addLast(i);<br>            backtrack(path, i+<span class="hljs-number">1</span>, n, k);<br>            path.removeLast();<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第16天，继续加油！</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p><a href="https://b23.tv/5bjd3R3">【b站网友也太有才华了，我被整破防了！-哔哩哔哩】</a></p><p>我对你极快地产生了兴趣，就像是石头掉进了池塘，混混沌沌，朦朦胧胧，时间带来了清澈，和沉底的泥</p></blockquote><p>绝了</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day15_回溯算法核心原理</title>
    <link href="/2022/01/19/2022-01-19-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day15_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/19/2022-01-19-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day15_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第15天，嗷呜~~</p><h1 id="Day15：回溯算法核心原理"><a href="#Day15：回溯算法核心原理" class="headerlink" title="Day15：回溯算法核心原理"></a>Day15：回溯算法核心原理</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/40">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=752"><a href="https://labuladong.gitee.io/plugin-v3/?qno=51">回溯算法核心原理</a></a></p><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>回溯法的基本使用流程：</p><ol><li>主函数里，初始化存出结果变量，路径变量，调用一次回溯函数</li><li>回溯函数里，先判断是否满足终止条件。如果需要先在路径里加入值的话，返回前记得remove（即add和remove无论从哪条路退出，都要次数一致）</li><li>然后循环遍历选择列表，满足条件的话，加入当前值，进入下一层回溯函数，删除当前值</li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>很久不写，一开始在纠结主函数里要不要先遍历选择加值，其实不用，全部都在回溯函数里完成即可</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <br>        traverse(nums, path);<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, List&lt;Integer&gt; path)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>(n==path.size())&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!path.contains(num))&#123;<br>                path.add(num);<br>                traverse(nums, path);<br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h3><blockquote><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>回溯的思路没有变化，不过这道题在进入下一层回溯前的判断条件写的东西有点多，要另外再写个函数</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>n这个东西用的比较多，不如加入函数的参数</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>        res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;String&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        traverse(path, <span class="hljs-number">0</span>, n);<br><br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    <br>    List&lt;List&lt;String&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(List&lt;String&gt; path, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(isValid(path, row, i, n))&#123;<br>                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;i; j++)&#123;<br>                    sb.append(<span class="hljs-string">&quot;.&quot;</span>);<br>                &#125;<br>                sb.append(<span class="hljs-string">&quot;Q&quot;</span>);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;n; j++)&#123;<br>                    sb.append(<span class="hljs-string">&quot;.&quot;</span>);<br>                &#125;<br>                path.add(sb.toString());<br><br>                traverse(path, row+<span class="hljs-number">1</span>, n);<br><br>                path.remove(path.size()-<span class="hljs-number">1</span>);<br><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(List&lt;String&gt; path, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;row; i++)&#123;<br>            <span class="hljs-keyword">if</span>(path.get(i).charAt(col)==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = col-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(path.get(i).charAt(j)==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            i--;<br>            j--;<br>        &#125;<br><br>        i = row-<span class="hljs-number">1</span>;<br>        j = col+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(path.get(i).charAt(j)==<span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            i--;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第15天，别人已经放假回家，但我们的战斗还要继续，冲冲冲！</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>错把陈醋当成墨，写尽半生纸上酸<br>更怕醋墨两相掺，半生苦涩半生酸</p></blockquote><p>没找到出处，从一个b站视频下面看到的，写得很有味道</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day14_BFS算法基础</title>
    <link href="/2022/01/18/2022-01-18-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day14_BFS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/18/2022-01-18-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day14_BFS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第14天，嗷呜~~</p><h1 id="Day14：BFS算法基础"><a href="#Day14：BFS算法基础" class="headerlink" title="Day14：BFS算法基础"></a>Day14：BFS算法基础</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/39">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=752">BFS 算法基础</a></p><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><blockquote><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点</p><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>BFS的基本框架，因为需要用到深度信息，所以需要在while循环里加入for循环，进而记录更新深度信息</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>应该木有</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        ArrayDeque&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        q.addLast(root);<br>        <span class="hljs-keyword">int</span> dep = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> n = q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>                TreeNode cur = q.removeFirst();<br>                <span class="hljs-keyword">if</span>(cur.left==<span class="hljs-keyword">null</span> &amp;&amp; cur.right==<span class="hljs-keyword">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> dep;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    q.addLast(cur.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    q.addLast(cur.right);<br>                &#125;<br>            &#125;<br>            dep++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a><a href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a></h3><blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><p>提示：</p><ul><li>1 &lt;= deadends.length &lt;= 500</li><li>deadends[i].length == 4</li><li>target.length == 4</li><li>target 不在 deadends 之中</li><li>target 和 deadends[i] 仅由若干位数字组成</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>需要联想到密码锁的转动，也是一种BFS，但可能成环，所以需要额外的HashSet来记录访问过的节点</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ul><li>对于deadends和visited，可以共用</li><li>Java中更改字符串，转成char[]，再用new String(char[])转回来</li></ul><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> </span>&#123;<br><br>        HashSet visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(String tmp : deadends)&#123;<br>            visited.add(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(visited.contains(<span class="hljs-string">&quot;0000&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target.equals(<span class="hljs-string">&quot;0000&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        visited.add(<span class="hljs-string">&quot;0000&quot;</span>);<br><br>        ArrayDeque&lt;String&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        q.addLast(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-keyword">int</span> dep = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> n = q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br><br>                String cur = q.removeFirst();<br><br>                <span class="hljs-keyword">if</span>(cur.equals(target))&#123;<br>                    <span class="hljs-keyword">return</span> dep;<br>                &#125;<br>                <br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br>                    String up = upp(cur, i);<br>                    <span class="hljs-keyword">if</span>(!visited.contains(up))&#123;<br>                        q.addLast(up);<br>                        visited.add(up);<br>                    &#125;<br>                    String down = downn(cur, i);<br>                    <span class="hljs-keyword">if</span>(!visited.contains(down))&#123;<br>                        q.addLast(down);<br>                        visited.add(down);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>            dep++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upp</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">if</span>(ss[index]==<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            ss[index] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ss[index]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(ss);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">downn</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">if</span>(ss[index]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            ss[index] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ss[index]--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(ss);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第14天，已经过了2/3，继续加油</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>翁彪</p><p>我是使爸妈衰老的诸多事件之一</p><p>职称、房贷、牛肉的价格</p><p>我跻身其中，最为持久</p><p>我是这对中年夫妻唯一相符的病症、共同的疾患</p><p>二十三年来无时不在考验他们的婚姻</p><p>我差不多就是耐性本身</p><p>我是疲惫的侧面、谩骂的间歇</p><p>我是流水中较大的那块石头</p><p>将眼泪分成两份</p></blockquote><p>敏锐，叙事感节奏感抽象感超好，厉害</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day13_二分图判定算法</title>
    <link href="/2022/01/17/2022-01-17-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day13_%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/17/2022-01-17-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day13_%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第13天，开始回血！</p><h1 id="Day13：二分图判定算法"><a href="#Day13：二分图判定算法" class="headerlink" title="Day13：二分图判定算法"></a>Day13：二分图判定算法</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/38">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=785&target=gitee&_=1642389518965">二分图判定算法</a></p><h3 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a></h3><blockquote><p>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：</p><ul><li>不存在自环（graph[u] 不包含 u）。</li><li>不存在平行边（graph[u] 不包含重复值）。</li><li>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）</li><li>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。</li></ul><p>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p><p>如果图是二分图，返回 true ；否则，返回 false 。</p><p>提示：</p><ul><li>graph.length == n</li><li>1 &lt;= n &lt;= 100</li><li>0 &lt;= graph[u].length &lt; n</li><li>0 &lt;= graph[u][i] &lt;= n - 1</li><li>graph[u] 不会包含 u</li><li>graph[u] 的所有值 互不相同</li><li>如果 graph[u] 包含 v，那么 graph[v] 也会包含 u</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>二分图的思路，遍历所有未访问过的节点，再遍历它的周围节点，如果周围节点已经访问过，判断两者是否同色；如果没有访问过，将其染色为反色</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>即使traverse函数返回值为void，也可以通过全局变量的boolean来剪枝，刚进入函数就判断boolean是否为false</li><li>每次进入traverse，直接将当前节点记为访问过</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = graph.length;<br><br>        color = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>        isok = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>                traverse(graph, i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> isok;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span>[] color;<br>    <span class="hljs-keyword">boolean</span>[] visited;<br>    <span class="hljs-keyword">boolean</span> isok;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph, <span class="hljs-keyword">int</span> src)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(!isok)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        visited[src] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next : graph[src])&#123;<br>            <span class="hljs-keyword">if</span>(!visited[next])&#123;<br>                color[next] = !color[src];<br>                traverse(graph, next);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(color[src]==color[next])&#123;<br>                    isok = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="886-可能的二分法"><a href="#886-可能的二分法" class="headerlink" title="886. 可能的二分法"></a><a href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a></h3><blockquote><p>给定一组 N 人（编号为 1, 2, …, N）， 我们想把每个人分进任意大小的两组。</p><p>每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p><p>形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。</p><p>当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。</p><p>提示：</p><ul><li>1 &lt;= N &lt;= 2000</li><li>0 &lt;= dislikes.length &lt;= 10000</li><li>dislikes[i].length == 2</li><li>1 &lt;= dislikes[i][j] &lt;= N</li><li>dislikes[i][0] &lt; dislikes[i][1]</li><li>对于 dislikes[i] == dislikes[j] 不存在 i != j</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>第一步联想到dislike关系就是邻边反色关系，这步很难，难想到以后之后就很简单了，同785即可</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ul><li>本题需要额外将dislike转化成一个graph</li><li>本题编号是从1开始，因此List&lt; Integer &gt;[] graph大小+1，初始化从1开始，travers的遍历从1开始，visited和color的大小+1</li></ul><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">possibleBipartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] dislikes)</span> </span>&#123;<br>        List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> LinkedList[n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            graph[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] tmp : dislikes)&#123;<br>            <span class="hljs-keyword">int</span> src = tmp[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> tar = tmp[<span class="hljs-number">1</span>];<br><br>            graph[src].add(tar);<br>            graph[tar].add(src);<br><br>        &#125;<br><br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>];<br>        color = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>];<br>        ok = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>                traverse(graph, i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ok;<br><br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span>[] visited;<br>    <span class="hljs-keyword">boolean</span>[] color;<br>    <span class="hljs-keyword">boolean</span> ok;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(List&lt;Integer&gt;[] graph, <span class="hljs-keyword">int</span> src)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!ok)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        visited[src] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next : graph[src])&#123;<br>            <span class="hljs-keyword">if</span>(!visited[next])&#123;<br>                color[next] = !color[src];<br>                traverse(graph, next);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(color[src]==color[next])&#123;<br>                    ok = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第13天，慢慢调整恢复状态~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>黄梅戏《女驸马》</p><p>我也曾赴过琼林宴，我也曾打马御街前</p></blockquote><p>查了下，“琼林宴”为皇上为殿试后录取的进士（天子门生）所设。两句歌词的大概意思是：我曾经参加国皇上为新科进士所举行的宴会，我也曾经在皇城的街道上骑马游街。算是人生得意之时的畅快之语</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day12_图论算法基础</title>
    <link href="/2022/01/16/2022-01-16-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day12_%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/16/2022-01-16-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day12_%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第12天，开始回血！</p><h1 id="Day12：图论算法基础"><a href="#Day12：图论算法基础" class="headerlink" title="Day12：图论算法基础"></a>Day12：图论算法基础</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/37">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=797&target=gitee&_=1642288864543">图论算法基础</a></p><h3 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h3><blockquote><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）</p><p>二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。</p><p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p><p>提示：</p><ul><li>n == graph.length</li><li>2 &lt;= n &lt;= 15</li><li>0 &lt;= graph[i][j] &lt; n</li><li>graph[i][j] != i（即，不存在自环）</li><li>graph[i] 中的所有元素 互不相同</li><li>保证输入为 有向无环图（DAG）</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>图论的题目思路类似BFS，但本题更类似于回溯法的变形（其实只用回溯法也是可以做出来的）</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>如果用回溯法，因为回溯法是不记录开头节点，所以需要额外添加头结点到路径中</li><li>如果用图的遍历方法，注意到达终点处的return前，要先remove（或者说只要进入当前的递归，不管从哪个地方return出去，都要path.add和path.remove数量相等）</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol><li>纯回溯版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="hljs-keyword">int</span>[][] graph) &#123;<br>        <span class="hljs-keyword">int</span> n = graph.length;<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        path.addLast(<span class="hljs-number">0</span>);<br>        backtrack(graph, path, n);<br>        <br>        <span class="hljs-keyword">return</span> res;<br><br><br>    &#125;<br><br>    List&lt;List&lt;Integer&gt;&gt; res;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph, LinkedList&lt;Integer&gt; path, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> cur = path.getLast();<br>        <span class="hljs-keyword">if</span>(cur==n-<span class="hljs-number">1</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next : graph[cur])&#123;<br>            path.addLast(next);<br>            backtrack(graph, path, n);<br>            path.removeLast();<br>        &#125;<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>图的遍历版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="hljs-keyword">int</span>[][] graph) &#123;<br>        res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        backtrack(graph, <span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br>    List&lt;List&lt;Integer&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph, <span class="hljs-keyword">int</span> src, LinkedList&lt;Integer&gt; path)</span></span>&#123;<br><br>        path.addLast(src);<br><br>        <span class="hljs-keyword">int</span> n = graph.length;<br>        <span class="hljs-keyword">if</span>(src==n-<span class="hljs-number">1</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            path.removeLast();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next : graph[src])&#123;<br>            backtrack(graph, next, path);<br>        &#125;<br><br>        path.removeLast();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第12天，看完医生，开了些药，向我的肠胃菌开战~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>确认成见 Confirmation Bias</p><p>个人无论合乎事实与否，偏好支持自己的成见、猜想的倾向。人们在脑中选择性地回忆、搜集有利细节，忽略矛盾的信息，并加以片面诠释</p></blockquote><p>挺矛盾的，一方面我们的人性天性，会要求我们用一套逻辑自洽的理论，解释分析身边的世界，不然我们会迷茫无所适从。但当我们真正分析起来，世界的复杂性、我们可收集信息的有限性、认知的狭隘性，最终导致我们找不到一个完美的理论，而在不完美的压迫下为了躲避这种痛苦，我们就会使用了确认成见。所以真正的成长成熟，其实是要我们克服很多痛苦违背些人性</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day11_二叉搜索树基础操作</title>
    <link href="/2022/01/15/2022-01-15-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day11_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/01/15/2022-01-15-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day11_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第11天，爬！</p><h1 id="Day11：二叉搜索树基础操作"><a href="#Day11：二叉搜索树基础操作" class="headerlink" title="Day11：二叉搜索树基础操作"></a>Day11：二叉搜索树基础操作</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/36">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=450">二叉搜索树基础操作</a></p><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p>提示:</p><ul><li>节点数的范围 [0, 104].</li><li>-105 &lt;= Node.val &lt;= 105</li><li>节点值唯一</li><li>root 是合法的二叉搜索树</li><li>-105 &lt;= key &lt;= 105</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>分三类讨论：</p><ul><li>如果要删除节点没有左右子树，那么直接删除即可（返回null）</li><li>如果要删除节点只有一棵子树，那么直接用子树代替即可（返回那棵子树）</li><li>如果要删除节点左右子树都存在，那么找到左子树的最大值或者右子树的最小值节点，进而代替即可（将找到的节点的左右子树分别指向root的左右子树，再返回自己即可）</li></ul><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>对于返回节点类型的递归函数而言，多利用root.left=traverse(root.left)，这样就省去了存储父节点的操作</li><li>对于<code>思路</code>中的情况3，不用管root被替换以后，它的左右子树指针要不要置空，没有必要</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> traverse(root, key);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val&gt;key)&#123;<br>            root.left = traverse(root.left, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val&lt;key)&#123;<br>            root.right = traverse(root.right, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-keyword">null</span> &amp;&amp; root.right!=<span class="hljs-keyword">null</span>)&#123;<br>                TreeNode small = root.right;<br>                <span class="hljs-keyword">while</span>(small.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    small = small.left;<br>                &#125;<br>                root.right = traverse(root.right, small.val);<br>                small.left = root.left;<br>                small.right = root.right;<br>                <span class="hljs-keyword">return</span> small;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> root.right;<br>                &#125;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><p>提示：</p><ul><li>给定的树上的节点数介于 0 和 10^4 之间</li><li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li><li>-10^8 &lt;= val &lt;= 10^8</li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>因为不必保持平衡性，所以可以一直遍历到空节点，插入即可</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>应该木有</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>（1）while找尾结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> traverse(root, val);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val&lt;val)&#123;<br>            root.right = traverse(root.right, val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            root.left = traverse(root.left, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><blockquote><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>慢慢遍历即可</p><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><p>木有</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val&lt;val)&#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><blockquote><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p></blockquote><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>对于子树，要传递3样信息：</p><ul><li>是否为二叉搜索树</li><li>二叉搜索树的最大值</li><li>二叉搜索树的最小值</li></ul><p>可以自上而下，也可以自下而上</p><h5 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h5><p>如果自下而上的话，因为题目中的数值可能出现Integer.MAX_VALUE，所以对于空树置最小值为Integer.MAX_VALUE并不保险，还是老老实实用TreeNode 或者Integer类型的null来分类讨论</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><p>（1）自下而上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Integer[] res = traverse(root);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Integer[] traverse(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>&#125;;<br>        &#125;<br>        Integer[] l = traverse(root.left);<br>        Integer[] r = traverse(root.right);<br>        <span class="hljs-keyword">if</span>(l[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span> || r[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l[<span class="hljs-number">2</span>]!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l[<span class="hljs-number">2</span>]&gt;=root.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r[<span class="hljs-number">1</span>]!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(r[<span class="hljs-number">1</span>]&lt;=root.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>]==<span class="hljs-keyword">null</span>?root.val:l[<span class="hljs-number">1</span>], r[<span class="hljs-number">2</span>]==<span class="hljs-keyword">null</span>?root.val:r[<span class="hljs-number">2</span>]&#125;;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）自上而下+TreeNode版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> traverse(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root, TreeNode min, TreeNode max)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min!=<span class="hljs-keyword">null</span> &amp;&amp; root.val&lt;=min.val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max!=<span class="hljs-keyword">null</span> &amp;&amp; root.val&gt;=max.val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> traverse(root.left, min, root) &amp;&amp; traverse(root.right, root, max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）自上而下+Integer版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> traverse(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root, Integer min, Integer max)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min!=<span class="hljs-keyword">null</span> &amp;&amp; root.val&lt;=min)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max!=<span class="hljs-keyword">null</span> &amp;&amp; root.val&gt;=max)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> traverse(root.left, min, root.val) &amp;&amp; traverse(root.right, root.val, max);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第11天，肚子继续疼，沙哥我继续忍~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1om4y1X7Cx">梁永安《脱单为何那么难？恋爱到底怎么谈？【梁永安爱情问答】》</a></p><p>高质量的孤独，是意识到自己的唯一性，自己的特别性</p></blockquote><p>这句话的情境是在讨论 “我们可不可以一辈子不结婚” 这个话题下讲的，梁老师举了很多名人不结婚的例子，来说明没有婚姻是可以用兴趣来作为一生的依靠（甚至可以说，如果只把婚姻来当做对抗孤独的武器，那肯定是无法得到理想中的婚姻的），进而提及了高质量的孤独。希望自己也能慢慢达到那个境界吧，在自己有了足够坚定的心之所向时，便不惧怕任何世俗所要求的东西了</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day10_二叉树算法入门</title>
    <link href="/2022/01/14/2022-01-14-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day10_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/01/14/2022-01-14-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day10_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第10天，rua！</p><h1 id="Day10：二叉树算法入门"><a href="#Day10：二叉树算法入门" class="headerlink" title="Day10：二叉树算法入门"></a>Day10：二叉树算法入门</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/35">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/plugin-v3/?qno=116&target=gitee">二叉树算法入门</a></p><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><blockquote><p>翻转一棵二叉树。</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>正常操作即可</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>要单独用变量表示root.left或者root.right，类似交换两个变量的值</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> traverse(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode l = traverse(root.left);<br>        TreeNode r = traverse(root.right);<br>        root.left = r;<br>        root.right = l;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><blockquote><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li><li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li></ul><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>对于左子树的尾结点，用while找即可，也可以在traverse里返回两者，但逻辑处理有点复杂，看需求</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>当左节点为空时，啥操作不用做即可，不要多此一举（血的教训233）</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><p>（1）while找尾结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        traverse(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        TreeNode l = traverse(root.left);<br>        TreeNode r = traverse(root.right);<br>        <br>        TreeNode last = root.left;<br>        <span class="hljs-keyword">if</span>(last!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">while</span>(last.right!=<span class="hljs-keyword">null</span>)&#123;<br>                last = last.right;<br>            &#125;<br>            root.left = <span class="hljs-keyword">null</span>;<br>            root.right = l;<br>            last.right = r;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）traverse里返回首尾两节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        traverse(root);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode[] traverse(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode[]&#123;<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span> &amp;&amp; root.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode[]&#123;root, root&#125;;<br>        &#125;<br>        TreeNode[] l = traverse(root.left);<br>        TreeNode[] r = traverse(root.right);<br>        <br>        <span class="hljs-keyword">if</span>(l[<span class="hljs-number">1</span>]!=<span class="hljs-keyword">null</span>)&#123;<br>            root.left = <span class="hljs-keyword">null</span>;<br>            root.right = l[<span class="hljs-number">0</span>];<br>            l[<span class="hljs-number">1</span>].right = r[<span class="hljs-number">0</span>];<br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">if</span>(r[<span class="hljs-number">1</span>]!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode[]&#123;root, r[<span class="hljs-number">1</span>]&#125;;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l[<span class="hljs-number">1</span>]!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode[]&#123;root, l[<span class="hljs-number">1</span>]&#125;;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode[]&#123;root, root&#125;;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><blockquote><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><ul><li><p>你只能使用常量级额外空间。</p></li><li><p>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p></li></ul><p><strong>提示：</strong></p><ul><li>树中节点的数量少于 <code>4096</code></li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>找到左子树的最右侧节点和右子树的最左侧节点，连接即可</p><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><p>木有</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">    public int val;</span><br><span class="hljs-comment">    public Node left;</span><br><span class="hljs-comment">    public Node right;</span><br><span class="hljs-comment">    public Node next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node() &#123;&#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    public Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">        next = _next;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        traverse(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(Node root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        traverse(root.left);<br>        traverse(root.right);<br>        Node l = root.left;<br>        Node r = root.right;<br>        <span class="hljs-keyword">while</span>(l!=<span class="hljs-keyword">null</span>)&#123;<br>            l.next = r;<br>            l = l.right;<br>            r = r.left;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第10天，肚子疼，很难受，隐忍~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>洛莉·摩尔</p><p>好比浣熊进了你家的烟囱，着了火，横冲直撞掉落在客厅里，浑身烧焦，带着火苗疯狂地到处乱窜，直到一命呜呼，恋爱就像那样，全都如此</p></blockquote><p>很西式的比喻，很有情绪力量</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day9_LRU算法设计</title>
    <link href="/2022/01/13/2022-01-13-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day9_LRU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/01/13/2022-01-13-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day9_LRU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第9天，嗷呜！</p><h1 id="Day9：LRU算法设计"><a href="#Day9：LRU算法设计" class="headerlink" title="Day9：LRU算法设计"></a>Day9：LRU算法设计</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/34">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/algo/2/20/45/">如何在数组中以 O(1) 删除元素</a></p><h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h3><blockquote><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li></ul><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 10000</li><li>0 &lt;= value &lt;= 105</li><li>最多调用 2 * 105 次 get 和 put</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol><li>因为要删除最久未使用的元素，所以必然需要有时序关系;</li><li>又因为O(1)时间删除头节点元素，所以只能用链表而非数组；</li><li>因为每次使用要更新当前元素，即涉及到删除指定的元素，所以需要双向链表（找到前驱节点再删除）；</li><li>因为要 O(1) 时间找到元素，所以需要HashMap记录Key和链表节点的对应关系信息；</li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ol><li>因为HashMap删除元素只能通过key，所以在从链表得到头结点时，头结点中需要额外加入key值，而不能只有val</li><li>LinkedHashMap除了Map所具有的各种函数，可以通过keySet().iterator().next()来获得头结点</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>（1）自己构造：双向链表+HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> DoubleLinkedList l;<br>    <span class="hljs-keyword">public</span> HashMap&lt;Integer, Node&gt; m;<br>    <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        l = <span class="hljs-keyword">new</span> DoubleLinkedList();<br>        m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cap = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!m.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span> m.get(key).val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(m.containsKey(key))&#123;<br>            deleteKey(key);<br>            addRecently(key, value);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(cap&lt;=m.size())&#123;<br>                removeLeastUsed();<br>            &#125;<br>            addRecently(key, value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        Node n = m.get(key);<br>        l.remove(n);<br>        l.addLast(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        Node n = <span class="hljs-keyword">new</span> Node(key, val);<br>        m.put(key, n);<br>        l.addLast(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        Node n = m.get(key);<br>        m.remove(key);<br>        l.remove(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeLeastUsed</span><span class="hljs-params">()</span></span>&#123;<br>        Node n = l.removeFirst();<br>        <span class="hljs-keyword">int</span> key = n.key;<br>        m.remove(key);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;<br>    Node pre;<br>    Node next;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleLinkedList</span></span>&#123;<br><br>    Node head;<br>    Node tail;<br>    <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleLinkedList</span><span class="hljs-params">()</span></span>&#123;<br>        head = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        tail = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        x.next = tail;<br>        x.pre = tail.pre;<br>        tail.pre.next = x;<br>        tail.pre = x;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        x.pre.next = x.next;<br>        x.next.pre = x.pre;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.next==tail)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Node first = head.next;<br>        remove(first);<br>        <span class="hljs-comment">// size--;</span><br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>（2）Java自带的LinkedHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br><br>    LinkedHashMap&lt;Integer, Integer&gt; m;<br>    <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        cap = capacity;<br>        m = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!m.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span> m.get(key);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(m.containsKey(key))&#123;<br>            m.put(key, value);<br>            makeRecently(key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(cap&lt;=m.size())&#123;<br>                <span class="hljs-keyword">int</span> old = m.keySet().iterator().next();<br>                m.remove(old);<br>            &#125;<br>            m.put(key, value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> val = m.remove(key);<br>        m.put(key, val);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第9天，今天因为采访一个选调生，所以搞得有点晚，苟住</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Rb4y1e7s4">王中左右《如果王家卫拍火影忍者》</a></p><p>世事无常，那么爱吃甜食的人，最终吃了一辈子的苦</p></blockquote><p>听听妙语，放松下身心</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day8_O1时间返回数组元素</title>
    <link href="/2022/01/12/2022-01-12-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day8_O1%E6%97%B6%E9%97%B4%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/12/2022-01-12-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day8_O1%E6%97%B6%E9%97%B4%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第8天，狗！</p><h1 id="Day8：O-1-时间返回数组元素"><a href="#Day8：O-1-时间返回数组元素" class="headerlink" title="Day8：O(1)时间返回数组元素"></a>Day8：O(1)时间返回数组元素</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/33">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/algo/2/20/61/">如何在数组中以 O(1) 删除元素</a></p><h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">380. O(1) 时间插入、删除和获取随机元素</a></h3><blockquote><p>实现RandomizedSet 类：</p><ul><li>RandomizedSet() 初始化 RandomizedSet 对象</li><li>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。</li><li>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。</li><li>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。<br>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) </li></ul><p>提示：</p><ul><li>-231 &lt;= val &lt;= 231 - 1</li><li>最多调用 insert、remove 和 getRandom 函数 2 * 105 次</li><li>在调用 getRandom 方法时，数据结构中 至少存在一个 元素。</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol><li>因为需要O(1)时间返回集合中的一项，所以必然是数组（利用下表）</li><li>因为需要O(1)时间插入元素，必然是动态数组+插在尾部</li><li>因为需要O(1)时间删除元素，只能将要删除元素交换至尾部删除（不然中间删除需要将后面统一前移）</li><li>因为涉及到交换尾部元素，所以得用Map记录值和索引的对应关系</li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>删除元素时，除了删除数组里的元素，Map也要记得删除</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedSet</span> </span>&#123;<br>    <span class="hljs-comment">// val -&gt; index</span><br>    HashMap&lt;Integer, Integer&gt; m;<br>    ArrayList&lt;Integer&gt; nums;<br>    Random rd;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RandomizedSet</span><span class="hljs-params">()</span> </span>&#123;<br>        m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        nums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        rd = <span class="hljs-keyword">new</span> Random();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(m.containsKey(val))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>        m.put(val, nums.size());<br>        nums.add(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!m.containsKey(val))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> index = m.get(val);<br>        <span class="hljs-keyword">int</span> lastVal = nums.get(nums.size()-<span class="hljs-number">1</span>);<br>        m.put(lastVal, index);<br>        nums.set(index, lastVal);<br>        nums.remove(nums.size()-<span class="hljs-number">1</span>);<br>        m.remove(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums.get(rd.nextInt(nums.size()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RandomizedSet object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RandomizedSet obj = new RandomizedSet();</span><br><span class="hljs-comment"> * boolean param_1 = obj.insert(val);</span><br><span class="hljs-comment"> * boolean param_2 = obj.remove(val);</span><br><span class="hljs-comment"> * int param_3 = obj.getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="710-黑名单中的随机数"><a href="#710-黑名单中的随机数" class="headerlink" title="710. 黑名单中的随机数"></a><a href="https://leetcode-cn.com/problems/random-pick-with-blacklist/">710. 黑名单中的随机数</a></h3><blockquote><p>给定一个包含 [0，n) 中不重复整数的黑名单 blacklist ，写一个函数从 [0, n) 中返回一个不在 blacklist 中的随机整数。</p><p>对它进行优化使其尽量少调用系统方法 Math.random() 。</p><p>提示:</p><ul><li>1 &lt;= n &lt;= 1000000000</li><li>0 &lt;= blacklist.length &lt; min(100000, N)</li><li>[0, n) 不包含 n ，详细参见 interval notation 。</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>因为要少调用random，所以在构造函数里，就要把黑名单的位置映射成白名单的，所以需要添加Map，记录可能抽到的黑名单元素，和白名单元素的对应关系：</p><ol><li><p>定义sz为去除黑名单后的元素数量</p></li><li><p>遍历黑名单的元素</p><ul><li>如果是在[sz, n-1)，就跳过</li><li>如果在[0, sz)，从尾部开始往前找到不在黑名单的元素，Map中加入对应关系</li></ul></li><li><p>调用pick时，如果random出的数在黑名单，就返回Map中的对应元素，否则直接返回就行</p></li></ol><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>先遍历黑名单存到Map里，方便之后判断</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span> sz;<br>    HashMap&lt;Integer, Integer&gt; m;<br>    Random rd = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[] blacklist)</span> </span>&#123;<br>        sz = n-blacklist.length;<br>        m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp : blacklist)&#123;<br>            m.put(tmp, <span class="hljs-number">666</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> last = n-<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> tmp : blacklist)&#123;<br>            <span class="hljs-keyword">if</span>(tmp&gt;=sz)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(m.containsKey(last))&#123;<br>                last--;<br>            &#125;<br>            m.put(tmp, last);<br>            last--;<br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pick</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cur = rd.nextInt(sz);<br>        <span class="hljs-keyword">if</span>(m.containsKey(cur))&#123;<br>            <span class="hljs-keyword">return</span> m.get(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution obj = new Solution(n, blacklist);</span><br><span class="hljs-comment"> * int param_1 = obj.pick();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第8天，最近因为申实习加了一些群，看到群里的大佬们的履历自惭形秽，情绪有点小波动，得赶紧调整回来</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《人与永恒》</p><p>爱情常常把人抽空，留下一具空躯壳，然后扬长而去。所以，聪明人始终对爱情有戒心，三思而后行，甚至于干脆不行</p></blockquote><p>不稳定因素并不为聪明人所喜，相比于相信别人，依靠自己是风险更低的选择，只是过得清苦些罢了</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>O(1)时间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day7_递归翻转链表</title>
    <link href="/2022/01/11/2022-01-11-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day7_%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/11/2022-01-11-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day7_%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第7天，忍！</p><h1 id="Day7：二分搜索"><a href="#Day7：二分搜索" class="headerlink" title="Day7：二分搜索"></a>Day7：二分搜索</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/32">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/algo/2/16/16/">递归反转链表：如何拆解复杂问题</a></p><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h3><blockquote><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>递归反转链表，几步走：</p><ol><li>调用递归，得到子链表翻转后的头结点 last</li><li>子链表的尾结点 head.next，需要指向 head</li><li>head 要指向null</li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>终止条件有两种：head==null || head.next==null</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> traverse(head);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span> || head.next==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode last = traverse(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外附迭代方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode pre = <span class="hljs-keyword">null</span>;<br>        ListNode cur = head;<br>        ListNode nxt = head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;<br>            nxt = nxt.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h3><blockquote><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>206的加强版，但需要额外记录前驱节点，记录流程如下：</p><ol><li><p>left不为1时，递归 head.next 到 left-1</p></li><li><p>left为1时，递归 head.next，几步走：</p><ul><li><p>终止条件 k==1时，记录前驱节点 successor</p></li><li><p>调用递归，得到子链表翻转后的头结点 last</p></li><li><p>子链表的尾结点 head.next，需要指向 head</p></li><li><p>head 要指向 successor</p></li></ul></li></ol><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>reverseAB里，除了调用reverseAB递归以外，需要另外将head指向子链表</p><blockquote><p>head.next = reverseAB(head.next, left-1, right-1);</p></blockquote><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reverseAB(head, left, right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseAB</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">1</span>)&#123;<br>            head.next = reverseAB(head.next, left-<span class="hljs-number">1</span>, right-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> reverseK(head, right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode successor = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseK</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>            successor = head.next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode last = reverseK(head.next, k-<span class="hljs-number">1</span>);<br>        head.next.next = head;<br>        head.next = successor;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>另附迭代方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reverseAB(head, left, right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseAB</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">1</span>)&#123;<br>            head.next = reverseAB(head.next, left-<span class="hljs-number">1</span>, right-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> reverseK(head, right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseK</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        ListNode pre = <span class="hljs-keyword">null</span>;<br>        ListNode cur = head;<br>        ListNode nxt = head;<br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            nxt = nxt.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nxt;<br>            k--;<br>        &#125;<br>        head.next = cur;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第7天，加油~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>马塞尔·普鲁斯特《追忆似水流年》</p><p>任何一样东西，当你渴望拥有它，它就盛开。一旦你拥有它，它就凋谢</p></blockquote><p>呜呜呜，呜呜呜</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>链表</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day6_二分搜索</title>
    <link href="/2022/01/10/2022-01-10-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day6_%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/01/10/2022-01-10-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day6_%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第6天，苟！</p><h1 id="Day6：二分搜索"><a href="#Day6：二分搜索" class="headerlink" title="Day6：二分搜索"></a>Day6：二分搜索</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/31">东哥 Github</a></p><p>专题详解内容：<a href="https://labuladong.gitee.io/algo/1/9/">二分搜索技巧</a></p><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h3><blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>二分搜索的基本用法，暂时自己习惯用下面的风格，就一直沿袭吧：</p><ol><li><p>while(left&lt;=right)，取的是小于等于号</p></li><li><p>每次更新，都是mid+1 / mid-1</p></li><li><p>如果是寻找左右边界，那么在跳出循环之后，要再判断两个例外：</p><blockquote><p>左边界：</p><ul><li>left &gt; nums.length - 1</li><li>nums[left] != target</li></ul><p>右边界：</p><ul><li>right &lt; 0</li><li>nums[right] != target</li></ul></blockquote></li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>这道题木有，找得到的话，循环内部return；找不到的话，循环外return</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><blockquote><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><ul><li>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</li></ul><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 105</li><li>-109 &lt;= nums[i] &lt;= 109</li><li>nums 是一个非递减数组</li><li>-109 &lt;= target &lt;= 109</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>对于二分搜索的所有情况集成，具体而言：</p><ol><li>先找到任意一个目标值，如果没找到，返回[-1, -1]；如果找到了，记录最后一步的left，right，mid</li><li>再从1中的left，right开始，向左找左边界，记录左边界值left1</li><li>再从1中的left，right开始，向右找右边界，记录右边界值right2</li><li>返回left1和right2</li></ol><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>记得先判断第一步能不能找得到任意一个值，找不到的话直接返回</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mid = -<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            mid = left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                right = mid - <span class="hljs-number">1</span>;         <br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(left&gt;right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> left1 = left;<br>        <span class="hljs-keyword">int</span> right1 = right;<br>        <span class="hljs-keyword">int</span> mid1 = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left1&lt;=right1)&#123;<br>            mid1 = left1 + (right1-left1)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid1]&lt;target)&#123;<br>                left1 = mid1 + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right1 = mid1 - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> left2 = left;<br>        <span class="hljs-keyword">int</span> right2 = right;<br>        <span class="hljs-keyword">int</span> mid2 = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left2&lt;=right2)&#123;<br>            mid2 = left2 + (right2-left2)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid2]&gt;target)&#123;<br>                right2 = mid2 - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left2 = mid2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left1, right2&#125;;<br>               <br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第6天，公司任务可能要多花些时间，但还是抽空把每天任务做掉，加油~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>汉娜 · 阿伦特</p><p>当一个人不可诱惑，不可冒犯，不可动摇的时候，他身上就具备了某些迷人的东西</p></blockquote><p>1、3感觉可行，2感觉分寸感不好把握，可能我段位还不够，不过确实总结得好，很敏锐</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day5_滑动窗口</title>
    <link href="/2022/01/09/2022-01-09-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day5_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/01/09/2022-01-09-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day5_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第5天，润！</p><h1 id="Day5：二维数组花式遍历技巧"><a href="#Day5：二维数组花式遍历技巧" class="headerlink" title="Day5：二维数组花式遍历技巧"></a>Day5：二维数组花式遍历技巧</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/30">东哥 Github</a></p><p>专题详解内容：<a href="https://mp.weixin.qq.com/s/ioKXTMZufDECBUwRRp3zaA">滑动窗口技巧</a></p><h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h3><blockquote><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><ul><li><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</p></li><li><p>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p></li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>滑动窗口的基本方法，4个要填充的代码块：</p><ol><li>窗口右边界移动的代码</li><li>窗口左边界移动的代码</li><li>右边界移动变成左边界移动的判定条件</li><li>更新答案的代码</li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>最小长度minlen，初始化的时候要为取不到的s.length()+1，不然对于“a”+“a”的case会报错</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] tt = t.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> tmp : tt)&#123;<br>            need.put(tmp, need.getOrDefault(tmp, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">int</span> n = ss.length;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> minlen = s.length()+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> resl = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> resr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-keyword">char</span> cur = ss[right];<br>            <span class="hljs-keyword">if</span>(need.containsKey(cur))&#123;<br>                window.put(cur, window.getOrDefault(cur, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(need.get(cur).equals(window.get(cur)))&#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            right++;<br>            <br>            <span class="hljs-keyword">while</span>(valid&gt;=need.size())&#123;<br>                <span class="hljs-keyword">if</span>(right-left&lt;minlen)&#123;<br>                    minlen = right - left;<br>                    resl = left;<br>                    resr = right;<br>                &#125;<br>                <br>                cur = ss[left];<br>                <span class="hljs-keyword">if</span>(need.containsKey(cur))&#123;                  <br>                    <span class="hljs-keyword">if</span>(need.get(cur).equals(window.get(cur)))&#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(cur, window.get(cur)-<span class="hljs-number">1</span>);<br>                &#125;<br>                left++;<br>            &#125;       <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> (minlen==s.length()+<span class="hljs-number">1</span>)?<span class="hljs-string">&quot;&quot;</span>:s.substring(resl, resr);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h3><blockquote><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>同76，不过右边界移动变成左边界移动的判定条件可以有多种：</p><ol><li>（同76），窗口内的元素全部包含目标元素</li><li>窗口长度等于目标长度</li></ol><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>判断当前长度和目标长度是否相等时，注意right是++之后的，即right-left就是当前窗口的长度</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <br>        <span class="hljs-keyword">char</span>[] ss1 = s1.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> tmp : ss1)&#123;<br>            need.put(tmp, need.getOrDefault(tmp, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">char</span>[] ss2 = s2.toCharArray();<br>        <span class="hljs-keyword">int</span> n = ss2.length;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-keyword">char</span> cur = ss2[right];<br>            <span class="hljs-keyword">if</span>(need.containsKey(cur))&#123;<br>                window.put(cur, window.getOrDefault(cur, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(need.get(cur).equals(window.get(cur)))&#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            right++;<br>            <br>            <span class="hljs-keyword">while</span>(valid&gt;=need.size())&#123;<br>                <span class="hljs-keyword">if</span>(right-left==s1.length())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>                cur = ss2[left];<br>                <span class="hljs-keyword">if</span>(need.containsKey(cur))&#123;<br>                    <span class="hljs-keyword">if</span>(need.get(cur).equals(window.get(cur)))&#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(cur, window.get(cur)-<span class="hljs-number">1</span>);<br>                &#125;<br>                left++;<br>            &#125;         <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><blockquote><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>同567，只是答案要求输出所有种类，而不是简单的true/false</p><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><p>木有</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <br>        <span class="hljs-keyword">char</span>[] pp = p.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> tmp : pp)&#123;<br>            need.put(tmp, need.getOrDefault(tmp, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">int</span> n = ss.length;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-keyword">char</span> cur = ss[right];<br>            <span class="hljs-keyword">if</span>(need.containsKey(cur))&#123;<br>                window.put(cur, window.getOrDefault(cur, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(window.get(cur).equals(need.get(cur)))&#123;<br>                    valid++;<br>                &#125;<br>            &#125;<br>            right++;<br>            <br>            <span class="hljs-keyword">while</span>(valid&gt;=need.size())&#123;<br>                <span class="hljs-keyword">if</span>(right-left==pp.length)&#123;<br>                    res.add(left);<br>                &#125;<br>                cur = ss[left];<br>                <span class="hljs-keyword">if</span>(need.containsKey(cur))&#123;<br>                    <span class="hljs-keyword">if</span>(window.get(cur).equals(need.get(cur)))&#123;<br>                        valid--;<br>                    &#125;<br>                    window.put(cur, window.get(cur)-<span class="hljs-number">1</span>);<br>                &#125;<br>                left++;          <br>            &#125;         <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><blockquote><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul></blockquote><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>只有一个字符串，因此只需要定义一个HashMap，较之前的题目更为简单。</p><blockquote><p> 更新答案的代码移动至循环最后</p></blockquote><h5 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h5><p>目标是返回最大的长度，因此maxlen初始化为0（可能为空）</p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">char</span>[] ss = s.toCharArray();<br>        <br>        <span class="hljs-keyword">int</span> n = ss.length;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxlen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dup = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-keyword">char</span> cur = ss[right];<br>            window.put(cur, window.getOrDefault(cur, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(window.getOrDefault(cur, <span class="hljs-number">0</span>)==<span class="hljs-number">2</span>)&#123;<br>                dup++;<br>            &#125;<br>            right++;<br>            <br>            <span class="hljs-keyword">while</span>(dup&gt;<span class="hljs-number">0</span>)&#123;<br>                cur = ss[left];                <br>                <span class="hljs-keyword">if</span>(window.getOrDefault(cur, <span class="hljs-number">0</span>)==<span class="hljs-number">2</span>)&#123;<br>                    dup--;<br>                &#125;<br>                window.put(cur, window.get(cur)-<span class="hljs-number">1</span>);<br>                left++;<br>            &#125;<br>        <br>            <span class="hljs-keyword">if</span>(right-left&gt;maxlen)&#123;<br>                maxlen = right - left;<br>            &#125;            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxlen;       <br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第5天，因为之前刷过几遍滑动窗口，整个过程较为顺利，明天加油~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《功夫熊猫》</p><p>Yesterday is history. </p><p>Tomorrow is a mystery. </p><p>But today is a gift.</p><p>That is why it is called present.</p></blockquote><p>一开始看到的是这个句子的中文版，后来才看到英文版，很有味道~~</p><p>结合下罗翔语录食用味道更佳：</p><blockquote><p>古希腊哲学家艾比赫泰德说过：对于不可控的事情，我们要保持乐观和自信；对于可控的事情，我们要保持谨慎和节制。对于不可控的事情，说白了你的焦虑和恐惧于事无补，你焦虑改变不了明天，反而会影响今天的心情；你的恐惧也改变不了明天，因为人生唯一应该恐惧的就是恐惧本身。但是对于可控的事情，能不能好好利用时间，这是可控的，你要谨慎，你要节制，因为如果不谨慎不节制，就会乐极生悲。今天是一个礼物，大家好好把握今天</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day4_二维数组花式遍历技巧</title>
    <link href="/2022/01/08/2022-01-08-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day4_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/01/08/2022-01-08-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day4_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%8A%B1%E5%BC%8F%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第4天，爬！</p><h1 id="Day4：二维数组花式遍历技巧"><a href="#Day4：二维数组花式遍历技巧" class="headerlink" title="Day4：二维数组花式遍历技巧"></a>Day4：二维数组花式遍历技巧</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/29">东哥 Github</a></p><p>专题详解内容：<a href="https://mp.weixin.qq.com/s/8jkzRKLNT-6CnEkvHp0ztA">二维数组花式遍历技巧盘点</a></p><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h3><blockquote><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p>提示：</p><ul><li>matrix.length == n</li><li>matrix[i].length == n</li><li>1 &lt;= n &lt;= 20</li><li>-1000 &lt;= matrix[i][j] &lt;= 1000</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>一些线性代数的处理思路，旋转 = 对角线翻转 + 水平翻转</p><blockquote><p>顺时针旋转 = 主对角线翻转 + 水平翻转</p><p>逆时针旋转 = 副对角线翻转 + 水平翻转</p></blockquote><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>思路对了应该木有</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix.length;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =i+<span class="hljs-number">1</span>; j&lt;n; j++)&#123;<br>                <span class="hljs-keyword">int</span> tmp = matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = tmp;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] tmp : matrix)&#123;<br>            <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> j=n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j&gt;i)&#123;<br>                <span class="hljs-keyword">int</span> t = tmp[i];<br>                tmp[i] = tmp[j];<br>                tmp[j] = t;<br>                i++;<br>                j--;<br>            &#125;<br>        &#125;      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h3><blockquote><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= m, n &lt;= 10</li><li>-100 &lt;= matrix[i][j] &lt;= 100</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>设定上下左右边界，while循环里面 →↓←↑ 一遍</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ol><li>外层循环虽然设定了跳出条件，但是内部的四小循环，还是另外需要设定 if 条件：小循环的固定的行/列，需要存在（eg. 小循环 matrix[left_bound] [i]，那么left_bound&lt;=right_bound）</li></ol><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <br>        <span class="hljs-keyword">int</span> ll = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> rr = n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> bb = m-<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(res.size()&lt;m*n)&#123;<br>            <br>            <span class="hljs-keyword">if</span>(tt&lt;=bb)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=ll; i&lt;=rr; i++)&#123;<br>                    res.add(matrix[tt][i]);<br>                &#125;<br>                tt++;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(ll&lt;=rr)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=tt; i&lt;=bb; i++)&#123;<br>                    res.add(matrix[i][rr]);<br>                &#125;<br>                rr--;                <br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(tt&lt;=bb)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=rr; i&gt;=ll; i--)&#123;<br>                    res.add(matrix[bb][i]);<br>                &#125;<br>                bb--;                <br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(ll&lt;=rr)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=bb; i&gt;=tt; i--)&#123;<br>                    res.add(matrix[i][ll]);<br>                &#125;<br>                ll++;                <br>            &#125;<br>      <br>        &#125;       <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h3><blockquote><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>同54</p><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><ol><li>Math.sqrt(m)，输出的是double类型</li><li>保险起见，同54，内部四小循环也需要加个 if 条件</li></ol><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] generateMatrix(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <br>        <span class="hljs-keyword">int</span> ll=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> rr=n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> bb=n-<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> sum = n*n;<br>        <br>        <span class="hljs-keyword">while</span>(cur&lt;=sum)&#123;<br>            <span class="hljs-keyword">if</span>(cur&lt;=sum)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=ll; i&lt;=rr; i++)&#123;<br>                    res[tt][i] = cur++;<br>                &#125;<br>                tt++;                <br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(cur&lt;=sum)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=tt; i&lt;=bb; i++)&#123;<br>                    res[i][rr] = cur++;<br>                &#125;<br>                rr--;                <br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(cur&lt;=sum)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=rr; i&gt;=ll; i--)&#123;<br>                    res[bb][i] = cur++;<br>                &#125;<br>                bb--;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(cur&lt;=sum)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=bb; i&gt;=tt; i--)&#123;<br>                    res[i][ll] = cur++;<br>                &#125;<br>                ll++;                <br>            &#125;<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第4天，今天题目相对简单点，剩下的日子里，苟住！</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>叔本华</p><p>没有相当程度的孤独，是不可能有内心的平和</p></blockquote><p>很惊艳。但是真正能熬得住孤独的人很少，大部分人只是拿着孤独当幌子，自我感动，陷在里面再也出不来了。要在孤独里，收心，审视，努力，旁观，破圈</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>二维数组遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day3_差分数组</title>
    <link href="/2022/01/07/2022-01-07-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day3_%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/07/2022-01-07-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day3_%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第3天，gogogo！</p><h1 id="Day3：差分数组"><a href="#Day3：差分数组" class="headerlink" title="Day3：差分数组"></a>Day3：差分数组</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/27">东哥 Github</a></p><p>专题详解内容：<a href="https://mp.weixin.qq.com/s/123QujqVn3--gyeZRhxR-A">小而美的算法技巧：差分数组技巧</a></p><h3 id="370-区间加法"><a href="#370-区间加法" class="headerlink" title="370. 区间加法"></a><a href="https://leetcode-cn.com/problems/range-addition/">370. 区间加法</a></h3><blockquote><p>假设你有一个长度为n的数组，初始情况下所有的数字均为0，你将会被给出 k个更新的操作。</p><p>其中，每个操作会被表示为一个三元组:[startIndex, endIndex, inc]，你需要将子数<br>组A<a href="%E5%8C%85%E6%8B%ACstartlndex%E5%92%8CendIndex">startlndex … endIndex</a>增加inc。</p><p>请你返回k次操作后的数组。</p></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>差分数组的基本使用</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p>木有</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] getModifiedArray(<span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span>[][] updates) &#123;<br>    Difference df = <span class="hljs-keyword">new</span> Diference(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] tmp : updates)&#123;<br>        <span class="hljs-keyword">int</span> left = tmp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> right = tmp[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> val = tmp[<span class="hljs-number">2</span>];<br>        df.increment(left, right, val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> df.result();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Difference</span></span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] diff;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Difference</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            diff[i] = nums[i] - nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        diff[left] += val;<br>        <span class="hljs-keyword">if</span>(right+<span class="hljs-number">1</span>&lt;diff.length)&#123;<br>            diff[right+<span class="hljs-number">1</span>] -= val;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] result()&#123;<br>        <span class="hljs-keyword">int</span> n = diff.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            res[i] = res[i-<span class="hljs-number">1</span>] + diff[i]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h3><blockquote><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p>提示：</p><ul><li>1 &lt;= n &lt;= 2 * 104</li><li>1 &lt;= bookings.length &lt;= 2 * 104</li><li>bookings[i].length == 3</li><li>1 &lt;= firsti &lt;= lasti &lt;= n</li><li>1 &lt;= seatsi &lt;= 104</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>差分数组的应用题</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ol><li>注意题目中航班是从1算起，所以每次进行increment操作时，left/right都要先 - 1</li><li>题目中提到右侧last也是包含的，所以不用额外-1操作</li></ol><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] corpFlightBookings(<span class="hljs-keyword">int</span>[][] bookings, <span class="hljs-keyword">int</span> n) &#123;<br>        Difference df = <span class="hljs-keyword">new</span> Difference(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] tmp : bookings)&#123;<br>            <span class="hljs-keyword">int</span> left = tmp[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> right = tmp[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> val = tmp[<span class="hljs-number">2</span>];<br>            df.increment(left, right, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> df.result();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Difference</span></span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] diff;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Difference</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            diff[i] = nums[i] - nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        diff[left] += val;<br>        <span class="hljs-keyword">if</span>(right+<span class="hljs-number">1</span>&lt;diff.length)&#123;<br>            diff[right+<span class="hljs-number">1</span>] -= val;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] result()&#123;<br>        <span class="hljs-keyword">int</span> n = diff.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            res[i] = res[i-<span class="hljs-number">1</span>] + diff[i]; <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1094-拼车"><a href="#1094-拼车" class="headerlink" title="1094. 拼车"></a><a href="https://leetcode-cn.com/problems/car-pooling/">1094. 拼车</a></h3><blockquote><p>假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。</p><p>这儿有一份乘客行程计划表 trips[][]，其中 trips[i] = [num_passengers, start_location, end_location] 包含了第 i 组乘客的行程信息：</p><p>必须接送的乘客数量；<br>乘客的上车地点；<br>以及乘客的下车地点。<br>这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。</p><p>请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false）</p><p>提示：</p><ul><li>你可以假设乘客会自觉遵守 “先下后上” 的良好素质</li><li>trips.length &lt;= 1000</li><li>trips[i].length == 3</li><li>1 &lt;= trips[i][0] &lt;= 100</li><li>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</li><li>1 &lt;= capacity &lt;= 100000</li></ul></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>差分数组的应用题，转化下题目意思，即车子所有时刻的人数数组，最大值会不会超过capacity</p><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><ol><li>题目没有提及右侧区间包含，因此在调用increment时，right需要-1（毕竟站点都是先下车一波人，再上车一波人，所以在right站点要减掉一波人）</li></ol><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">carPooling</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] trips, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        Difference df = <span class="hljs-keyword">new</span> Difference(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1001</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] tmp : trips)&#123;<br>            <span class="hljs-keyword">int</span> left = tmp[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> right = tmp[<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> val = tmp[<span class="hljs-number">0</span>];<br>            df.increment(left, right, val);<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] res = df.result();<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : res)&#123;<br>            max = Math.max(max, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max&lt;=capacity;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Difference</span></span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] diff;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Difference</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            diff[i] = nums[i] - nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        diff[left] += val;<br>        <span class="hljs-keyword">if</span>(right+<span class="hljs-number">1</span>&lt;diff.length)&#123;<br>            diff[right+<span class="hljs-number">1</span>] -= val;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] result()&#123;<br>        <span class="hljs-keyword">int</span> n = diff.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>            res[i] = res[i-<span class="hljs-number">1</span>] + diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第3天，今天题目风格较为统一，思路和注意点都比较少，所以写得也比较快，坚持！</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>王中左右的视频<a href="https://www.bilibili.com/video/BV1fZ4y1U7Bx">《如果王家卫做春晚总导演》</a></p><p>听人说过，四十不惑，三十而已，而三十多岁的我，卡在了中间，困惑不已</p></blockquote><p>王家卫区up，虽然每次风格都很固定，但在同一风格下创造出很多金句，本身的文字功底很强，而且之前有一期孙悟空林黛玉混剪，编剧功力也不错，敲代码累了看看很享受</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day2_前缀和</title>
    <link href="/2022/01/06/2022-01-06-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day2_%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2022/01/06/2022-01-06-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day2_%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>东哥的21天算法挑战，第2天，冲！</p><h1 id="Day2：前缀和"><a href="#Day2：前缀和" class="headerlink" title="Day2：前缀和"></a>Day2：前缀和</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/26">东哥 Github</a></p><p>专题详解内容：<a href="https://mp.weixin.qq.com/s/EwAH3JDs5WFO6-LFmI3-2Q">小而美的算法技巧：前缀和数组</a></p><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3><blockquote><p>给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p><p>实现 NumArray 类：</p><ul><li>NumArray(int[] nums) 使用数组 nums 初始化对象</li><li>int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）</li></ul><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 104</li><li>-105 &lt;= nums[i] &lt;= 105</li><li>0 &lt;= i &lt;= j &lt; nums.length</li><li>最多调用 104 次 sumRange 方法</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>前缀和的基本使用，构造preSum来避免O(n^2)的复杂度</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ol><li>preSum的大小要+1，多了个base case：preSum[0]=0</li><li>最终输出的时候，右边界要+1</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] preSum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// preSum[0] = 0;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            sum += nums[i-<span class="hljs-number">1</span>];<br>            preSum[i] = sum;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> preSum[right+<span class="hljs-number">1</span>]-preSum[left];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h3><blockquote><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p><ul><li>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。</li></ul><p>实现 NumMatrix 类：</p><ul><li>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化</li><li>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。</li></ul><p><strong>提示：</strong></p><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= m, n &lt;= 200</li><li>-105 &lt;= matrix[i][j] &lt;= 105</li><li>0 &lt;= row1 &lt;= row2 &lt; m</li><li>0 &lt;= col1 &lt;= col2 &lt; n</li><li>最多调用 104 次 sumRegion 方法</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>前缀和的二维版本，初始化preSum和最后输出都会稍微复杂点</p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ol><li><p>同样preSum的大小要+1，多了个base case：preSum[0] [0] = 0;</p></li><li><p>初始化的操作：preSum[i] [j] = preSum[i-1] [j] + preSum[i] [j-1] + matrix[i-1] [j-1] - preSum[i-1] [j-1];</p><blockquote><p>注意：</p><p>matrix[i-1] [j-1] 普遍要比 preSum[i] [j]的序号要-1</p></blockquote></li><li><p>最后输出的操作：return preSum[row2+1] [co2+1] + preSum[row1] [col1] - preSum[row2+1] [col1]  - preSum[row1] [col2+1];</p><blockquote><p>注意：</p><p>大的边界row2/col2是要+1的，小的row1/col1是不需要的</p></blockquote></li></ol><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumMatrix</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">int</span>[][] preSum;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NumMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>                preSum[i][j] = preSum[i-<span class="hljs-number">1</span>][j]+preSum[i][j-<span class="hljs-number">1</span>]+matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]-preSum[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row1, <span class="hljs-keyword">int</span> col1, <span class="hljs-keyword">int</span> row2, <span class="hljs-keyword">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> preSum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]+preSum[row1][col1]-preSum[row1][col2+<span class="hljs-number">1</span>]-preSum[row2+<span class="hljs-number">1</span>][col1];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h3><blockquote><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 2 * 104</li><li>-1000 &lt;= nums[i] &lt;= 1000</li><li>-107 &lt;= k &lt;= 107</li></ul></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>使用前缀和后，最直觉的思路还是双层循环，但可以借助HashMap来记录sum为x的个数，这样就能减掉一层循环</p><p>综上，流程如下：</p><ol><li>初始化HashMap&lt;Integer, Integer&gt;，存一个(0,1)，这样如果左边界为0的sum就能res+1了</li><li>进入循环，每次先（1）计算当前的sum；（2）然后减去目标k，得到的target，去HashMap里取值，加入到res里；（3）将当前的sum也加入到HashMap中</li><li>最终返回res</li></ol><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><ol><li><p>更新当前的sum到HashMap中时，要在(2)之后进行，不然答案会多加（对比双循环，双循环内部 j&lt;i，所以当前的sum不能先更新到哈希表中）</p><blockquote><p>例如：数组为{1}，k=0，显然最后的结果 res=0</p><p>那么进入循环，sum=1，然后将sum加入到HashMap中（目前HashMap中有(0,1)和(1,1)），计算 target = sum - k = 1，那么查询HashMap就会res+1了</p></blockquote></li><li><p>可以优化掉前缀和数组，因为循环每一轮得到的东西都会记录在HashMap中，所以没必要保留数组</p></li></ol><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; m = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        m.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>            sum += nums[i-<span class="hljs-number">1</span>];<br>            <br>            <span class="hljs-keyword">int</span> target = sum - k;<br>            <span class="hljs-keyword">if</span>(m.containsKey(target))&#123;<br>                res += m.get(target);<br>            &#125;<br>            <br>            m.put(sum, m.getOrDefault(sum, <span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战第2天，学文章+做题+写总结，还是花了快2个小时（虽然只有3题），不过这个过程还是必要的，即使不一定能加深理解，但是至少能记录些我的一些手误点和思考积疾，坚持住~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>王村村的视频<a href="https://www.bilibili.com/video/BV1c34y1z7Pu">《中年男性的独居生活01（浪漫主义无聊）》</a></p><p>有一天我睡觉的时候，听到蚊子在我耳边噪响，我从被子里面伸手，扇自己耳朵，过了一会儿明显感觉到这个蚊子飞进了我的被窝，我拼命裹紧被子，在床上打滚，早上起来，床上有一小撮干了的血渍，后来我把那块带了血渍的床单裁了下来，做了个框，然后写了这么一句话，我说：我与生活搏斗过，那摊血，应该是我的，但流血的，不是我</p></blockquote><p>最近关注的一个up，这段很有感觉就抄下来了，希望多年以后自己的中年生活，也能在破碎中觅得诗意聊以慰藉</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【冲】labuladong的21天算法挑战Day1_链表基操</title>
    <link href="/2022/01/05/2022-01-05-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day1_%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%93%8D/"/>
    <url>/2022/01/05/2022-01-05-labuladong%E7%9A%8421%E5%A4%A9%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98Day1_%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%93%8D/</url>
    
    <content type="html"><![CDATA[<p>参加了labuladong东哥的21天算法挑战，交了300元押金，为了把钱拿回来，冲冲冲！</p><h1 id="Day1：单链表解题技巧"><a href="#Day1：单链表解题技巧" class="headerlink" title="Day1：单链表解题技巧"></a>Day1：单链表解题技巧</h1><p>打卡地：<a href="https://github.com/labuladong/challenge/issues/25">东哥 Github</a></p><p>专题详解内容：<a href="https://mp.weixin.qq.com/s/dVqXEMKZ6_tuB7J-leLmtg">单链表的六大解题套路，你都见过么？</a></p><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul></blockquote><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol><li>设定双指针分别指向两个链表头结点</li><li>另外设定指针指向要返回的结果链表</li><li>循环比较两个指针值的大小，将结果链表的指针指向较小值的指针，并将较小值指针向前移动</li><li>结果指针也向前移动</li></ol><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ol><li>设计哑节点，代码更简洁（最后返回dum.next，这样不用纠结是链表1的头还是链表2的头）</li><li>当一个链表为空时，直接将当前链表连到剩下没空的链表即可</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;<br>ListNode dum = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode cur = dum;<br>        <span class="hljs-keyword">while</span>(list1!=<span class="hljs-keyword">null</span> &amp;&amp; list2!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list1.val&gt;list2.val)&#123;<br>                cur.next = list2;<br>                list2 = list2.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur.next = list1;<br>                list1 = list1.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1==<span class="hljs-keyword">null</span>)&#123;<br>            cur.next = list2;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur.next = list1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><blockquote><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>提示：</strong></p><ul><li>k == lists.length</li><li>0 &lt;= k &lt;= 10^4</li><li>0 &lt;= lists[i].length &lt;= 500</li><li>-10^4 &lt;= lists[i][j] &lt;= 10^4</li><li>lists[i] 按 升序 排列</li><li>lists[i].length 的总和不超过 10^4</li></ul></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>类似 Leetcode21，同样比较多个指针所在链表的值，将结果链表指针指向最小值所在链表，自身再前进</p><p>但是多个链表指针如何最高效比较大小，要借助优先级队列，复杂度为O(logK)，K为队列长度（在本题中即为链表个数k），整体复杂度即为O(NlogK)，其中N为所有节点个数</p><p>综上流程步骤为：</p><ol><li>将k个链表头结点存入优先级队列中</li><li>每次取出队列头结点（即为当前所有链表的最小值节点），将结果链表指针指向该节点，自身再前进</li><li>重复以上步骤，直至优先级队列为空</li></ol><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><ol><li>优先级队列中定义大小的比较时，都用Integer/Double.compare(a, b)，封装类的比较函数会帮你处理边界问题（当然此题不会出现越界行为，仅是提醒）</li><li>边界case会有：**[[]]**，因此初始化优先级队列时，注意判断节点是否为null，不为null再加入优先级队列</li><li>同样因为边界case：**[[]]**，更新优先级队列内容时，也要先判断节点是否为null，不为null再加入优先级队列</li></ol><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>ListNode dum = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        PriorityQueue&lt;ListNode&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> Integer.compare(o1.val, o2.val);<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(ListNode l : lists)&#123;<br>            <span class="hljs-keyword">if</span>(l!=<span class="hljs-keyword">null</span>)&#123;<br>                q.offer(l);<br>            &#125;<br>        &#125;<br>        ListNode cur = dum;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            ListNode tmp = q.poll();<br>            cur.next = tmp;<br>            cur = cur.next;<br>            <span class="hljs-keyword">if</span>(tmp.next!=<span class="hljs-keyword">null</span>)&#123;<br>                q.offer(tmp.next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h3><blockquote><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul></blockquote><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>设定快慢指针，快指针每次走两步，慢指针每次走一步，当链表成环则双指针迟早相遇，不成环的话则快指针最终走到尽头。</p><p>综上，流程如下：</p><ol><li>设定快慢指针都指向头结点</li><li>每次快指针走两步，慢指针走一步，判断两指针是否相等，相等则返回true</li><li>当快指针走到尽头退出循环，返回false</li></ol><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h5><ol><li>循环条件是快指针当前非null，并且&amp;&amp;，当前快指针的next也非null</li><li>内部break是快慢指针是否相等</li></ol><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode slow = head;<br>        ListNode fast = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-keyword">null</span> &amp;&amp; fast.next!=<span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span>(fast==slow)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul></blockquote><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>类似 Leetcode141，在快慢指针相遇时，再将快指针拨回头结点，双指针都每次前进一步，它们就会在入环点相遇</p><ol><li>（同Leetcode141）</li><li>快指针重新设定为链表头结点，快慢指针同时前进，每次一步</li><li>重复上述步骤，直至两者再次相遇，相遇点即为入环点</li></ol><p>证明：</p><h5 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h5><ol><li>（个人手欠错误），fast指针老是多打一个next：fast.next.next != null</li></ol><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-keyword">null</span> &amp;&amp; fast.next!=<span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast==slow)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast==<span class="hljs-keyword">null</span> || fast.next==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        fast = head;<br>        <span class="hljs-keyword">while</span>(fast!=slow)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h3><blockquote><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul></blockquote><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>快慢指针的基本操作，快指针前进两步，慢指针前进一步</p><h5 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a>注意点</h5><p>还是那个个人手欠错误，fast指针别多打一个next：</p><ol><li>fast.next.next != null</li><li>fast = fast.next.next.next;</li></ol><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>ListNode slow = head;<br>        ListNode fast = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-keyword">null</span> &amp;&amp; fast.next!=<span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li><li>listA - 第一个链表</li><li>listB - 第二个链表</li><li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li><li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p>提示：</p><ul><li>listA 中节点数目为 m</li><li>listB 中节点数目为 n</li><li>1 &lt;= m, n &lt;= 3 * 104</li><li>1 &lt;= Node.val &lt;= 105</li><li>0 &lt;= skipA &lt;= m</li><li>0 &lt;= skipB &lt;= n</li><li>如果 listA 和 listB 没有交点，intersectVal 为 0</li><li>如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</li></ul><p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p></blockquote><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>双指针分别指向两个链表，每次前进一步，当指针到达链表末尾，移动到另一个链表的头结点。这样两者的前进路径长度正好相等，如果链表相交就正好同时到达相交节点，如果不想交，如果不相交就同时到达null</p><h5 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a>注意点</h5><ol><li>来自东哥巧妙的设计，循环的判定条件为快慢指针不相等，因为不管相不相交，最终都会跳出循环（快慢指针要么都指向同一节点，要么都指向null，null也是相等）</li><li>循环内部，l1==null的情况只会进入一次，因为第二次进入前，while本身判断条件会先卡住退出</li></ol><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        ListNode l1 = headA;<br>        ListNode l2 = headB;<br>        <span class="hljs-keyword">while</span>(l1!=l2)&#123;<br>            <span class="hljs-keyword">if</span>(l1!=<span class="hljs-keyword">null</span>)&#123;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l1 = headB;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2!=<span class="hljs-keyword">null</span>)&#123;<br>                l2 = l2.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l2 = headA;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>利用快慢指针，快慢指针都从头结点出发，快指针先走N步，然后快慢指针同时前进，每次前进一步，当快指针到达末尾时，慢指针正好到达倒数第N个节点</p><p>对于删除节点，需要第N+1个节点来修改跳过下一个指针，因此额外设定哑结点，并且快指针多走N+1步，这样就能到达倒数第N+1个节点</p><p>综上，流程如下：</p><ol><li>设定哑结点，哑结点的下个节点指向头结点</li><li>快指针起点设为哑结点，先移动N+1步</li><li>慢指针起点设为哑结点，快慢指针同时前进，每次前进一步</li><li>当快指针到达null时，慢指针正好到达倒数第N+1个节点</li><li>将慢指针跳过下个节点即可</li><li>返回哑结点的下个节点</li></ol><h5 id="注意点-6"><a href="#注意点-6" class="headerlink" title="注意点"></a>注意点</h5><ol><li>设定哑结点，防止删除节点为头结点</li><li>对于删除操作，基本都要达到目标节点的上个节点，所以快指针先走N+1步，而不是第N步</li></ol><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>ListNode dum = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        dum.next = head;<br>        ListNode fast = dum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n+<span class="hljs-number">1</span>; i++)&#123;<br>            fast = fast.next;<br>        &#125;<br>        ListNode slow = dum;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next;<br>            slow = slow.next;<br>        &#125;<br>        slow.next = slow.next.next;<br>        <span class="hljs-keyword">return</span> dum.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>21天挑战，第一天写完所有题解花了2个多小时，很累，感觉全部写完工程量确实有点大，之后考虑当天先写一个题解，之后慢慢补</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《卡萨布兰卡》</p><p>「你如今的气质里，藏着你走过的路，读过的书和热爱的人。」</p></blockquote><p>精简得好，路和书很明显，而对于人，不仅是你原生家庭的爱恨，还有恋人在你身上留下的痕迹，难呀~~</p>]]></content>
    
    
    <categories>
      
      <category>程序缘的内功修炼</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>labuladong</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【唔】2022新年已至</title>
    <link href="/2022/01/01/2022-01-01-2022%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%87%B3/"/>
    <url>/2022/01/01/2022-01-01-2022%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%87%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2021已经过去，2022已经来临</p><p>在这看似仪式满满的时间点，其实也没有太大必要伤春悲秋，怒立旗帜（flag）~~</p><p>让我来记下些许小事，解构些隆重，冲淡些氛围</p><p>毕竟，每一天都是平等的，不能厚此薄彼，他们都是365分子中的一个呀</p></blockquote><h1 id="一只猫"><a href="#一只猫" class="headerlink" title="一只猫"></a>一只猫</h1><p>2021年的最后一天，本来是要在实验室写周报的，但是实验室的学长学姐可能要腻歪会儿，为了给他们创造些私人空间，我就回宿舍了</p><p>路上，看到一只猫，坐在老树根旁，跟我些许有些像，于是停下来和他唠会儿磕，他说他的猫语，我说我的人话</p><p><img src="/2022/01/01/2022-01-01-2022%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%87%B3/%E7%8C%AB1.jpg" alt="猫1"></p><p>在掏出手机给他拍拍照留作新年礼物时，他倒挺心大，径直走到我脚旁坐下来，可能以为我也是个老树根吧，毕竟我不说猫话</p><p><img src="/2022/01/01/2022-01-01-2022%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%87%B3/%E7%8C%AB2.jpg" alt="猫2"></p><p><img src="/2022/01/01/2022-01-01-2022%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%87%B3/%E7%8C%AB3.jpg" alt="猫3"></p><p>在我脚边坐了会儿，挠了会儿痒，之后又自顾自地走了，对我也不留念，挺潇洒，既可以跟你亲近，又表现出不寄人篱下的骨气，猫中豪杰，respect！</p><p><img src="/2022/01/01/2022-01-01-2022%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%87%B3/%E7%8C%AB4.jpg" alt="猫4"></p><p>看着猫哥在一旁舔自己，跟竹林隐士一般如入无人之境，而且这是隐于市的大隐境界，不得不肃然起敬</p><p><img src="/2022/01/01/2022-01-01-2022%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%87%B3/%E7%8C%AB5.jpg" alt="猫5"></p><blockquote><p>他不留恋周围闲人，我也自不必留恋</p></blockquote><h1 id="往前走，莫回头"><a href="#往前走，莫回头" class="headerlink" title="往前走，莫回头"></a>往前走，莫回头</h1>]]></content>
    
    
    <categories>
      
      <category>我与我，周旋久</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【苦】客户端嵌套浏览器内核：C#+WinForm+Cefsharp</title>
    <link href="/2021/12/29/2021-12-29-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B5%8C%E5%A5%97%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8CSharp+WinForm+Cefsharp/"/>
    <url>/2021/12/29/2021-12-29-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B5%8C%E5%A5%97%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8CSharp+WinForm+Cefsharp/</url>
    
    <content type="html"><![CDATA[<p>老师要求把之前做的Mediasoup网页端，做个客户端出来，目测是不难，但是实现的过程里遇到了很多坎，记录下过程，也是吐槽宣泄下情绪~~</p><h1 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h1><p>因为实验室的工程项目都是用C#做的，再加上自己最近学的Java形式风格和C#很像，于是没怎么思考就以C#为前提搜索了</p><h3 id="老旧库"><a href="#老旧库" class="headerlink" title="老旧库"></a>老旧库</h3><p>一开始搜到的，都是十几年前的技术：</p><ul><li>WebKit</li><li>WebBrowser</li><li><a href="https://github.com/Erls-Corporation/open-webkit-sharp">Open-Webkit-Sharp（WebKit的升级版）</a></li></ul><p>这些库都是十年前最后一次更新，一看都不是很好的选择</p><h3 id="CefSharp"><a href="#CefSharp" class="headerlink" title="CefSharp"></a>CefSharp</h3><p>搜到3个老旧库之后，于是把搜索时间缩短到1年之内，果然搜到了目前的选择：CefSharp。看了它的 <a href="https://github.com/cefsharp/CefSharp/">github</a>，最近一直在更新，于是顺利确定</p><h1 id="搭建工程并测试"><a href="#搭建工程并测试" class="headerlink" title="搭建工程并测试"></a>搭建工程并测试</h1><p>一开始参考这些教程：<a href="https://www.eskysky.com/1645.html">网址1</a>、<a href="https://www.cnblogs.com/SavionZhang/p/15169863.html">网址2</a></p><p>确实能成功运行，访问一些静态网站，但是对于我的Mediasoup项目（有一些JavaScript交互的），画面却一直卡住</p><p>于是继续去官网索罗，发现官方提供一个最小化配置的<a href="https://github.com/cefsharp/CefSharp.MinimalExample">工程demo</a>，在这个基础上你可以继续搭建你要的东西，于是开心下载，直接运行并访问我的服务器地址，成功，贼开心</p><blockquote><p>注：</p><p>如果Visual Studio里打开工程文件，里面有很多报错提示，可以不用管，直接运行是成功的。</p><ul><li>如果实在看不顺眼，可以将 <code>Any CPU</code> 改成 <code>x64</code> 或者 <code>x86</code> ，报错就会消失</li></ul></blockquote><h1 id="坎坷的插曲"><a href="#坎坷的插曲" class="headerlink" title="坎坷的插曲"></a>坎坷的插曲</h1><p>成功运行之后，第一件想做的事就是让软件初始化的时候，直接访问我的服务器地址，而不是 Google，想当然以为把代码里所有涉及到 <code>www.google.com</code> 的地方直接改成我的服务器IP地址， 结果跑下来并不对</p><p>于是想当然以为应该需要更深层次的修改，于是搜索关键词 <code>&quot;cefsharp网址&quot;</code> ，结果当时跳出来的都是关于“重定向”的，一开始没多细想，觉得重定向也行，判断当前访问的google网址的话，重定向到我的服务器就行。结果一顿搜，一顿试，一顿失败，整个人都丧了起来</p><blockquote><p>记录下对于“重定向”而言有用的网址，基本都提到要重写一个接口函数：</p><ul><li>个人博客类<ul><li><a href="https://blog.csdn.net/little_code/article/details/105515747">网址1</a></li><li><a href="http://www.cocoachina.com/articles/103105">网址2</a></li><li><a href="https://magpcss.org/ceforum/viewtopic.php?f=10&t=13320#p27200">网址3</a></li></ul></li><li>官方文档类<ul><li><a href="%5Bhttps://github.com/cefsharp/CefSharp/wiki/CefSharp%E4%B8%AD%E6%96%87%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3#a1%5D(https://github.com/cefsharp/CefSharp/wiki/CefSharp%E4%B8%AD%E6%96%87%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3#a1)">网址1</a></li><li><a href="https://github.com/cefsharp/CefSharp/wiki/General-Usage#request-handling">网址2</a></li></ul></li><li>可能不对口类<ul><li><a href="https://www.yesdotnet.com/archive/post/1619002218.html">网址1</a></li><li><a href="https://www.codebye.com/chromiumwebbrowser-loadpageasync.html">网址2</a></li></ul></li></ul></blockquote><p>后来准备放弃了，盯着界面发呆，突然发现我界面没有按钮，但是代码是写了按钮，这才发现我运行的不是我改的程序，惊呼WC~~</p><h4 id="所以教训来了"><a href="#所以教训来了" class="headerlink" title="所以教训来了~~"></a>所以教训来了~~</h4><p>Visual Studio里的解决方案可能包含多个工程文件，而你运行只会运行其中一个（粗体名字的那个），所以当你想运行另外一个文件时，就需要右键那个工程文件，点击 <code>设为启动项目</code> </p><blockquote><p>所以改初始化的地址，就只需要把初始化browser的网址换掉就行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">browser = new ChromiumWebBrowser(&quot;www.google.com&quot;);<br>// 换成服务器IP即可<br>browser = new ChromiumWebBrowser(&quot;服务器IP&quot;)<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>咋说呢，感觉这种很蠢的问题，真正要解决，都是在突然驻足的无意间发现的，不可复制</p><p>所以累了的时候，被打击了的时候，歇歇也不是坏事，说不定发个呆就发现问题在哪儿了hhh</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《在人间》张子选</p><p>“你承诺过的月亮，还是没有出现；而我无眠，或者，我只是衣单天寒地，替你多爱了一夜人间。”</p></blockquote><p>写得好，我艳羡过这样的诗意和文笔，但对于现在的我而言，倒没有太大波澜了，人生还有太多要追寻的东西，不必留念~~</p>]]></content>
    
    
    <categories>
      
      <category>程序猿的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>WinForm</tag>
      
      <tag>CefSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【嘿】关于代理的那些事儿</title>
    <link href="/2021/12/26/2021-12-26-%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <url>/2021/12/26/2021-12-26-%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%90%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    
    <content type="html"><![CDATA[<p>对于科学上网这件事，都是我的舍友们给我开启了门，而之后的事情，便是我自己的一些摸索</p><h1 id="浏览器等普通上网"><a href="#浏览器等普通上网" class="headerlink" title="浏览器等普通上网"></a>浏览器等普通上网</h1><p>最开始是SSR（酸酸乳），后来是Clash。这些都是代理的工具，而具体用的服务器，就是要各凭本事找了，目前用的是渡口</p><div class="note note-info">            <p>渡口提供了各个系统的版本，我自己在Windows，Ubuntu，Android都实验成功，用到现在还挺好</p>          </div><blockquote><p>注：一些小问题</p><p>在安装了渡口以后，如果不开软件，可能就上不了网，暂时没研究出怎么改回去</p></blockquote><h1 id="CMD命令行"><a href="#CMD命令行" class="headerlink" title="CMD命令行"></a>CMD命令行</h1><p>在配各种环境的时候，常常是在CMD中敲命令行下载的:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install xxxx<br>conda install xxxx<br>npm install xxxx<br>.<br>.<br>.<br></code></pre></td></tr></table></figure><p>而这种情况下，即使你开了Clash也是不能代理的，需要额外执行下面语句：</p><div class="note note-info">            <p>Windows</p>          </div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> http_proxy=http://127.0.0.1:7890<br><span class="hljs-built_in">set</span> https_proxy=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>Ubuntu</p>          </div><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:7890<br><span class="hljs-built_in">export</span> https_proxy=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>7890是Clash的默认代理端口</p><p>另外有个很奇怪的事没弄明白，即使我关闭Clash中的开关按钮，命令行里依然可以代理下载东西，感觉这个按钮只能管控浏览器的代理</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>上述的两种代理方式，已经满足一个程序猿的大部分需求了</p><div class="note note-secondary">            <p>特别是CMD，之前配环境要用各种镜像源设置，而且可能不是最新的，现在直接去官方下，解决所有根本问题</p>          </div><p>翻过这座山，遍是烂漫花开</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>鲁迅</p><p>人一旦悟透了就会变得沉默，不是没有与人相处的能力，而是没有了逢人作戏的兴趣</p></blockquote><p>上学时只觉得鲁迅的文章晦涩难懂，等到了大学没了语文课，却每每被生活里的突现所惊艳。细细想来，并不是我成长成熟，而只是枯燥的理工世界让这亮色过于耀眼</p>]]></content>
    
    
    <categories>
      
      <category>程序猿的技能栽树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Proxy</tag>
      
      <tag>CMD</tag>
      
      <tag>Clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【豁】重搭博客：Hexo+Fluid主题</title>
    <link href="/2021/12/25/2021-12-25-%E9%87%8D%E6%90%AD%E5%8D%9A%E5%AE%A2_Hexo_fluid/"/>
    <url>/2021/12/25/2021-12-25-%E9%87%8D%E6%90%AD%E5%8D%9A%E5%AE%A2_Hexo_fluid/</url>
    
    <content type="html"><![CDATA[<p>之前搭博客的时候，有很多小问题没有解决（网页显示有出入，Github也提示有安全漏洞），于是乎准备重搭下博客~~</p><h1 id="正确流程"><a href="#正确流程" class="headerlink" title="正确流程"></a>正确流程</h1><blockquote><p>以下流程针对Windows系统，已正确复现好几遍，放心食用~~</p></blockquote><h3 id="前期环境准备"><a href="#前期环境准备" class="headerlink" title="前期环境准备"></a>前期环境准备</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">因为最近成功在各个系统的网页+cmd上代理成功，所以现在偏向于用<span class="hljs-built_in">npm</span>安装所有环境~~<br></code></pre></td></tr></table></figure><ol><li>nvm</li></ol><blockquote><p>nvm是一种node版本管理器，可以兼容不同node版本并来回切换，强烈推荐~~</p></blockquote><p>去<a href="https://github.com/coreybutler/nvm-windows/releases">官网</a>下载 <code>nvm-setup.zip</code>，解压安装即可（装之前切记卸载所有node版本）</p><p>（另外参考：<a href="https://juejin.cn/post/6867816303025979399">网址</a>）</p><ol start="2"><li>node+npm</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 常用指令</span><br><span class="hljs-comment"># 1.显示系统已有的node版本</span><br>nvm list<br><span class="hljs-comment"># 2.安装指定版本的node+npm</span><br>nvm install x.x.x<br><span class="hljs-comment"># 3.使用指定版本的node_npm</span><br>nvm use x.x.x<br></code></pre></td></tr></table></figure><p>执行指令2+3即可</p><blockquote><p>注：</p><p>如果有安装乱码报错啥的，是因为cmd没有管理员权限，用管理员身份打开即可</p></blockquote><h3 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h3><blockquote><p>参考：<a href="https://blog.csdn.net/yaorongke/article/details/119089190">博客网址</a>，<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a></p></blockquote><ol><li><p>安装Hexo</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><p>新建项目并初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># xxx如果省略，则不单独创建文件夹</span><br>hexo init xxx<br><span class="hljs-built_in">cd</span> xxx<br>npm install<br></code></pre></td></tr></table></figure></li><li><p>启动并测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># g: generate，编译生成可执行文件</span><br>hexo g<br><span class="hljs-comment"># s: server，本地测试</span><br>hexo s<br></code></pre></td></tr></table></figure></li><li><p>访问：<a href="http://localhost:4000，会看到如下图所示，即为测试成功">http://localhost:4000，会看到如下图所示，即为测试成功</a>~~</p></li></ol><p><img src="/2021/12/25/2021-12-25-%E9%87%8D%E6%90%AD%E5%8D%9A%E5%AE%A2_Hexo_fluid/Hexo%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%BD%91%E7%AB%99%E7%95%8C%E9%9D%A2.png" alt="Hexo初始化的网站界面"></p><h3 id="Fluid主题安装"><a href="#Fluid主题安装" class="headerlink" title="Fluid主题安装"></a>Fluid主题安装</h3><blockquote><p>参考：<a href="https://hexo.fluid-dev.com/docs/start/">Fluid官网</a></p></blockquote><ol><li><p>博客目录里执行命令，下载Fluid</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>复制 <code>./themes/fluid/_config.yml</code> 到博客根目录下，并改名为 <code>_config.fluid.yml</code> </p></li><li><p>修改 <code>_config_yml</code> 中的 <code> theme</code> 和 <code>language</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure></li><li><p>启动并测试，同样访问：<a href="http://localhost:4000，测试成功">http://localhost:4000，测试成功</a>~~</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># g: generate，编译生成可执行文件</span><br>hexo g<br><span class="hljs-comment"># s: server，本地测试</span><br>hexo s<br></code></pre></td></tr></table></figure></li></ol><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>记录些基本操作：</p><h3 id="“关于”-页面"><a href="#“关于”-页面" class="headerlink" title="“关于” 页面"></a>“关于” 页面</h3><ol><li><p>生成 “关于” 页面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new page about<br></code></pre></td></tr></table></figure></li><li><p>修改关于页面内容：<code>/source/about/index.md</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: about<br>date: 2020-02-23 19:20:33<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br><br>这里写关于页的正文，支持 Markdown, HTML<br></code></pre></td></tr></table></figure></li></ol><h3 id="普通日志"><a href="#普通日志" class="headerlink" title="普通日志"></a>普通日志</h3><ol><li><p>修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>生成普通日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new post xxxx-xx-xx-xxxxxxxxxx<br></code></pre></td></tr></table></figure><p>执行完即可在<code>source/_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p></li></ol><h3 id="Hexo的专属小语法"><a href="#Hexo的专属小语法" class="headerlink" title="Hexo的专属小语法"></a>Hexo的专属小语法</h3><h5 id="普通标签"><a href="#普通标签" class="headerlink" title="普通标签"></a>普通标签</h5><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="xml">#格式，其中xxx可选：primary secondary success danger info light </span><br><span class="xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> xxx %&#125;</span><span class="xml"></span><br><span class="xml">xxxx(文字和 markdown 语法皆可)</span><br><span class="xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></td></tr></table></figure><p>例如：</p><ol><li></li></ol><div class="note note-primary">            <p>primary</p>          </div><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> primary %&#125;</span><span class="xml"></span><br><span class="xml">primary</span><br><span class="xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li></li></ol><div class="note note-secondary">            <p>secondary</p>          </div><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> secondary %&#125;</span><span class="xml"></span><br><span class="xml">secondary</span><br><span class="xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></td></tr></table></figure><ol start="3"><li></li></ol><div class="note note-success">            <p>success</p>          </div><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&#123;% note success %&#125;<br><span class="hljs-keyword">success</span><br><span class="hljs-keyword"></span>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li></li></ol><div class="note note-danger">            <p>danger</p>          </div><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> danger %&#125;</span><span class="xml"></span><br><span class="xml">danger</span><br><span class="xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></td></tr></table></figure><ol start="5"><li></li></ol><div class="note note-info">            <p>info</p>          </div><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&#123;%<span class="hljs-built_in"> note </span><span class="hljs-builtin-name">info</span> %&#125;<br><span class="hljs-builtin-name">info</span><br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><p>6.</p><div class="note note-light">            <p>light</p>          </div><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">note</span> light %&#125;</span><span class="xml"></span><br><span class="xml">light</span><br><span class="xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">endnote</span> %&#125;</span><br></code></pre></td></tr></table></figure><h5 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h5><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">#格式，其中xxx可选：primary <span class="hljs-keyword">default</span> info success <span class="hljs-keyword">warning</span> danger<br>&#123;% label xxx @文字 %&#125;<br></code></pre></td></tr></table></figure><ol><li></li></ol><span class="label label-primary">文字</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">label</span> primary @文字 %&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li></li></ol><span class="label label-default">文字</span><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">&#123;% label <span class="hljs-keyword">default</span> @文字 %&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li></li></ol><span class="label label-info">文字</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">label</span> info @文字 %&#125;</span><br></code></pre></td></tr></table></figure><ol start="4"><li></li></ol><span class="label label-success">文字</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">label</span> success @文字 %&#125;</span><br></code></pre></td></tr></table></figure><ol start="5"><li></li></ol><span class="label label-warning">文字</span><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">&#123;% label <span class="hljs-keyword">warning</span> @文字 %&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li></li></ol><span class="label label-danger">文字</span><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">label</span> danger @文字 %&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Github-gitee发布"><a href="#Github-gitee发布" class="headerlink" title="Github+gitee发布"></a>Github+gitee发布</h3><blockquote><p>参考：<a href="https://blog.csdn.net/yakuaback/article/details/104513748">网址</a></p></blockquote><ol><li><p>安装 <code>hexo-deployer-git</code> </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>Github 和 Gitee 中新建仓库</p><blockquote><p>Github 仓库名称为：xxxxx.github.io</p><p>Gitee 仓库名称为：xxxxx</p></blockquote></li><li><p>修改根目录下的 <code>_config.yml</code>，配置 <code>deploy</code> 相关信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <br>    <span class="hljs-attr">github:</span> <span class="hljs-string">git@github.com:oldsandyoungman/oldsandyoungman.github.io.git</span><br>    <span class="hljs-attr">gitee:</span> <span class="hljs-string">git@gitee.com:oldsandyoungman/oldsandyoungman.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br>  <span class="hljs-comment"># token: xxxxxxxxxxxxxx</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注：</p><p>因为我之前配置git时配置了SSH密钥，所以不需要最后一行token（token是用https链接访问时要用到的，获取方式： <code>GitHub</code>  -  <code>Settings</code> - <code>Developer settings</code> - <code>Personal access tokens</code> - <code>Generate new token</code>）</p>          </div></li><li><p>部署到 <code>Github</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo g -d<br></code></pre></td></tr></table></figure></li><li><p>访问 <code>https://oldsandyoungman.github.io</code> 或者 <code>https://oldsandyoungman.gitee.io</code> 即可</p></li></ol><div class="note note-success">            <p>基本内容就这些惹，还有很多细节可以之后再补充（基本都在 <code>_config.fluid.yml</code> 里，而且是中文注释，没啥大问题的）</p>          </div><h1 id="其它一些小记"><a href="#其它一些小记" class="headerlink" title="其它一些小记"></a>其它一些小记</h1><p>一开始找教程的时候，想的还是原来的next主题，参考了官网和其它一些网址：<a href="https://github.com/next-theme/hexo-theme-next">网址1</a>、<a href="https://theme-next.js.org/">网址2</a></p><p>但是部署到Github上时，总是加载不全，最后不得不放弃next主题。后来看看Fluid主题也很顺眼，甚至觉得高级感也有，于是就换成Fluid的了</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>搭完了，也累了，洗洗睡了</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>《言叶之庭》</p><p>隐约雷鸣，阴霾天空，但盼风雨来，能留你在此</p><p>隐约雷鸣，即使天无雨，我亦留此地</p></blockquote><p>看了<a href="https://www.bilibili.com/video/BV1MY411W78X">木鱼水心的《言叶之庭》拉片</a>，第一次看拉片，对于拉片这个类型的视频真的由衷敬佩，也对电影本身以及导演的考虑respect。觉得新海诚这个导演可以再了解了解，刻画得这么细腻，要么本身有类似经历，要么就是感官的敏锐成为某种程度的天才</p>]]></content>
    
    
    <categories>
      
      <category>程序员的优雅之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub / Gitee</tag>
      
      <tag>Blog</tag>
      
      <tag>Fluid主题</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【嗯】装Ubuntu系统</title>
    <link href="/2021/12/21/2021-12-21-%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/12/21/2021-12-21-%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>因为要做毕设的开题报告，准备稍微copy点别人的代码跑通找找自信（嘿嘿）。然后大部分人深度学习的环境都是建在ubuntu上，吃过太多windows配环境的苦的我，决定重装下ubuntu系统从头开始（配环境总让人觉得电脑深处有太多奇怪的环境配置残留，重启大法总是让人舒畅，遇事不决重装就对了~~）</p><p>在笔记本和台式机上都重装成功之后，记录下过程，留给未来作参考~~</p><h1 id="系统盘制作"><a href="#系统盘制作" class="headerlink" title="系统盘制作"></a>系统盘制作</h1><h3 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h3><ul><li><p>U盘</p><p>一个8G的U盘应该足够应付任何版本的Ubuntu系统了</p></li><li><p><a href="https://rufus.ie/zh/">rufus</a>（免费）/ UltralSO（要想办法，易破解之类）</p><p>两个软件都行，感觉rufus操作更简单些</p></li><li><p><a href="https://ubuntu.com/download/alternative-downloads">Ubuntu镜像文件</a></p></li></ul><p><img src="/2021/12/21/2021-12-21-%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/ubuntu%E5%8E%86%E5%8F%B2%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD.png" alt="ubuntu历史镜像下载"></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>下载好镜像文件，插入U盘，打开rufus，选择好U盘和镜像文件，其它都是默认，点开始就行（好像也不用格式化233）</p><p><img src="/2021/12/21/2021-12-21-%E8%A3%85Ubuntu%E7%B3%BB%E7%BB%9F/rufus%E5%88%B6%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%98.png" alt="ubuntu历史镜像下载"></p><h1 id="Ubuntu系统安装"><a href="#Ubuntu系统安装" class="headerlink" title="Ubuntu系统安装"></a>Ubuntu系统安装</h1><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li>重启电脑，疯狂按键弹出BIOS</li></ol><blockquote><p>笔记本（暗影精灵）：ESC</p><p>台式电脑：F12</p></blockquote><ol start="2"><li><p>选择U盘启动（可以不用UEFI）</p></li><li><p>进入Ubuntu安装界面，一次选择：</p></li></ol><ul><li>语言：中文</li><li>键盘布局：英文（美）</li><li>有跳wifi界面就连wifi</li><li>不安装第三方的东西</li><li>清空整个磁盘安装（个人倾向的强迫症，分配空间总是会失败）</li><li>时间：上海</li><li>设置用户名和密码</li></ul><ol start="4"><li>关机，拔掉U盘重启，进入安装好的Ubuntu系统</li></ol><blockquote><p>注：</p><p>如果是18.04版本，进入系统有可能出现屏幕倒置的问题：</p><p>解决办法：右上角的设置旁边的按钮，是禁用自动翻转，禁用后重启即可</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>暂时就这些内容，关于Ubuntu系统装哪些软件，准备开另外一篇文章写写</p><p>然后想额外设置个小栏目《渡何处》，每篇文章都加一些最近看到的有意思的话做结~~</p><h2 id="渡何处"><a href="#渡何处" class="headerlink" title="渡何处"></a>渡何处</h2><blockquote><p>任何过于先进的科技对普通人来说都像是魔法一样。你们觉得那可能是魔法，但那只是你未曾企及的科技而已</p></blockquote><p>来自采访稚晖君的<a href="https://b23.tv/z2T7Fnr">视频</a>，有时候学累了，看看大佬们的人文性质的思考，确实能补充点鸡血。</p><p>愿我也有对技术最纯粹的追求和热爱，来抵抗未来的所有迷茫坎坷~~</p>]]></content>
    
    
    <categories>
      
      <category>天下苦配环境久矣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>装系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【省】重启博客</title>
    <link href="/2021/12/20/2021-12-20-%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/12/20/2021-12-20-%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久不见，甚是想念~~</p><p>大四心血来潮，想建一个博客，结果3分钟热度，写了搭建博客的过程+鬼畜学习之路，就停更了。</p><p>因为我自己每天在有道云上写日记，所以也并没有输出需求的问题，所以博客目前对我而言的意义其实是一个展示平台。</p><p>但最近，因为我的日记愈显纷繁杂乱，在找之前一些配置工程的笔记时，花了很长时间甚至没找到（有道云的搜索功能感觉不是那么靠谱），再加上最近再填微软的暑期实习报名时提到了一条个人博客，所以综上两条原因，我想重启下我的博客，在最后找工作前，丰富下我的github内容，看起来更高级些~~</p><h1 id="博客的内容规整"><a href="#博客的内容规整" class="headerlink" title="博客的内容规整"></a>博客的内容规整</h1><p>重启还是需要一些仪式感滴，于是把博客的分类稍作细化规整~~</p><p>暂时分成了下面几个栏目：</p><blockquote><ul><li>程序媛的优雅之路<ul><li>一些可视化的工作，例如博客的配置，网页的制作</li></ul></li><li>天下苦配环境久矣<ul><li>各种配环境的过程记录，报错梳理</li></ul></li><li>程序猿的技能栽树<ul><li>各种项目所用的框架学习，记录些基本指令</li></ul></li><li>程序缘的内功修炼<ul><li>各种基本功，例如数据结构与算法、计算机网络</li></ul></li><li>另一个我之鬼畜求索<ul><li>学习鬼畜制作的工作手册</li></ul></li><li>另一个我之摄影<ul><li>学习摄影的点滴记录</li></ul></li><li>我与我，周旋久<ul><li>写点随笔，随想</li></ul></li></ul></blockquote><p>然后最近也在学摄影，所以首页和文章的配图就用最近觉得拍得好看的皂片~~</p><h1 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h1><p>定个小目标，希望自己一周能更新一篇文章，这样就能在找工作之前丰满起来~~</p><p>其实现在我已经积累了很多素材了，比如配各种环境，webrtc的学习笔记，所以其实即使这周没什么素材，也可以整理之前的内容</p><p>加油，冲冲冲~~</p>]]></content>
    
    
    <categories>
      
      <category>我与我，周旋久</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【记】博客进阶_小功能1</title>
    <link href="/2020/04/04/2020-04-04-%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6_%E5%B0%8F%E5%8A%9F%E8%83%BD1/"/>
    <url>/2020/04/04/2020-04-04-%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6_%E5%B0%8F%E5%8A%9F%E8%83%BD1/</url>
    
    <content type="html"><![CDATA[<p>不想学习~~</p><p>然后就在摸索一些博客的小功能，看到别人的评论区和访客统计很羡慕，所以用了一些时间把这些功能摸索出来，整理如下：</p><br><h1 id="添加评论区"><a href="#添加评论区" class="headerlink" title="添加评论区"></a>添加评论区</h1><p>这个借鉴的也就是原来搭博客教程的那位<a href="http://logos23333.top/other/2018/02/12/%E4%BA%94%E5%88%86%E9%92%9F%E5%BB%BA%E5%A5%BD%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">仁兄</a>，用的是<a href="https://livere.com/">来必力</a>。</p><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>这步其实没什么困难，但是因为是韩国网站，在填写发到邮箱的验证码时，它的页面是不自动跳转的，然后提示信息是韩文我也没看，所以我一直以为是没反应，点了3、4次发送验证码，后来去百度翻译了一下才懂，很尴尬hh~</p><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>填写你的网站域名（xxx.github.io），就可以生成代码：</p><p><img src="/2020/04/04/2020-04-04-%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6_%E5%B0%8F%E5%8A%9F%E8%83%BD1/1.jpg" alt="代码示例"><br>重要的信息是图中的 <code>uid</code> ，即黄色部分的一串代码。</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开 <code>_config.yml</code> 文件，搜索 “livere” ，将上面的那串 <code>uid</code> 代码填入相应位置即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Support for LiveRe comments system.</span><br><span class="hljs-comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span><br><span class="hljs-attr">livere_uid:</span> <span class="hljs-string">xxxxxxxx</span><br></code></pre></td></tr></table></figure><br><br><h1 id="添加访客统计"><a href="#添加访客统计" class="headerlink" title="添加访客统计"></a>添加访客统计</h1><p>使用的是 <a href="https://leancloud.cn/">leancloud</a> ，参考自 <a href="https://blog.csdn.net/laugh12321/article/details/85232176">博客</a> (里面也有其他很多小功能，以后有时间再研究)</p><h3 id="注册账号-1"><a href="#注册账号-1" class="headerlink" title="注册账号"></a>注册账号</h3><p>进入 <code>控制台</code> 注册，需要实名认证，不然不能创建应用</p><h3 id="创建应用，生成Keys"><a href="#创建应用，生成Keys" class="headerlink" title="创建应用，生成Keys"></a>创建应用，生成Keys</h3><p>起一个名字，单击创建即可<img src="/2020/04/04/2020-04-04-%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6_%E5%B0%8F%E5%8A%9F%E8%83%BD1/2.jpg" alt="代码示例"></p><p>点击上图的 <code>设置</code> 按钮，并进入 <code>应用Keys</code><img src="/2020/04/04/2020-04-04-%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6_%E5%B0%8F%E5%8A%9F%E8%83%BD1/3.jpg" alt="代码示例"></p><p>复制上面的 <code>AppID</code> 和 <code>AppKey</code> </p><h3 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开 <code>_config.yml</code> 文件，搜索 “leancloud” ，将上面的 <code>AppID</code> 和 <code>AppKey</code> 分别填入相应位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Show number of visitors to each article.</span><br><span class="hljs-comment"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="hljs-attr">leancloud_visitors:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">app_id:</span> <span class="hljs-string">xxxxxxx</span> <span class="hljs-comment">#&lt;app_id&gt;</span><br>  <span class="hljs-attr">app_key:</span> <span class="hljs-string">xxxxxxx</span> <span class="hljs-comment">#&lt;app_key&gt;</span><br></code></pre></td></tr></table></figure><p>打开 <code>_includes/_partials/footer.html</code> 文件</p><ul><li><p>在 <code>&lt;div class=&quot;copyright&quot; &gt;</code> 之前加入下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code> &#123;沙% if site.copyright %哥&#125; </code> 之后加入下面的代码：</p><p>（上面的“沙”“哥”是为了防止报错，不加的话在编译过程中会误认为是logic tag，自己没有好好学过这些知识，以后看看能不能有更好的办法美化一下）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;powered-by&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-user-md&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_container_site_uv&quot;</span>&gt;</span><br>  本站访客数:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>然后就ok啦~~</p>]]></content>
    
    
    <categories>
      
      <category>程序员的优雅之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub / Gitee</tag>
      
      <tag>Blog</tag>
      
      <tag>Next主题</tag>
      
      <tag>Jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【记】鬼畜沙哥成长记</title>
    <link href="/2020/03/28/2020-03-28-%E5%88%9D%E9%81%87%E9%AC%BC%E7%95%9C/"/>
    <url>/2020/03/28/2020-03-28-%E5%88%9D%E9%81%87%E9%AC%BC%E7%95%9C/</url>
    
    <content type="html"><![CDATA[<p>从搭建博客到现在写了两三篇博文，自己花了很多时间成本，试验出一些能在Github上正确显示的写法，但依然有很多小问题没能解决（现在的状态是勉强让我的审美强迫症安分下来，hia）</p><p>大一的时候（也就是2016年），自己才真正意义上接触B站，接触鬼畜，当时被几个视频震撼了，觉得卧槽还能这样，牛逼牛逼~~</p><blockquote><p><a href="https://www.bilibili.com/video/BV1Zs411X7N9">【康熙说唱王朝】部落到帝国·怒斥群臣</a></p><p><a href="https://www.bilibili.com/video/BV12s411S7w8">【三国笑传】你见过这么魔性的曹操吗？</a></p></blockquote><br><p>之后便立下一个flag，要自己做一个鬼畜视频。</p><p>结果这一立，就是3年过去了，自己学习、思想上都迷茫了一阵子，大四才侥幸有了时间，在毕业设计的间隙中，抽了一个礼拜学习做了一下，拙作如下，请君莫笑~~：</p><blockquote><p><a href="https://www.bilibili.com/video/BV1LE411c7o5">【半鬼畜+半剪辑】罗翔老师之圆圈正义论</a></p></blockquote><br><p>过程很艰难，可能不是鬼畜的料，略作小叙，给未来的自己留下些笑料~~</p><br><br><h1 id="鬼畜分类"><a href="#鬼畜分类" class="headerlink" title="鬼畜分类"></a>鬼畜分类</h1><p>觉得这个挺有必要聊聊的，因为一开始没有分清些概念，一通瞎学，学了很多我不喜欢类型的鬼畜制作方法，时间成本有些多~~</p><p>下面是我的认知分类</p><blockquote><p>鬼畜调教：视频的剪辑拼凑（画面+声音）。没有调音（改变声音的音调）</p><ul><li>工具：视频软件即可，如：Vegas，Pr 等。</li></ul><p>音MAD：视频的剪辑拼凑（画面+声音）。会单独对声音进行调音，并且声音往往选择一个片段（乐器或者人声），调节出不同时间长短不同音高，来拼接成完整的曲目。</p><ul><li>工具：视频软件（如 Vegas，Pr 等），调音工具（如 UTAU，Melody，FL studio ，Au等）。</li></ul><p>人力VOCALOID：视频的剪辑拼凑（画面+声音）。会单独对声音进行调音，并且在此基础上，进行填词（这个是大手笔）。</p><ul><li>工具：视频软件（如 Vegas，Pr 等），调音工具（如 UTAU，Melody，FL studio ，Au等）。</li></ul></blockquote><p>在B站上找资源学习的时候，大部分其实都是关于后两者的教程，但我目前其实更想做鬼畜调教（更有鬼畜的那种通过反复倒放的原始趣味性，也更容易些 hia~~），音MAD 和 人力VOCALOID 可能要等我好好学习积累点内功才行（一不小心就会让声音失真，听不出来是谁的声音，所以调音是一门很大的学问）。</p><br><br><h1 id="鬼畜调教之How-to-play"><a href="#鬼畜调教之How-to-play" class="headerlink" title="鬼畜调教之How to play"></a>鬼畜调教之How to play</h1><p>鬼畜调教的教程其实少的可怜，因为使用软件之类的虽然可以出教程比较显式，但是会用之后，更复杂的，如何反复如何踩点如何调词序，有太多细节和无法成文成系统的东西，不大好出教程，感觉只能靠自己摸索和看大佬的教程去感受，有些小僵硬。</p><blockquote><p>关于踩点和调词序，这些除了鬼畜方面的技巧，个人感觉其实很大程度上还是跟乐理音律的硬知识有关（鬼畜也要音乐人的基本素养，诶~~）</p></blockquote><p>所以这里给出一些我搜刮下来比较好的教程，慢慢铺垫，我自己有时间也可以从头好好学学。</p><br><h3 id="视频软件教程——Vegas"><a href="#视频软件教程——Vegas" class="headerlink" title="视频软件教程——Vegas"></a>视频软件教程——Vegas</h3><p>对于鬼畜，其实视频软件更推荐Vegas（个人的经验是，因为鬼畜需要大量的伸缩音频的时间长短，这个在Pr等软件里较为僵硬，自己要手动取输入，而在Vegas里只要拖一下鼠标就行）。</p><blockquote><p>觉得讲得最详细最耐心的教程：<a href="https://www.bilibili.com/video/BV16E411d7rD">Vegas-从零基础到大神视频教程</a></p></blockquote><br><h3 id="关于节奏打点"><a href="#关于节奏打点" class="headerlink" title="关于节奏打点"></a>关于节奏打点</h3><p>其实本质上学了视频软件后，基本没啥可以再学的，之后就是自己瞎玩玩 ~~ 不过有一个视频觉得对我帮助很大，就是如何将一个BGM的节拍可视化出来，这个对于后期调词序踩点啥的都很有用，非常推荐。</p><blockquote><p>卡点推荐：<a href="https://www.bilibili.com/video/BV1qb411K74x">100%卡点教学</a></p></blockquote><br><br><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>是的，这么快就到结语了，因为真的没啥可以系统学习了，全靠后期的积累和一时的灵感。就多看大佬的作品，自己也多练习，两者结合并重复，必将大成~~</p><blockquote><p> 祝你成为超人！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>鬼畜的求索之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>鬼畜</tag>
      
      <tag>Vegas</tag>
      
      <tag>FL studio</tag>
      
      <tag>B站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【待】博客进阶手册</title>
    <link href="/2020/03/28/2020-03-28-%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E6%89%8B%E5%86%8C/"/>
    <url>/2020/03/28/2020-03-28-%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>从搭建博客到现在写了两三篇博文，自己花了很多时间成本，试验出一些能在Github上正确显示的写法，但依然有很多小问题没能解决（现在的状态是勉强让我的审美强迫症安分下来，hia）</p><p>之后的进阶或是小问题的解决，其实就是不断地学习基础知识了，路漫漫修远哉 ~~</p><p>先列出以后要学的东西，至于实不实现，可能要到好久以后bia ~~</p><blockquote><ul><li>HTML语言</li><li>CSS</li><li>Jekyll（<a href="http://jekyllcn.com/docs/home/">官方文档</a>）</li><li>Typora（<a href="https://sspai.com/post/54912">大佬的博客</a>，<a href="http://support.typora.io/">官方文档（有太多细节）</a>）</li></ul></blockquote><br><p>要忙一段时间学习啦，这个暂且丢下，来日再见~~</p>]]></content>
    
    
    <categories>
      
      <category>程序员的优雅之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>Jekyll</tag>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【记】markdown基本语法总结</title>
    <link href="/2020/03/27/2020-03-27-markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/27/2020-03-27-markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>一条一条慢慢来 ~<br>&emsp;<br><br></p><br><h1 id="换行：-lt-br-gt"><a href="#换行：-lt-br-gt" class="headerlink" title="换行：&lt;br&gt;"></a>换行：<code>&lt;br&gt;</code></h1><br><br># 空格：```&emsp;xxx``` 在&emsp;很久很久&emsp;以前<br><br># 首行缩进：```&emsp;&emsp;xxx```&emsp;&emsp;在很久很久以前<br><br># 分割线：--- ---<br># 大小标题：前面加n个 “#”<h1 id="Heading-1"><a href="#Heading-1" class="headerlink" title="Heading 1"></a>Heading 1</h1><h2 id="Heading-2"><a href="#Heading-2" class="headerlink" title="Heading 2"></a>Heading 2</h2><h3 id="Heading-3"><a href="#Heading-3" class="headerlink" title="Heading 3"></a>Heading 3</h3><h4 id="Heading-4"><a href="#Heading-4" class="headerlink" title="Heading 4"></a>Heading 4</h4><h5 id="Heading-5"><a href="#Heading-5" class="headerlink" title="Heading 5"></a>Heading 5</h5><h6 id="Heading-6"><a href="#Heading-6" class="headerlink" title="Heading 6"></a>Heading 6</h6><br><br># 文字效果：## 超链接：```[域名](www.xxx.com)```效果： [百度](https://www.baidu.com)<br>## 加粗：```**xxx**```效果：**Strong text**<br>## 斜体：```*xxx*```效果：*Italic text*<br>## 下划线：```<u>xxxx</u>```效果：<u>Underline text</u><br><h2 id="删除线：-xxx"><a href="#删除线：-xxx" class="headerlink" title="删除线：~~xxx~~"></a>删除线：<code>~~xxx~~</code></h2><p>效果：<del>Deleted text</del><br><br></p><h2 id="小代码块：just-xxx-这样"><a href="#小代码块：just-xxx-这样" class="headerlink" title="小代码块：just` xxx `这样"></a>小代码块：<code>just` xxx `这样</code></h2><p>效果：<code>Sed erat diam</code><br><br></p><h2 id="大代码块："><a href="#大代码块：" class="headerlink" title="大代码块："></a>大代码块：</h2><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">按tab键（就像这一行）<br><span class="hljs-title">或者:</span><br>`沙`哥`C（去掉沙哥，仅演示）<br>xxx<br>`沙`哥`（去掉沙哥，仅演示）<br></code></pre></td></tr></table></figure><p>效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><br><h2 id="引用文章：-gt-xxx"><a href="#引用文章：-gt-xxx" class="headerlink" title="引用文章：&gt;xxx"></a>引用文章：<code>&gt;xxx</code></h2><p>效果：</p><blockquote><p>我可没说过。                ——鲁迅    </p></blockquote><br>## 上浮 & 下沉：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">上浮：<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br>下沉：<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br></code></pre></td></tr></table></figure>效果： <sup>上浮</sup> 正常 <sub>下沉</sub> <br><br><h1 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>.数字编号：<br></code></pre></td></tr></table></figure><ol><li>一</li><li>二</li><li>三<br></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">b</span>.符号编号：- xxxx<br></code></pre></td></tr></table></figure><ul><li>一</li><li>二</li><li>三<br></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">c.引用里编号：&gt;* <span class="hljs-comment">(空格)</span>xxx<br></code></pre></td></tr></table></figure><blockquote><p>沙哥牛逼（打了空格首行缩进，但木有显示，不知道咋解决，嘤嘤嘤）</p><ul><li>每日几句 </li><li>如果你发现一个事物很绚烂，要么真牛逼，要么快死掉了。</li><li>我的成长让我相信：人生最重要的东西，其实大都没有什么用：爱情，正义，自由，尊严，知识，文明，这些一再在灰黯时刻拯救我、安慰我的力量，对很多人来讲‘没有用’，我却坚持相信，这些才都是人生的珍宝，才经得起反复的追求。</li><li>世上有味之事，往往无用。吟无用之诗，醉无用之酒，读无用之书，钟无用之情，终于成一无所用之人，却因此活得有滋有味</li></ul></blockquote><br><h1 id="表格："><a href="#表格：" class="headerlink" title="表格：| --- | --- | --- |"></a>表格：<code>| --- | --- | --- |</code></h1><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 学号          </span>|<span class="hljs-string"> 姓名      </span>|<span class="hljs-string">  备注     </span>|<br>|<span class="hljs-string"> --------      </span>|<span class="hljs-string"> -----:   </span>|<span class="hljs-string"> :----:   </span>|<br>|<span class="hljs-string"> 1             </span>|<span class="hljs-string"> 1号      </span>|<span class="hljs-string"> 牛逼      </span>|<br>|<span class="hljs-string"> 2             </span>|<span class="hljs-string"> 2号      </span>|<span class="hljs-string"> 牛逼      </span>|<br>|<span class="hljs-string"> 3             </span>|<span class="hljs-string"> 3号      </span>|<span class="hljs-string"> 牛逼      </span>|<br>|<span class="hljs-string"> （左起）       </span>|<span class="hljs-string"> （右起）   </span>|<span class="hljs-string"> （居中）  </span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>学号</th><th align="right">姓名</th><th align="center">备注</th></tr></thead><tbody><tr><td>1</td><td align="right">1号</td><td align="center">牛逼</td></tr><tr><td>2</td><td align="right">2号</td><td align="center">牛逼</td></tr><tr><td>3</td><td align="right">3号</td><td align="center">牛逼</td></tr><tr><td>（左起）</td><td align="right">（右起）</td><td align="center">（居中）</td></tr></tbody></table><br><h1 id="任务清单：-待办1；-x-待办2"><a href="#任务清单：-待办1；-x-待办2" class="headerlink" title="任务清单：- [ ] 待办1；- [x] 待办2"></a>任务清单：<code>- [ ] 待办1；- [x] 待办2</code></h1><ul><li><input disabled type="checkbox"> 练习markdown</li><li><input checked disabled type="checkbox"> 稍微熟练写法</li></ul><p>（难，清单的格式有编号的前缀，所以Github上两者同时出现，将就下bia ~ ~）</p><br><br><h1 id="公式：-G-m-g"><a href="#公式：-G-m-g" class="headerlink" title="公式：$ $  G=m*g  $ $"></a>公式：$ $  G=m*g  $ $</h1><p>$$ G=m*g $$</p><br><br><h1 id="插图片："><a href="#插图片：" class="headerlink" title="插图片："></a>插图片：</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">本地：!<span class="hljs-selector-attr">[xxx]</span>(<span class="hljs-attribute">file</span>:<span class="hljs-comment">///C:\Users\xxx\xxx.jpg)</span><br>网络：![xxx](<span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.github.com/username/username.github.io/_posts/image/xxx.jpg)</span><br></code></pre></td></tr></table></figure><p>全称网址：<br><img src="https://github.com/oldsandyoungman/oldsandyoungman.github.io/blob/master/assets/art_pig.jpg" alt="art_pig1"><br>相对网址：<br><img src="/assets/images_sha/art_pig.jpg" alt="art_pig2"></p><br><br><h1 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h1><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">沙`哥`傻`flow(<span class="hljs-string">\：使用前去掉沙哥傻，这里为了演示代码)</span><br>st=&gt;start: 大象和冰箱<br>op=&gt;operation: 将大象塞入冰箱<br>cond=&gt;condition: 塞得下吗?<br>e=&gt;end<br><br>st-&gt;op-&gt;cond<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">yes</span>)</span>-&gt;</span>e<br>cond<span class="hljs-function"><span class="hljs-params">(<span class="hljs-literal">no</span>)</span>-&gt;</span>op<br>沙`哥`傻`(<span class="hljs-string">\：使用前去掉沙哥傻，这里为了演示代码)</span><br></code></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start: 大象和冰箱<br>op=&gt;operation: 将大象塞入冰箱<br>cond=&gt;condition: 塞得下吗?<br>e=&gt;end<br><br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br><br></code></pre></td></tr></table></figure><p>（貌似显示不粗来，应该还不能用呀）</p>]]></content>
    
    
    <categories>
      
      <category>程序员的优雅之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【记】Github和Gitee上搭建博客</title>
    <link href="/2020/03/27/2020-03-27-Github%E5%92%8CGitee%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/03/27/2020-03-27-Github%E5%92%8CGitee%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>折腾了可能有3、4天，才用  <a href="http://jekyllcn.com/">Jekyll</a> + <a href="https://github.com/Simpleyyt/jekyll-theme-next">Next</a> 搭建好个人博客（<code>Windows</code> 配置 <code>Jekyll</code> 挺不友好的），其中参考了很多教程和博客，最后正常运行，但是其中的原理还是没有太明白。<br><br><br><br>梳理下大概的流程，以后有时间在新系统上重新配置一遍：<br><br><br><br><br><br></p><h1 id="Windows下-Jekyll的Next主题搭建"><a href="#Windows下-Jekyll的Next主题搭建" class="headerlink" title="Windows下 Jekyll的Next主题搭建"></a>Windows下 Jekyll的Next主题搭建</h1><h3 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h3><ol><li><p>下载<a href="https://rubyinstaller.org/">Ruby官网的Windows版本exe</a>（菜菜的我爱着傻瓜式的exe）</p><ul><li><a href="http://jekyllcn.com/docs/windows/#installation">官方教程</a>上是用<a href="https://chocolatey.org/install">chocolatey</a>作为平台再安装Ruby的，但是后面的步骤遇到一些版本不匹配问题，所以我后来舍弃了。不同人的电脑配置不同，可以尝试。</li></ul></li><li><p>运行exe到最后一步，先不启动Windows PowerShell（不打勾），换下源（不然速度太慢，参考 <a href="https://blog.csdn.net/mscf/article/details/82627951">this blog</a>）</p></li><li><p>管理员身份运行cmd，输入“ridk install”并回车，安装1和3</p></li><li><p>看网上的说法2非必要，然后我自己装了2出现了点问题，卸载了单独装1+3才好的，我也解释不清楚</p></li></ol><br><h3 id="利用-gem-安装-nokogiri-（不确定是不是必要项）"><a href="#利用-gem-安装-nokogiri-（不确定是不是必要项）" class="headerlink" title="利用 gem 安装 nokogiri （不确定是不是必要项）"></a>利用 gem 安装 nokogiri （不确定是不是必要项）</h3><ol><li><p>先换源：（完事第一步）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gem sources -a http:<span class="hljs-regexp">//g</span>ems.ruby-china.com/<br></code></pre></td></tr></table></figure></li><li><p><a href="http://jekyllcn.com/docs/windows/#installation">官方教程</a>的说法是很多参数的命令行：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">gem install nokogiri --^<br>   --with-xml2-include=C:<span class="hljs-symbol">\C</span>hocolatey<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\l</span>ibxml2.2.7.8.7<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\n</span>ative<span class="hljs-symbol">\i</span>nclude^<br>   --with-xml2-lib=C:<span class="hljs-symbol">\C</span>hocolatey<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\l</span>ibxml2.redist.2.7.8.7<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\n</span>ative<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\v</span>110<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\R</span>elease<span class="hljs-symbol">\d</span>ynamic<span class="hljs-symbol">\c</span>decl^<br>   --with-iconv-include=C:<span class="hljs-symbol">\C</span>hocolatey<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\l</span>ibiconv.1.14.0.11<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\n</span>ative<span class="hljs-symbol">\i</span>nclude^<br>   --with-iconv-lib=C:<span class="hljs-symbol">\C</span>hocolatey<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\l</span>ibiconv.redist.1.14.0.11<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\n</span>ative<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\v</span>110<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\R</span>elease<span class="hljs-symbol">\d</span>ynamic<span class="hljs-symbol">\c</span>decl^<br>   --with-xslt-include=C:<span class="hljs-symbol">\C</span>hocolatey<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\l</span>ibxslt.1.1.28.0<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\n</span>ative<span class="hljs-symbol">\i</span>nclude^<br>   --with-xslt-lib=C:<span class="hljs-symbol">\C</span>hocolatey<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\l</span>ibxslt.redist.1.1.28.0<span class="hljs-symbol">\b</span>uild<span class="hljs-symbol">\n</span>ative<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\v</span>110<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\R</span>elease<span class="hljs-symbol">\d</span>ynamic<br></code></pre></td></tr></table></figure><ul><li>这部分因为我反复卸载用了很多方法，不确定哪个奏效，留个坑</li></ul></li></ol><br><h3 id="利用gem安装Github-pages"><a href="#利用gem安装Github-pages" class="headerlink" title="利用gem安装Github-pages"></a>利用gem安装Github-pages</h3><ol><li><p>安装bundle，输入如下命令行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gem <span class="hljs-keyword">install</span> bundler<br></code></pre></td></tr></table></figure><ul><li>关于<a href="https://www.jianshu.com/p/bcbb278e9208">bundle的作用，和Gem的关系</a></li></ul></li><li><p>本地博客的根目录下，手动建立名为“Gemfile”的无后缀文件，在该文件中写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-string">&#x27;http://rubygems.org&#x27;</span><br>gem <span class="hljs-string">&#x27;github-pages&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>如果是用别人的模板（比如在下，git了<a href="https://github.com/Simpleyyt/jekyll-theme-next">Next主题</a>的模板，然后在上面改），那么就下载好文件到你的博客目录下，里面自带“Gemfile”文件的。</li></ul></li><li><p>命令行切换到本地博客的根目录，输入： </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">bundle <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure></li><li><p>按照道理，之后就可以正常运行了。启动：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">jekyll <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure></li><li><p>如果出现“exec”啥的报错（具体不大记得了~~），就换下面的命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bundle </span>exec <span class="hljs-keyword">jekyll </span>server<br></code></pre></td></tr></table></figure></li></ol><br><br><br># 修改配置 + 写博客### 修改配置这一部分就是在根目录下的_config.yml文件中进行修改，我列一些我用到的配置项（用文本编辑器打开，搜一个改一个 ~）<br>#### 网站的基本信息：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">沙沙响</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">Rustling</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">佛曰：God</span> <span class="hljs-string">bless</span> <span class="hljs-string">you~</span> <br><span class="hljs-attr">author:</span> <span class="hljs-string">沙哥</span><br><span class="hljs-comment"># Support language: de, en, fr-FR, id, ja, ko, pt-BR, pt, ru, zh-Hans, zh-hk, zh-tw</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-Hans</span><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span><br></code></pre></td></tr></table></figure>注意：zh-Hans 即简体中文，名称的选取是源自 /_data/languages/ 目录下的文件名<br><h4 id="域名："><a href="#域名：" class="headerlink" title="域名："></a>域名：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com&#x27; and baseurl as &#x27;/child&#x27;</span><br><span class="hljs-attr">url:</span><br><span class="hljs-attr">baseurl:</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">pretty</span><br><br></code></pre></td></tr></table></figure><p>如果之后挂载到 Gitee 上，那么需要配置（具体见 3.2 Gitee篇），Github实验下来貌似不需要。</p><br><h4 id="浏览器标签页的小标"><a href="#浏览器标签页的小标" class="headerlink" title="浏览器标签页的小标"></a>浏览器标签页的小标</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Put your favicon.ico into `assets/` directory.</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/assets/art_pig.jpg</span><br><br></code></pre></td></tr></table></figure><p>即浏览器标签页的小图标，就像这样：</p><p><img src="/assets/images_sha/favicon.jpg" alt="favicon"></p><br><h4 id="菜单的内容和相应图标"><a href="#菜单的内容和相应图标" class="headerlink" title="菜单的内容和相应图标"></a>菜单的内容和相应图标</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ---------------------------------------------------------------</span><br><span class="hljs-comment"># Menu Settings</span><br><span class="hljs-comment"># ---------------------------------------------------------------</span><br><br><span class="hljs-comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)</span><br><span class="hljs-attr">menu:</span><br>  <span class="hljs-attr">home:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-string">/categories/</span><br>  <span class="hljs-attr">about:</span> <span class="hljs-string">/about/</span><br>  <span class="hljs-attr">archives:</span> <span class="hljs-string">/archives/</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">/tags/</span><br>  <span class="hljs-comment">#sitemap: /sitemap.xml</span><br>  <span class="hljs-comment">#commonweal: /404.html</span><br><br><br><span class="hljs-comment"># Enable/Disable menu icons.</span><br><span class="hljs-comment"># Icon Mapping:</span><br><span class="hljs-comment">#   Map a menu item to a specific FontAwesome icon name.</span><br><span class="hljs-comment">#   Key is the name of menu item and value is the name of FontAwesome icon. Key is case-senstive.</span><br><span class="hljs-comment">#   When an question mask icon presenting up means that the item has no mapping icon.</span><br><span class="hljs-attr">menu_icons:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment">#KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</span><br>  <span class="hljs-attr">home:</span> <span class="hljs-string">home</span><br>  <span class="hljs-attr">about:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-string">th</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">calendar</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">tags</span><br>  <span class="hljs-attr">archives:</span> <span class="hljs-string">archive</span><br>  <span class="hljs-attr">sitemap:</span> <span class="hljs-string">sitemap</span><br>  <span class="hljs-attr">commonweal:</span> <span class="hljs-string">heartbeat</span><br><br></code></pre></td></tr></table></figure><br><h4 id="Next主题的几大样式选择"><a href="#Next主题的几大样式选择" class="headerlink" title="Next主题的几大样式选择"></a>Next主题的几大样式选择</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-comment"># ---------------------------------------------------------------</span><br><span class="hljs-comment"># Scheme Settings</span><br><span class="hljs-comment"># ---------------------------------------------------------------</span><br><br><span class="hljs-comment"># Schemes</span><br><span class="hljs-comment">#scheme: Muse</span><br><span class="hljs-comment">#scheme: Mist</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">Pisces</span><br><br></code></pre></td></tr></table></figure><p>Pisces 是你当前看到的样式，分为左右两栏</p><br><h4 id="菜单栏下方的联系方式及相应图标"><a href="#菜单栏下方的联系方式及相应图标" class="headerlink" title="菜单栏下方的联系方式及相应图标"></a>菜单栏下方的联系方式及相应图标</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># ---------------------------------------------------------------</span><br><span class="hljs-comment"># Sidebar Settings</span><br><span class="hljs-comment"># ---------------------------------------------------------------</span><br><br><br><span class="hljs-comment"># Social Links</span><br><span class="hljs-comment"># Key is the link label showing to end users.</span><br><span class="hljs-comment"># Value is the target link (E.g. GitHub: https://github.com/iissnan)</span><br><span class="hljs-attr">social:</span><br>  <span class="hljs-comment">#LinkLabel: Link</span><br>  <span class="hljs-attr">GitHub:</span> <span class="hljs-string">https://github.com/oldsandyoungman</span><br>  <span class="hljs-attr">School:</span> <span class="hljs-string">http://www.seu.edu.cn</span><br><br><br><span class="hljs-comment"># Social Links Icons</span><br><span class="hljs-comment"># Icon Mapping:</span><br><span class="hljs-comment">#   Map a menu item to a specific FontAwesome icon name.</span><br><span class="hljs-comment">#   Key is the name of the item and value is the name of FontAwesome icon. Key is case-senstive.</span><br><span class="hljs-comment">#   When an globe mask icon presenting up means that the item has no mapping icon.</span><br><span class="hljs-attr">social_icons:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># Icon Mappings.</span><br>  <span class="hljs-comment"># KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome</span><br>  <span class="hljs-attr">GitHub:</span> <span class="hljs-string">github</span><br>  <span class="hljs-attr">Twitter:</span> <span class="hljs-string">twitter</span><br>  <span class="hljs-attr">Weibo:</span> <span class="hljs-string">weibo</span><br>  <span class="hljs-attr">School:</span> <span class="hljs-string">university</span><br><br></code></pre></td></tr></table></figure><p>这里我借鉴别人的，也是设置了 Github 和我大学的官网，也可以添加其他链接</p><br><h4 id="你的头像"><a href="#你的头像" class="headerlink" title="你的头像"></a>你的头像</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Sidebar Avatar</span><br><span class="hljs-comment"># in directory: /assets/images/avatar.gif</span><br><span class="hljs-comment">#avatar:</span><br><span class="hljs-attr">in directory:</span> <br><span class="hljs-attr">avatar:</span> <span class="hljs-string">assets/art_pig.jpg</span><br><br></code></pre></td></tr></table></figure><p>可以用动图gif，我没试验hiahia</p><br><h4 id="侧栏属性"><a href="#侧栏属性" class="headerlink" title="侧栏属性"></a>侧栏属性</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">sidebar:</span><br>  <span class="hljs-comment"># Sidebar Position, available value: left | right</span><br>  <span class="hljs-attr">position:</span> <span class="hljs-string">left</span><br>  <span class="hljs-comment">#position: right</span><br><br>  <span class="hljs-comment"># Sidebar Display, available value:</span><br>  <span class="hljs-comment">#  - post    expand on posts automatically. Default.</span><br>  <span class="hljs-comment">#  - always  expand for all pages automatically</span><br>  <span class="hljs-comment">#  - hide    expand only when click on the sidebar toggle icon.</span><br>  <span class="hljs-comment">#  - remove  Totally remove sidebar including sidebar toggle.</span><br>  <span class="hljs-comment">#display: post</span><br>  <span class="hljs-attr">display:</span> <span class="hljs-string">always</span><br>  <span class="hljs-comment">#display: hide</span><br>  <span class="hljs-comment">#display: remove</span><br><br>  <span class="hljs-comment"># Sidebar offset from top menubar in pixels.</span><br>  <span class="hljs-attr">offset:</span> <span class="hljs-number">12</span><br>  <span class="hljs-attr">offset_float:</span> <span class="hljs-number">0</span><br><br>  <span class="hljs-comment"># Back to top in sidebar</span><br>  <span class="hljs-attr">b2t:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># Scroll percent label in b2t button</span><br>  <span class="hljs-attr">scrollpercent:</span> <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><p>我关注的是 <code>display: always</code>，就是无论浏览哪个页面和如何滚动，都不会省略侧边栏</p><br><h4 id="其他社交链接"><a href="#其他社交链接" class="headerlink" title="其他社交链接"></a>其他社交链接</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Blog rolls</span><br><span class="hljs-attr">links_title:</span> <span class="hljs-string">Links</span><br><span class="hljs-comment">#links_layout: block</span><br><span class="hljs-comment">#links_layout: inline</span><br><span class="hljs-attr">links:</span><br>  <span class="hljs-comment">#Title: http://example.com/</span><br>  <span class="hljs-string">B站:</span> <span class="hljs-string">https://space.bilibili.com/129371092</span><br><br></code></pre></td></tr></table></figure><p>我挂了个B站作为例子</p><br><h4 id="背景动画"><a href="#背景动画" class="headerlink" title="背景动画"></a>背景动画</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Canvas-nest</span><br><span class="hljs-attr">canvas_nest:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># three_waves</span><br><span class="hljs-attr">three_waves:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># canvas_lines</span><br><span class="hljs-attr">canvas_lines:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># canvas_sphere</span><br><span class="hljs-attr">canvas_sphere:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># Only fit scheme Pisces</span><br><span class="hljs-comment"># Canvas-ribbon</span><br><span class="hljs-attr">canvas_ribbon:</span> <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><p>这个我玩得最起劲，觉得贼几把炫酷 ~~</p><br><br><hr><blockquote><p>其他一些高级功能我之后有时间再慢慢探索 ~~~</p></blockquote><hr><br><br><h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><ol><li><p>在根目录的 _post 文件夹下，新建：年-月-日-标题（例如2020-03-27-我是标题）的md后缀文件</p></li><li><p>文件内容分为两部分。</p><ul><li><p>第一部分是一些配置信息，例如我这篇博客列出了一些基本信息，按照格式填写即可：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: 【记】Github和Gitee上搭建博客<br>date: 2020<span class="hljs-string">-03</span><span class="hljs-string">-27</span> 14:32:20<br>category: 程序员的优雅之路<br><span class="hljs-keyword">tags:</span><br>- GitHub / Gitee<br>- Blog<br>- Next主题<br>description: 那些年我们走过的那些坑<br></code></pre></td></tr></table></figure></li><li><p>第二部分是正文，正常的markdown语言就行</p></li></ul></li></ol><ol start="3"><li>保存并且上传后，过一阵子刷新你的个人博客即可</li></ol><br><h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><p>正常的markdown语言的加载图片，用的是全称网址，例如我在本地博客下的 assets 文件夹下建立 images_sha 来存放我用到的图片，那么加载图片的格式应该是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">![名字](https:<span class="hljs-regexp">//</span>www.github.com<span class="hljs-regexp">/xxxx/</span>xxxx.github.io<span class="hljs-regexp">/assets/im</span>ages_sha/xxx.jpg)<br></code></pre></td></tr></table></figure><p><img src="https://github.com/oldsandyoungman/oldsandyoungman.github.io/blob/master/assets/images_sha/art_pig.jpg" alt="art_pig"></p><p>但是我现在实验下来并没有成功（<strong>例如上面就是一个失败的案例，不知道阁下显示是否正常</strong>），后来在网上找到相对路径的方法倒是成功了，所以目前都用的相对路径来写博客。</p><br><p>用相对路劲的话，我的markdown是 Typora 编辑器，在“格式”-“图像”-“设置图像根目录…”，选中本地博客的根目录，之后加载图片就可以用如下指令：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![名字](<span class="hljs-regexp">/assets/im</span>ages_sha/xxx.jpg)<br></code></pre></td></tr></table></figure><p><img src="/assets/images_sha/art_pig.jpg" alt="art_pig"></p><p>另外值得注意的是，当在 _post 文件夹下建立图片时，貌似 Github 上无法显示（知乎上 <a href="https://www.zhihu.com/question/31123165/answer/274501351">这篇回答</a> 提到），所以建议不要在 _post 文件夹下放置图片</p><br><br><br><h1 id="Github-和-Gitee-上的配置"><a href="#Github-和-Gitee-上的配置" class="headerlink" title="Github 和 Gitee 上的配置"></a>Github 和 Gitee 上的配置</h1><p>总体而言，Github配置较为简单，因为Github服务器的配置环境版本较新，我加载下来没有出现乱码啥的<sub>（当然速度较慢是必然的）</sub>；而Gitee的环境版本较为落后，所以有时候我加载下来不对，会让有些小烦躁。</p><ul><li>关于两者环境的具体说明：<a href="https://www.cnblogs.com/xjtu-blacksmith/p/jekyll-of-pages.html">this blog</a></li></ul><br><h3 id="Github篇"><a href="#Github篇" class="headerlink" title="Github篇"></a>Github篇</h3><ol><li><p>新建一个Repository，命名为 xxxxx.github.io（xxxxx为你的用户名）</p></li><li><p>将你本地的博客全部 push 上去（关于 git 的概念和操作，建议从头学一遍<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰大佬的博客</a>，毕竟作为程序员之后将与 git 常相伴随 ~~ ），具体而言</p><ul><li><p>安装好 git </p></li><li><p>在 git bash 中，进入你的博客所在的根目录</p></li><li><p>输入命令，初始化仓库：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure></li><li><p>输入命令，将仓库所有东西 add 到本地的暂存区</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-builtin-name">add</span> .<br></code></pre></td></tr></table></figure></li><li><p>输入命令，将暂存区的东西提交，并且写一个备注”xxxx”</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;xxxx&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>输入命令，查看本地仓库连接的远端服务器情况</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote -v</span><br></code></pre></td></tr></table></figure></li><li><p>如果之前已经设定过，就跳过；没有的话添加账户：（origin是自己给远端起的名字，xxxx是用户名）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git remote add origin git@github<span class="hljs-selector-class">.com</span>:xxxx/xxxx<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>.git<br></code></pre></td></tr></table></figure></li><li><p>输入命令，把本地的master，提交给远端的origin</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure></li></ul></li><li><p>到这里其实就应该算结束了，如果不出意外，输入xxxxx.github.io就能看到你的博客了</p></li></ol><br><br><h3 id="Gitee篇"><a href="#Gitee篇" class="headerlink" title="Gitee篇"></a>Gitee篇</h3><ol><li><p>首先，将本地博客根目录下的 _config.yml 文件中，url 等字段进行修改。</p><p>例如我 Gitee 上个人博客的网址为：<a href="https://gitee.com/oldsandyoungman/blog%EF%BC%8C%E9%82%A3%E4%B9%88">https://gitee.com/oldsandyoungman/blog，那么</a> _config.yml 文件中部分内容则修改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com&#x27; and baseurl as &#x27;/child&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://oldsandyoungman.gitee.io/blog</span><br><span class="hljs-attr">baseurl:</span> <span class="hljs-string">/blog</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">pretty</span><br></code></pre></td></tr></table></figure></li><li><p>之后的上传步骤同理，不过在添加远端名字时，需要将“Github”的网址，改成你Gitee上的相应网址，例如我 Gitee 上个人博客的网址为：<a href="https://gitee.com/oldsandyoungman/blog%EF%BC%8C">https://gitee.com/oldsandyoungman/blog，</a></p><p> 那么就将</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git remote add origin git@github<span class="hljs-selector-class">.com</span>:oldsandyoungman/oldsandyoungman<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span>.git<br></code></pre></td></tr></table></figure><p> 改为</p> <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git remote <span class="hljs-keyword">add</span> origin git<span class="hljs-title">@gitee.com</span>:oldsandyoungman/blog.git<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li>最后，在Gitee的你的仓库页面，点击“服务”，选中“Gitee Pages”，然后就可以生成你的博客啦 ~~</li></ol>]]></content>
    
    
    <categories>
      
      <category>程序员的优雅之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub / Gitee</tag>
      
      <tag>Blog</tag>
      
      <tag>Next主题</tag>
      
      <tag>Jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
